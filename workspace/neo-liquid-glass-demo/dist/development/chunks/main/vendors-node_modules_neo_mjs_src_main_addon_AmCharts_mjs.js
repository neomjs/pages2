"use strict";
(self["webpackChunkmyapp"] = self["webpackChunkmyapp"] || []).push([["vendors-node_modules_neo_mjs_src_main_addon_AmCharts_mjs"],{

/***/ "./node_modules/neo.mjs/src/main/addon/AmCharts.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/neo.mjs/src/main/addon/AmCharts.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/neo.mjs/src/main/addon/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DomAccess.mjs */ "./node_modules/neo.mjs/src/main/DomAccess.mjs");



/**
 * Helper class to include amCharts into your neo.mjs app
 * https://www.amcharts.com/docs/v4/
 * @class Neo.main.addon.AmCharts
 * @extends Neo.main.addon.Base
 */
class AmCharts extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.AmCharts'
         * @protected
         */
        className: 'Neo.main.addon.AmCharts',
        /**
         * Stores all chart ids inside an object
         * @member {Object} charts={}
         * @protected
         */
        charts: {},
        /**
         * Stores all chart data inside an object. key => chart id
         * No array since in case a chart gets loaded multiple times, we only want to apply the last data on mount.
         * @member {Object} dataMap={}
         * @protected
         */
        dataMap: {},
        /**
         * @member {String} downloadPath='https//cdn.amcharts.com/lib/4/'
         * @protected
         */
        downloadPath: 'https://cdn.amcharts.com/lib/4/',
        /**
         * @member {String} fallbackPath='https://raw.githubusercontent.com/neomjs/pages/main/resources_pub/amCharts'
         * @protected
         */
        fallbackPath: 'https://raw.githubusercontent.com/neomjs/pages/main/resources_pub/amCharts/',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'callMethod',
                'create',
                'destroy',
                'setProperties',
                'setProperty',
                'updateData'
            ]
        },
        /**
         * Enforce using the fallbackPath
         * @member {Boolean} useFallbackPath=false
         * @protected
         */
        useFallbackPath: false
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        super.afterSetIsReady(value, oldValue);

        if (value) {
            let me = this;

            me.timeout(1000).then(() => {
                Object.entries(me.dataMap).forEach(([key, dataValue]) => {
                    me.updateData(dataValue)
                });

                me.dataMap = {}
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.path
     * @param {Array} [data.params]
     */
    callMethod(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'callMethod', data})
        } else {
            if (me.hasChart(data.id)) {
                let chart      = me.charts[data.id],
                    pathArray  = data.path.split('.'),
                    methodName = pathArray.pop(),
                    scope      = pathArray.length < 1 ? chart:  Neo.ns(pathArray.join('.'), false, chart);

                scope[methodName].call(scope, ...data.params || [])
            } else {
                // todo
            }
        }
    }

    /**
     * @param {Object} chart
     */
    combineSeriesTooltip(chart) {
        chart.series.each(series => {
            series.adapter.add('tooltipText', () => {
                let text = "[bold]{dateX}[/]\n";

                chart.series.each(item => {
                    text += "[" + item.stroke + "]â—[/] " + item.name + ": {" + item.dataFields.valueY + "}\n"
                });

                return text
            })
        })
    }

    /**
     * @param {Object}  data
     * @param {Boolean} data.combineSeriesTooltip
     * @param {Object}  data.config
     * @param {Array}   [data.data]
     * @param {String}  [data.dataPath]
     * @param {String}  data.id
     * @param {String}  data.package
     * @param {String}  data.type='XYChart'
     */
    create(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'create', data})
        } else {
            // todo: check if globalThis[data.package] exists, if not load it and call create afterwards
            am4core.useTheme(am4themes_dark);

            me.charts[data.id] = am4core.createFromConfig(data.config, data.id, globalThis[data.package][data.type || 'XYChart']);

            if (data.combineSeriesTooltip) {
                me.combineSeriesTooltip(me.charts[data.id])
            }

            // in case data has arrived before the chart got created, apply it now
            if (data.data) {
                me.updateData({
                    data    : data.data,
                    dataPath: data.dataPath,
                    id      : data.id
                })
            } else if (me.dataMap[data.id]) {
                me.updateData(me.dataMap[data.id]);
                delete me.dataMap[data.id]
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    destroy(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'destroy', data})
        } else {
            me.charts[data.id]?.dispose?.();
            delete me.charts[data.id]
        }
    }

    /**
     * @param {String} id
     * @returns {Boolean}
     */
    hasChart(id) {
        return !!this.charts[id]
    }

    /**
     * Async approach
     * core.js has to arrive first or the other scripts will cause JS errors since they rely on it
     * => fetching the other files after core.js is loaded
     * @param {Boolean} useFallback=false
     */
    loadFiles(useFallback=false) {
        let me              = this,
            useFallbackPath = me.useFallbackPath || useFallback,
            basePath;

        if (useFallbackPath && Neo.config.isGitHubPages) {
            basePath = '../../../../resources_pub/amCharts/';

            if (Neo.config.environment !== 'development') {
                basePath = `../../${basePath}`
            }
        } else {
            basePath = useFallbackPath ? me.fallbackPath : me.downloadPath
        }

        me.isLoading = true;

        _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'core.js').then(() => {
            Promise.all([
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'charts.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'maps.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'themes/dark.js'),
                _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadScript(basePath + 'geodata/worldLow.js')
            ]).then(() => {
                me.isLoading = false;
                me.isReady   = true
            })
        }).catch(e => {
            if (!useFallback && !me.useFallbackPath) {
                console.log('Download from amcharts.com failed, switching to fallback', e);
                me.loadFiles(true)
            }
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.properties
     */
    setProperties(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'setProperties', data})
        } else {
            Object.entries(data.properties).forEach(([key, value]) => {
                me.setProperty({
                    id   : data.id,
                    path : key,
                    value
                })
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} [data.isColor=false] true will wrap the value into am4core.color()
     * @param {String} data.path
     * @param {*} data.value
     */
    setProperty(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'setProperty', data})
        } else {
            if (this.hasChart(data.id)) {
                let chart        = this.charts[data.id],
                    pathArray    = data.path.split('.'),
                    propertyName = pathArray.pop(),
                    scope        = Neo.ns(pathArray.join('.'), false, chart);

                scope[propertyName] = data.isColor ? am4core.color(data.value) : data.value
            } else {
                // todo
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.data
     * @param {String} data.dataPath
     * @param {String} data.id
     */
    updateData(data) {
        let me = this;

        if (!me.isReady) {
            return me.cacheMethodCall({fn: 'updateData', data})
        } else if (!me.hasChart(data.id)) {
            me.dataMap[data.id] = data
        } else {
            let chart = me.charts[data.id];

            if (data.dataPath === '') {
                chart.data = data.data
            } else {
                Neo.ns(data.dataPath, false, chart).data = data.data
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AmCharts));


/***/ }),

/***/ "./node_modules/neo.mjs/src/main/addon/Base.mjs":
/*!******************************************************!*\
  !*** ./node_modules/neo.mjs/src/main/addon/Base.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true,
        /**
         * Will get set to true once all addon related files got loaded (if there is a need to load)
         * @member {Boolean} isReady_=false
         * @protected
         */
        isReady_: false,
        /**
         * Amount in ms to delay the loading of library files, unless remote method access happens
         * Change the value to false in case you don't want an automated preloading
         * @member {Boolean|Number} preloadFilesDelay=5000
         * @protected
         */
        preloadFilesDelay: 5000,
    }

    /**
     * @member {Object[]} cache=[]
     */
    cache = []
    /**
     * Will get set to true once we start loading Monaco related files
     * @member {Boolean} isLoading=false
     */
    isLoading = false
    /**
     * Internal flag to store the setTimeout() id for loading external files
     * @member {Number|null} loadingTimeoutId=null
     */
    loadingTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.loadFiles) {
            if (me.preloadFilesDelay === 0) {
                me.loadFiles()
            } else if (Neo.isNumber(me.preloadFilesDelay)) {
                me.loadingTimeoutId = setTimeout(() => {
                    me.loadFiles()
                }, me.preloadFilesDelay)
            }
        }
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        if (value) {
            let me = this,
                returnValue;

            me.cache.forEach(item => {
                returnValue = me[item.fn](item.data);
                item.resolve(returnValue)
            });

            me.cache = []
        }
    }

    /**
     * Internally caches call when isReady===false
     * Loads the library files in case this is not already happening
     * @param item
     * @returns {Promise<unknown>}
     */
    cacheMethodCall(item) {
        let me = this;

        if (!me.isLoading) {
            me.loadingTimeoutId && clearTimeout(me.loadingTimeoutId);
            me.loadingTimeoutId = null;
            me.loadFiles()
        }

        return new Promise((resolve, reject) => {
            me.cache.push({...item, resolve})
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vdmVuZG9ycy1ub2RlX21vZHVsZXNfbmVvX21qc19zcmNfbWFpbl9hZGRvbl9BbUNoYXJ0c19tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ007O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FB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UTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9tYWluL2FkZG9uL0FtQ2hhcnRzLm1qcyIsIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9tYWluL2FkZG9uL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgRG9tQWNjZXNzIGZyb20gJy4uL0RvbUFjY2Vzcy5tanMnO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBpbmNsdWRlIGFtQ2hhcnRzIGludG8geW91ciBuZW8ubWpzIGFwcFxuICogaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjQvXG4gKiBAY2xhc3MgTmVvLm1haW4uYWRkb24uQW1DaGFydHNcbiAqIEBleHRlbmRzIE5lby5tYWluLmFkZG9uLkJhc2VcbiAqL1xuY2xhc3MgQW1DaGFydHMgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYWluLmFkZG9uLkFtQ2hhcnRzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgYWxsIGNoYXJ0IGlkcyBpbnNpZGUgYW4gb2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhcnRzPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNoYXJ0czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgYWxsIGNoYXJ0IGRhdGEgaW5zaWRlIGFuIG9iamVjdC4ga2V5ID0+IGNoYXJ0IGlkXG4gICAgICAgICAqIE5vIGFycmF5IHNpbmNlIGluIGNhc2UgYSBjaGFydCBnZXRzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgd2Ugb25seSB3YW50IHRvIGFwcGx5IHRoZSBsYXN0IGRhdGEgb24gbW91bnQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YU1hcD17fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhTWFwOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZG93bmxvYWRQYXRoPSdodHRwcy8vY2RuLmFtY2hhcnRzLmNvbS9saWIvNC8nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRvd25sb2FkUGF0aDogJ2h0dHBzOi8vY2RuLmFtY2hhcnRzLmNvbS9saWIvNC8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmYWxsYmFja1BhdGg9J2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9uZW9tanMvcGFnZXMvbWFpbi9yZXNvdXJjZXNfcHViL2FtQ2hhcnRzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmYWxsYmFja1BhdGg6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbmVvbWpzL3BhZ2VzL21haW4vcmVzb3VyY2VzX3B1Yi9hbUNoYXJ0cy8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnY2FsbE1ldGhvZCcsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ2Rlc3Ryb3knLFxuICAgICAgICAgICAgICAgICdzZXRQcm9wZXJ0aWVzJyxcbiAgICAgICAgICAgICAgICAnc2V0UHJvcGVydHknLFxuICAgICAgICAgICAgICAgICd1cGRhdGVEYXRhJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5mb3JjZSB1c2luZyB0aGUgZmFsbGJhY2tQYXRoXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUZhbGxiYWNrUGF0aD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB1c2VGYWxsYmFja1BhdGg6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc1JlYWR5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJc1JlYWR5KHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS50aW1lb3V0KDEwMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lLmRhdGFNYXApLmZvckVhY2goKFtrZXksIGRhdGFWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlRGF0YShkYXRhVmFsdWUpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5kYXRhTWFwID0ge31cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucGF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtkYXRhLnBhcmFtc11cbiAgICAgKi9cbiAgICBjYWxsTWV0aG9kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnY2FsbE1ldGhvZCcsIGRhdGF9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1lLmhhc0NoYXJ0KGRhdGEuaWQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYXJ0ICAgICAgPSBtZS5jaGFydHNbZGF0YS5pZF0sXG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheSAgPSBkYXRhLnBhdGguc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9IHBhdGhBcnJheS5wb3AoKSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgICAgICA9IHBhdGhBcnJheS5sZW5ndGggPCAxID8gY2hhcnQ6ICBOZW8ubnMocGF0aEFycmF5LmpvaW4oJy4nKSwgZmFsc2UsIGNoYXJ0KTtcblxuICAgICAgICAgICAgICAgIHNjb3BlW21ldGhvZE5hbWVdLmNhbGwoc2NvcGUsIC4uLmRhdGEucGFyYW1zIHx8IFtdKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAgICAgKi9cbiAgICBjb21iaW5lU2VyaWVzVG9vbHRpcChjaGFydCkge1xuICAgICAgICBjaGFydC5zZXJpZXMuZWFjaChzZXJpZXMgPT4ge1xuICAgICAgICAgICAgc2VyaWVzLmFkYXB0ZXIuYWRkKCd0b29sdGlwVGV4dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IFwiW2JvbGRde2RhdGVYfVsvXVxcblwiO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQuc2VyaWVzLmVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gXCJbXCIgKyBpdGVtLnN0cm9rZSArIFwiXeKXj1svXSBcIiArIGl0ZW0ubmFtZSArIFwiOiB7XCIgKyBpdGVtLmRhdGFGaWVsZHMudmFsdWVZICsgXCJ9XFxuXCJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5jb21iaW5lU2VyaWVzVG9vbHRpcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YS5jb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIFtkYXRhLmRhdGFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBbZGF0YS5kYXRhUGF0aF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEucGFja2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS50eXBlPSdYWUNoYXJ0J1xuICAgICAqL1xuICAgIGNyZWF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuY2FjaGVNZXRob2RDYWxsKHtmbjogJ2NyZWF0ZScsIGRhdGF9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9kbzogY2hlY2sgaWYgZ2xvYmFsVGhpc1tkYXRhLnBhY2thZ2VdIGV4aXN0cywgaWYgbm90IGxvYWQgaXQgYW5kIGNhbGwgY3JlYXRlIGFmdGVyd2FyZHNcbiAgICAgICAgICAgIGFtNGNvcmUudXNlVGhlbWUoYW00dGhlbWVzX2RhcmspO1xuXG4gICAgICAgICAgICBtZS5jaGFydHNbZGF0YS5pZF0gPSBhbTRjb3JlLmNyZWF0ZUZyb21Db25maWcoZGF0YS5jb25maWcsIGRhdGEuaWQsIGdsb2JhbFRoaXNbZGF0YS5wYWNrYWdlXVtkYXRhLnR5cGUgfHwgJ1hZQ2hhcnQnXSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNvbWJpbmVTZXJpZXNUb29sdGlwKSB7XG4gICAgICAgICAgICAgICAgbWUuY29tYmluZVNlcmllc1Rvb2x0aXAobWUuY2hhcnRzW2RhdGEuaWRdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbiBjYXNlIGRhdGEgaGFzIGFycml2ZWQgYmVmb3JlIHRoZSBjaGFydCBnb3QgY3JlYXRlZCwgYXBwbHkgaXQgbm93XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgICAgOiBkYXRhLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogZGF0YS5pZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lLmRhdGFNYXBbZGF0YS5pZF0pIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVEYXRhKG1lLmRhdGFNYXBbZGF0YS5pZF0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS5kYXRhTWFwW2RhdGEuaWRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICovXG4gICAgZGVzdHJveShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuY2FjaGVNZXRob2RDYWxsKHtmbjogJ2Rlc3Ryb3knLCBkYXRhfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmNoYXJ0c1tkYXRhLmlkXT8uZGlzcG9zZT8uKCk7XG4gICAgICAgICAgICBkZWxldGUgbWUuY2hhcnRzW2RhdGEuaWRdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDaGFydChpZCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNoYXJ0c1tpZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBhcHByb2FjaFxuICAgICAqIGNvcmUuanMgaGFzIHRvIGFycml2ZSBmaXJzdCBvciB0aGUgb3RoZXIgc2NyaXB0cyB3aWxsIGNhdXNlIEpTIGVycm9ycyBzaW5jZSB0aGV5IHJlbHkgb24gaXRcbiAgICAgKiA9PiBmZXRjaGluZyB0aGUgb3RoZXIgZmlsZXMgYWZ0ZXIgY29yZS5qcyBpcyBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZUZhbGxiYWNrPWZhbHNlXG4gICAgICovXG4gICAgbG9hZEZpbGVzKHVzZUZhbGxiYWNrPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdXNlRmFsbGJhY2tQYXRoID0gbWUudXNlRmFsbGJhY2tQYXRoIHx8IHVzZUZhbGxiYWNrLFxuICAgICAgICAgICAgYmFzZVBhdGg7XG5cbiAgICAgICAgaWYgKHVzZUZhbGxiYWNrUGF0aCAmJiBOZW8uY29uZmlnLmlzR2l0SHViUGFnZXMpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gJy4uLy4uLy4uLy4uL3Jlc291cmNlc19wdWIvYW1DaGFydHMvJztcblxuICAgICAgICAgICAgaWYgKE5lby5jb25maWcuZW52aXJvbm1lbnQgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICBiYXNlUGF0aCA9IGAuLi8uLi8ke2Jhc2VQYXRofWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gdXNlRmFsbGJhY2tQYXRoID8gbWUuZmFsbGJhY2tQYXRoIDogbWUuZG93bmxvYWRQYXRoXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIERvbUFjY2Vzcy5sb2FkU2NyaXB0KGJhc2VQYXRoICsgJ2NvcmUuanMnKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBEb21BY2Nlc3MubG9hZFNjcmlwdChiYXNlUGF0aCArICdjaGFydHMuanMnKSxcbiAgICAgICAgICAgICAgICBEb21BY2Nlc3MubG9hZFNjcmlwdChiYXNlUGF0aCArICdtYXBzLmpzJyksXG4gICAgICAgICAgICAgICAgRG9tQWNjZXNzLmxvYWRTY3JpcHQoYmFzZVBhdGggKyAndGhlbWVzL2RhcmsuanMnKSxcbiAgICAgICAgICAgICAgICBEb21BY2Nlc3MubG9hZFNjcmlwdChiYXNlUGF0aCArICdnZW9kYXRhL3dvcmxkTG93LmpzJylcbiAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1lLmlzUmVhZHkgICA9IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgaWYgKCF1c2VGYWxsYmFjayAmJiAhbWUudXNlRmFsbGJhY2tQYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIGZyb20gYW1jaGFydHMuY29tIGZhaWxlZCwgc3dpdGNoaW5nIHRvIGZhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnc2V0UHJvcGVydGllcycsIGRhdGF9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YS5wcm9wZXJ0aWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zZXRQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBkYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoIDoga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuaXNDb2xvcj1mYWxzZV0gdHJ1ZSB3aWxsIHdyYXAgdGhlIHZhbHVlIGludG8gYW00Y29yZS5jb2xvcigpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldFByb3BlcnR5KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5jYWNoZU1ldGhvZENhbGwoe2ZuOiAnc2V0UHJvcGVydHknLCBkYXRhfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0NoYXJ0KGRhdGEuaWQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYXJ0ICAgICAgICA9IHRoaXMuY2hhcnRzW2RhdGEuaWRdLFxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyYXkgICAgPSBkYXRhLnBhdGguc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gcGF0aEFycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgPSBOZW8ubnMocGF0aEFycmF5LmpvaW4oJy4nKSwgZmFsc2UsIGNoYXJ0KTtcblxuICAgICAgICAgICAgICAgIHNjb3BlW3Byb3BlcnR5TmFtZV0gPSBkYXRhLmlzQ29sb3IgPyBhbTRjb3JlLmNvbG9yKGRhdGEudmFsdWUpIDogZGF0YS52YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5kYXRhUGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICovXG4gICAgdXBkYXRlRGF0YShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuY2FjaGVNZXRob2RDYWxsKHtmbjogJ3VwZGF0ZURhdGEnLCBkYXRhfSlcbiAgICAgICAgfSBlbHNlIGlmICghbWUuaGFzQ2hhcnQoZGF0YS5pZCkpIHtcbiAgICAgICAgICAgIG1lLmRhdGFNYXBbZGF0YS5pZF0gPSBkYXRhXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhcnQgPSBtZS5jaGFydHNbZGF0YS5pZF07XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGFQYXRoID09PSAnJykge1xuICAgICAgICAgICAgICAgIGNoYXJ0LmRhdGEgPSBkYXRhLmRhdGFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTmVvLm5zKGRhdGEuZGF0YVBhdGgsIGZhbHNlLCBjaGFydCkuZGF0YSA9IGRhdGEuZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbUNoYXJ0cyk7XG4iLCJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWFpbiB0aHJlYWQgYWRkb25zXG4gKiBAY2xhc3MgTmVvLm1haW4uYWRkb24uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uYWRkb24uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpZGVudGlmaWVyIGZvciBjb3JlLkJhc2UgdG8gZ2V0IGhhbmRsZWQgbGlrZSBzaW5nbGV0b25zIGZvciByZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc01haW5UaHJlYWRBZGRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzTWFpblRocmVhZEFkZG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSBhbGwgYWRkb24gcmVsYXRlZCBmaWxlcyBnb3QgbG9hZGVkIChpZiB0aGVyZSBpcyBhIG5lZWQgdG8gbG9hZClcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNSZWFkeV89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNSZWFkeV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IGluIG1zIHRvIGRlbGF5IHRoZSBsb2FkaW5nIG9mIGxpYnJhcnkgZmlsZXMsIHVubGVzcyByZW1vdGUgbWV0aG9kIGFjY2VzcyBoYXBwZW5zXG4gICAgICAgICAqIENoYW5nZSB0aGUgdmFsdWUgdG8gZmFsc2UgaW4gY2FzZSB5b3UgZG9uJ3Qgd2FudCBhbiBhdXRvbWF0ZWQgcHJlbG9hZGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufE51bWJlcn0gcHJlbG9hZEZpbGVzRGVsYXk9NTAwMFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwcmVsb2FkRmlsZXNEZWxheTogNTAwMCxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2FjaGU9W11cbiAgICAgKi9cbiAgICBjYWNoZSA9IFtdXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSB3ZSBzdGFydCBsb2FkaW5nIE1vbmFjbyByZWxhdGVkIGZpbGVzXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMb2FkaW5nPWZhbHNlXG4gICAgICovXG4gICAgaXNMb2FkaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3JlIHRoZSBzZXRUaW1lb3V0KCkgaWQgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZmlsZXNcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbG9hZGluZ1RpbWVvdXRJZD1udWxsXG4gICAgICovXG4gICAgbG9hZGluZ1RpbWVvdXRJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmxvYWRGaWxlcykge1xuICAgICAgICAgICAgaWYgKG1lLnByZWxvYWRGaWxlc0RlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzTnVtYmVyKG1lLnByZWxvYWRGaWxlc0RlbGF5KSkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgICAgICAgICB9LCBtZS5wcmVsb2FkRmlsZXNEZWxheSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNSZWFkeSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICAgICAgbWUuY2FjaGUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1lW2l0ZW0uZm5dKGl0ZW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXNvbHZlKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmNhY2hlID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgY2FjaGVzIGNhbGwgd2hlbiBpc1JlYWR5PT09ZmFsc2VcbiAgICAgKiBMb2FkcyB0aGUgbGlicmFyeSBmaWxlcyBpbiBjYXNlIHRoaXMgaXMgbm90IGFscmVhZHkgaGFwcGVuaW5nXG4gICAgICogQHBhcmFtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICAgKi9cbiAgICBjYWNoZU1ldGhvZENhbGwoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBtZS5sb2FkaW5nVGltZW91dElkICYmIGNsZWFyVGltZW91dChtZS5sb2FkaW5nVGltZW91dElkKTtcbiAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZS5jYWNoZS5wdXNoKHsuLi5pdGVtLCByZXNvbHZlfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
"use strict";
(self["webpackChunkmyapp"] = self["webpackChunkmyapp"] || []).push([["node_modules_neo_mjs_src_plugin_Responsive_mjs"],{

/***/ "./node_modules/neo.mjs/src/plugin/Base.mjs":
/*!**************************************************!*\
  !*** ./node_modules/neo.mjs/src/plugin/Base.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }),

/***/ "./node_modules/neo.mjs/src/plugin/Responsive.mjs":
/*!********************************************************!*\
  !*** ./node_modules/neo.mjs/src/plugin/Responsive.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/neo.mjs/src/plugin/Base.mjs");


/**
 * @class Neo.plugin.Responsive
 * @extends Neo.plugin.Base
 */
class Responsive extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Responsive'
         * @protected
         */
        className: 'Neo.plugin.Responsive',
        /**
         * @member {String} ntype='plugin-responsive'
         * @protected
         */
        ntype: 'plugin-responsive',
        /**
         * @member {Map} responsiveConfig: new Map()
         */
        responsiveConfig: new Map(),
        /**
         * @member {Object} defaultResponsiveConfig
         */
        defaultResponsiveConfig: {
            landscape(data) {
                return data.width > data.height
            },
            portrait(data) {
                return data.width < data.height
            }
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        owner.addCls('neo-responsive');

        Neo.first('viewport').addDomListeners([
            {resize: me.onResize, scope: me}
        ])

        Neo.Responsive = Neo.Responsive || {
            responsiveConfig: new Map(),
            apps            : {}
        };

        me.addToResponsiveMap(me.defaultResponsiveConfig, me);
        me.addToResponsiveMap(owner.responsiveConfig || {}, owner);
        me.handleBodyCls()
    }

    /**
     * @param responsiveObj
     * @param scope
     */
    addToResponsiveMap(responsiveObj, scope) {
        for (const [key, value] of Object.entries(responsiveObj)) {
            let fn;

            if (Neo.isObject(value)) {
                fn = function (rect) {
                    let returnBool = true;

                    for (const [subKey, subValue] of Object.entries(value)) {
                        const isMin      = subKey.startsWith('min'),
                              testConfig = subKey.substring(3).toLowerCase();

                        if (isMin) {
                            returnBool = rect[testConfig] >= subValue
                        } else {
                            returnBool = rect[testConfig] <= subValue
                        }

                        if (!returnBool) {
                            break
                        }
                    }

                    return returnBool
                }
            } else {
                fn = value
            }

            fn = fn.bind(scope);

            Neo.Responsive.responsiveConfig.set(key, fn)
        }
    }

    /**
     *
     */
    handleBodyCls() {
        const
            me        = this,
            {appName} = me.owner,
            apps      = Neo.Responsive;

        if (!apps[appName]?.activeBodyUpdate) {
            const viewport = Neo.first('viewport'); // todo

            apps[appName] = {
                appId           : viewport.id,
                activeBodyUpdate: true
            };

            viewport.addDomListeners([
                {resize: me.onResizeBody, scope: me}
            ])
        }
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        const
            me           = this,
            config       = {},
            configTester = Neo.Responsive.responsiveConfig,
            {owner}      = me,
            {responsive} = owner;

        for (const [key, value] of Object.entries(responsive)) {
            const hasKey = configTester.get(key)?.(data.rect);

            if (hasKey) {
                for (const [configKey, configValue] of Object.entries(value)) {
                    if (false) // removed by dead control flow
{} else {
                        config[configKey] = configValue
                    }
                }
            }
        }

        Object.keys(config).length > 0 && owner.set(config)
    }

    /**
     * Add either neo-landscape or neo-portrait to the parent viewport component
     */
    onResizeBody(data) {
        const
            me          = this,
            newRect     = data.contentRect,
            isLandscape = newRect.width >= newRect.height,
            addCls      = isLandscape ? 'neo-landscape' : 'neo-portrait',
            removeCls   = isLandscape ? 'neo-portrait' : 'neo-landscape';

        Neo.applyDeltas(me.appName, {
            id : 'document.body',
            cls: {
                add   : [addCls],
                remove: [removeCls]
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Responsive));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9ub2RlX21vZHVsZXNfbmVvX21qc19zcmNfcGx1Z2luX1Jlc3BvbnNpdmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Rk47O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFNO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixLQUF1RCxFQUFFO0FBQUEsRUFHNUQsQ0FBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9wbHVnaW4vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbXlhcHAvLi9ub2RlX21vZHVsZXMvbmVvLm1qcy9zcmMvcGx1Z2luL1Jlc3BvbnNpdmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBsdWdpbiBpbXBsZW1lbnRhdGlvbnMuXG4gKiBQbHVnaW5zIGFyZSBpbnRlbmRlZCB0byBnZXQgcHV0IGludG8gdGhlIHBsdWdpbnMgY29uZmlnIG9mIGNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmhhbmNlIHRoZW0gb3IgYWRkIGFkZGl0aW9uYWwgZmVhdHVyZXNcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUGx1Z2luIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcGx1Z2luIG50eXBlcyBuZWVkIHRvIHN0YXJ0IHdpdGggJ3BsdWdpbi0nIHRvIGVuc3VyZSB0aGF0IGNvbXBvbmVudC5CYXNlOiBnZXRQbHVnaW4oKSBjYW4gZmluZCB0aGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKG93bmVyLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub25Pd25lckNvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3duZXIubW91bnRlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lck1vdW50ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLm9uKCdtb3VudGVkJywgbWUub25Pd25lck1vdW50ZWQsIG1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCB0aGlzLl9fcHJvdG9fXylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBpcyBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIG9uT3duZXJDb25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgbGV0IHtvd25lcn0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChvd25lci53aW5kb3dJZCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dJZCA9IG93bmVyLndpbmRvd0lkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBsdWdpbik7XG4iLCJpbXBvcnQgUGx1Z2luIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLlJlc3BvbnNpdmVcbiAqIEBleHRlbmRzIE5lby5wbHVnaW4uQmFzZVxuICovXG5jbGFzcyBSZXNwb25zaXZlIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5wbHVnaW4uUmVzcG9uc2l2ZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5SZXNwb25zaXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbi1yZXNwb25zaXZlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi1yZXNwb25zaXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge01hcH0gcmVzcG9uc2l2ZUNvbmZpZzogbmV3IE1hcCgpXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlQ29uZmlnOiBuZXcgTWFwKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlZmF1bHRSZXNwb25zaXZlQ29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0UmVzcG9uc2l2ZUNvbmZpZzoge1xuICAgICAgICAgICAgbGFuZHNjYXBlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS53aWR0aCA+IGRhdGEuaGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9ydHJhaXQoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLndpZHRoIDwgZGF0YS5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBvd25lci5hZGRDbHMoJ25lby1yZXNwb25zaXZlJyk7XG5cbiAgICAgICAgTmVvLmZpcnN0KCd2aWV3cG9ydCcpLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7cmVzaXplOiBtZS5vblJlc2l6ZSwgc2NvcGU6IG1lfVxuICAgICAgICBdKVxuXG4gICAgICAgIE5lby5SZXNwb25zaXZlID0gTmVvLlJlc3BvbnNpdmUgfHwge1xuICAgICAgICAgICAgcmVzcG9uc2l2ZUNvbmZpZzogbmV3IE1hcCgpLFxuICAgICAgICAgICAgYXBwcyAgICAgICAgICAgIDoge31cbiAgICAgICAgfTtcblxuICAgICAgICBtZS5hZGRUb1Jlc3BvbnNpdmVNYXAobWUuZGVmYXVsdFJlc3BvbnNpdmVDb25maWcsIG1lKTtcbiAgICAgICAgbWUuYWRkVG9SZXNwb25zaXZlTWFwKG93bmVyLnJlc3BvbnNpdmVDb25maWcgfHwge30sIG93bmVyKTtcbiAgICAgICAgbWUuaGFuZGxlQm9keUNscygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlc3BvbnNpdmVPYmpcbiAgICAgKiBAcGFyYW0gc2NvcGVcbiAgICAgKi9cbiAgICBhZGRUb1Jlc3BvbnNpdmVNYXAocmVzcG9uc2l2ZU9iaiwgc2NvcGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzcG9uc2l2ZU9iaikpIHtcbiAgICAgICAgICAgIGxldCBmbjtcblxuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm5Cb29sID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzdWJLZXksIHN1YlZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTWluICAgICAgPSBzdWJLZXkuc3RhcnRzV2l0aCgnbWluJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0Q29uZmlnID0gc3ViS2V5LnN1YnN0cmluZygzKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Cb29sID0gcmVjdFt0ZXN0Q29uZmlnXSA+PSBzdWJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Cb29sID0gcmVjdFt0ZXN0Q29uZmlnXSA8PSBzdWJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldHVybkJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkJvb2xcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuID0gdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4gPSBmbi5iaW5kKHNjb3BlKTtcblxuICAgICAgICAgICAgTmVvLlJlc3BvbnNpdmUucmVzcG9uc2l2ZUNvbmZpZy5zZXQoa2V5LCBmbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlQm9keUNscygpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZX0gPSBtZS5vd25lcixcbiAgICAgICAgICAgIGFwcHMgICAgICA9IE5lby5SZXNwb25zaXZlO1xuXG4gICAgICAgIGlmICghYXBwc1thcHBOYW1lXT8uYWN0aXZlQm9keVVwZGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBOZW8uZmlyc3QoJ3ZpZXdwb3J0Jyk7IC8vIHRvZG9cblxuICAgICAgICAgICAgYXBwc1thcHBOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBhcHBJZCAgICAgICAgICAgOiB2aWV3cG9ydC5pZCxcbiAgICAgICAgICAgICAgICBhY3RpdmVCb2R5VXBkYXRlOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2aWV3cG9ydC5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgICAgIHtyZXNpemU6IG1lLm9uUmVzaXplQm9keSwgc2NvcGU6IG1lfVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25SZXNpemUoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICA9IHt9LFxuICAgICAgICAgICAgY29uZmlnVGVzdGVyID0gTmVvLlJlc3BvbnNpdmUucmVzcG9uc2l2ZUNvbmZpZyxcbiAgICAgICAgICAgIHtvd25lcn0gICAgICA9IG1lLFxuICAgICAgICAgICAge3Jlc3BvbnNpdmV9ID0gb3duZXI7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzcG9uc2l2ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0tleSA9IGNvbmZpZ1Rlc3Rlci5nZXQoa2V5KT8uKGRhdGEucmVjdCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjb25maWdLZXksIGNvbmZpZ1ZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhbHNlICYmIE5lby50eXBlT2Yob3duZXJbY29uZmlnS2V5XSkgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IG50eXBlLCBtb2R1bGUgb3IgY2xhc3NOYW1lIG11c3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyW2NvbmZpZ0tleV0uc2V0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnW2NvbmZpZ0tleV0gPSBjb25maWdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnKS5sZW5ndGggPiAwICYmIG93bmVyLnNldChjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGVpdGhlciBuZW8tbGFuZHNjYXBlIG9yIG5lby1wb3J0cmFpdCB0byB0aGUgcGFyZW50IHZpZXdwb3J0IGNvbXBvbmVudFxuICAgICAqL1xuICAgIG9uUmVzaXplQm9keShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZXdSZWN0ICAgICA9IGRhdGEuY29udGVudFJlY3QsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZSA9IG5ld1JlY3Qud2lkdGggPj0gbmV3UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBhZGRDbHMgICAgICA9IGlzTGFuZHNjYXBlID8gJ25lby1sYW5kc2NhcGUnIDogJ25lby1wb3J0cmFpdCcsXG4gICAgICAgICAgICByZW1vdmVDbHMgICA9IGlzTGFuZHNjYXBlID8gJ25lby1wb3J0cmFpdCcgOiAnbmVvLWxhbmRzY2FwZSc7XG5cbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgIGlkIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkICAgOiBbYWRkQ2xzXSxcbiAgICAgICAgICAgICAgICByZW1vdmU6IFtyZW1vdmVDbHNdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhSZXNwb25zaXZlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
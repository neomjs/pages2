"use strict";
(self["webpackChunkmyapp"] = self["webpackChunkmyapp"] || []).push([["vendors-node_modules_neo_mjs_src_draggable_toolbar_SortZone_mjs"],{

/***/ "./node_modules/neo.mjs/src/draggable/toolbar/DragZone.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/neo.mjs/src/draggable/toolbar/DragZone.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./node_modules/neo.mjs/src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./node_modules/neo.mjs/src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./node_modules/neo.mjs/src/util/VDom.mjs");




/**
 * @class Neo.draggable.toolbar.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.toolbar.DragZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.DragZone',
        /**
         * @member {String} ntype='toolbar-dragzone'
         * @protected
         */
        ntype: 'toolbar-dragzone'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            opts    = {delegate: '.neo-draggable', scope: me};

        owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        ]);

        owner.on({
            insert      : me.onItemInsert,
            itemsCreated: me.onItemsCreated,
            scope       : me
        });

        // The toolbar items can already be created
        me.adjustToolbarItemCls(true)
    }

    /**
     * @param {Boolean} draggable
     */
    adjustToolbarItemCls(draggable) {
        let me      = this,
            {owner} = me,
            wrapperCls;

        owner.items.forEach(item => {
            wrapperCls = item.wrapperCls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
            item.wrapperCls = wrapperCls
        })
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            me.timeout(30).then(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                me.timeout(100).then(() => {
                    me.dragEnd()
                })
            })
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.owner.vdom, data.path[0].id).vdom;
            await me.dragStart(data)
        }
    }

    /**
     * @param {Object}             data
     * @param {Number}             data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let {item}     = data,
            wrapperCls = item.wrapperCls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, 'neo-draggable');
        item.wrapperCls = wrapperCls
    }

    /**
     * @param {Object}               data
     * @param {String}               data.id
     * @param {Neo.component.Base[]} data.items
     */
    onItemsCreated(data) {
        this.adjustToolbarItemCls(true)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ }),

/***/ "./node_modules/neo.mjs/src/draggable/toolbar/SortZone.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/neo.mjs/src/draggable/toolbar/SortZone.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./node_modules/neo.mjs/src/draggable/toolbar/DragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./node_modules/neo.mjs/src/util/VDom.mjs");



/**
 * @class Neo.draggable.toolbar.SortZone
 * @extends Neo.draggable.toolbar.DragZone
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.toolbar.SortZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.SortZone',
        /**
         * @member {String} ntype='toolbar-sortzone'
         * @protected
         */
        ntype: 'toolbar-sortzone',
        /**
         * Depending on the parent structure using position absolute and relative, it can be needed to subtract
         * the x & y parent rect values from the item rects.
         * @member {Boolean} adjustItemRectsToParent=false
         */
        adjustItemRectsToParent: false,
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {String|null} itemMargin=null
         * @protected
         */
        itemMargin: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * @member {Boolean} alwaysFireDragMove=false
         * @protected
         */
        reversedLayoutDirection: false,
        /**
         * @member {Number} scrollLeft=0
         */
        scrollLeft: 0,
        /**
         * @member {Number} scrollTop=0
         */
        scrollTop: 0,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }

    /**
     * @member {Boolean} isOverDragging=false
     * @protected
     */
    isOverDragging = false

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     * @param {Object} data
     */
    async onDragEnd(data) {
        let me                  = this,
            {itemStyles, owner} = me,
            ownerStyle          = owner.style || {},
            itemStyle;

        await me.timeout(10);

        if (owner.sortable) {
            ownerStyle.height   = me.ownerStyle.height    || null;
            ownerStyle.minWidth = me.ownerStyle.minWidth  || null;
            ownerStyle.width    = me.ownerStyle.width     || null;

            owner.style = ownerStyle;

            owner.items.forEach((item, index) => {
                itemStyle = item.wrapperStyle || {};

                Object.assign(itemStyle, {
                    height  : itemStyles[index].height || null,
                    left    : null,
                    margin  : null,
                    position: null,
                    top     : null,
                    width   : itemStyles[index].width || null
                });

                if (index === me.startIndex) {
                    itemStyle.visibility = null
                }

                item.wrapperStyle = itemStyle
            });

            if (me.startIndex !== me.currentIndex) {
                me.moveTo(me.startIndex, me.currentIndex)
            }

            Object.assign(me, {
                currentIndex: -1,
                indexMap    : null,
                itemRects   : null,
                itemStyles  : null,
                ownerRect   : null,
                startIndex  : -1
            });

            await me.timeout(30);

            me.dragEnd(data) // we do not want to trigger the super class call here
        }
    }

    /**
     * @param {Object} data
     */
    async onDragMove(data) {
        // The method can trigger before we got the client rects from the main thread
        if (!this.itemRects || this.isScrolling) {
            return
        }

        let me                 = this,
            {clientX, clientY} = data,
            index              = me.currentIndex,
            {itemRects}        = me,
            maxItems           = itemRects.length - 1,
            ownerX             = me.adjustItemRectsToParent ? me.ownerRect.x : 0,
            ownerY             = me.adjustItemRectsToParent ? me.ownerRect.y : 0,
            reversed           = me.reversedLayoutDirection,
            delta, isOverDragging, isOverDraggingEnd, isOverDraggingStart, itemHeightOrWidth, moveFactor;

        if (me.sortDirection === 'horizontal') {
            delta               = clientX - ownerX + me.scrollLeft - me.offsetX - itemRects[index].left;
            isOverDraggingEnd   = clientX > me.boundaryContainerRect.right;
            isOverDraggingStart = clientX < me.boundaryContainerRect.left;
            itemHeightOrWidth   = 'width'
        } else {
            delta               = clientY - ownerY + me.scrollTop - me.offsetY - itemRects[index].top;
            isOverDraggingEnd   = clientY > me.boundaryContainerRect.bottom;
            isOverDraggingStart = clientY < me.boundaryContainerRect.top;
            itemHeightOrWidth   = 'height'
        }

        isOverDragging = isOverDraggingEnd || isOverDraggingStart;
        moveFactor     = isOverDragging ? 0.02 : 0.55; // We can not use 0.5, since items would jump back & forth

        if (isOverDraggingStart) {
            if (index > 0) {
                me.currentIndex--;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (isOverDraggingEnd) {
            if (index < maxItems) {
                me.currentIndex++;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index > 0 && (!reversed && delta < 0 || reversed && delta > 0)) {
            if (Math.abs(delta) > itemRects[index - 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex--;
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index < maxItems && (!reversed && delta > 0 || reversed && delta < 0)) {
            if (Math.abs(delta) > itemRects[index + 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex++;
                me.switchItems(index, me.currentIndex)
            }
        }

        me.isOverDragging = isOverDragging && me.currentIndex !== 0 && me.currentIndex !== maxItems;

        if (me.isOverDragging) {
            await me.timeout(30); // wait for 1 frame

            if (me.isOverDragging) {
                await me.onDragMove(data)
            }
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me         = this,
            button     = Neo.getComponent(data.path[0].id),
            {owner}    = me,
            itemStyles = me.itemStyles = [],
            {layout}   = owner,
            ownerStyle = owner.style || {},
            index, indexMap, itemStyle, rect;

        if (owner.sortable) {
            index    = owner.indexOf(button.id);
            indexMap = {};

            Object.assign(me, {
                currentIndex           : index,
                dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find(owner.vdom, button.id).vdom,
                dragProxyConfig        : {...me.dragProxyConfig, cls: [...owner.cls]},
                indexMap               : indexMap,
                ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
                reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
                sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
                startIndex             : index
            });

            await me.dragStart(data); // We do not want to trigger the super class call here

            owner.items.forEach((item, index) => {
                indexMap[index] = index;

                itemStyles.push({
                    height: item.height ? `${item.height}px` :  item.style?.height,
                    width : item.width  ? `${item.width}px`  :  item.style?.width
                })
            });

            owner.getDomRect([owner.id].concat(owner.items.map(e => e.id))).then(itemRects => {
                me.ownerRect = itemRects[0];

                // The only reason we are adjusting the toolbar style is that there might be no min-height or min-width present.
                // => Removing items from the layout could trigger a change in size otherwise
                owner.style = {
                    ...ownerStyle,
                    height  : `${itemRects[0].height}px`,
                    minWidth: `${itemRects[0].width}px`,
                    width   : `${itemRects[0].width}px`
                };

                itemRects.shift();

                me.adjustItemRectsToParent && itemRects.forEach(rect => {
                    rect.x -= me.ownerRect.x;
                    rect.y -= me.ownerRect.y
                });

                me.itemRects = itemRects;

                owner.items.forEach((item, index) => {
                    itemStyle = item.wrapperStyle || {};
                    rect      = itemRects[index];

                    me.adjustProxyRectToParent?.(rect, me.ownerRect);

                    item.wrapperStyle = Object.assign(itemStyle, {
                        height  : `${rect.height}px`,
                        left    : `${rect.left}px`,
                        margin  : me.itemMargin,
                        position: 'absolute',
                        top     : `${rect.top}px`,
                        width   : `${rect.width}px`
                    })
                });

                // we need to add a short (1 frame) delay to ensure the item has switched to an absolute position
                me.timeout(5).then(() => {
                    itemStyle = button.wrapperStyle || {};
                    itemStyle.visibility = 'hidden';
                    button.wrapperStyle = itemStyle
                })
            })
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async scrollToIndex() {
        let me = this;

        me.isScrolling = true;
        await me.owner.scrollToIndex?.(me.currentIndex, me.itemRects[me.currentIndex]);
        me.isScrolling = false
    }

    /**
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        let me       = this,
            reversed = me.reversedLayoutDirection,
            tmp;

        if ((!reversed && index2 < index1) || (reversed && index1 < index2)) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp;
        }

        let itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = rect1.clone(),
            rect2Copy = rect2.clone();

        if (me.sortDirection === 'horizontal') {
            rect1.width = rect2Copy.width;
            rect2.x     = rect1Copy.x + rect2Copy.width;
            rect2.width = rect1Copy.width
        } else {
            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.y      = rect1Copy.y + rect2Copy.height
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2)
    }

    /**
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me             = this,
            item           = me.owner.items[me.indexMap[index]],
            {wrapperStyle} = item;

        wrapperStyle.left = `${rect.left}px`;
        wrapperStyle.top  = `${rect.top}px`;

        item.wrapperStyle = wrapperStyle
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLW5vZGVfbW9kdWxlc19uZW9fbWpzX3NyY19kcmFnZ2FibGVfdG9vbGJhcl9Tb3J0Wm9uZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNSO0FBQ0Q7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFZO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQix1QkFBdUI7O0FBRXZCO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQSxhQUFh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c3JjL2RyYWdnYWJsZS90b29sYmFyL0RyYWdab25lLm1qcyIsIndlYnBhY2s6Ly9teWFwcC8uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9kcmFnZ2FibGUvdG9vbGJhci9Tb3J0Wm9uZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEcmFnWm9uZSBmcm9tICcuLi8uLi9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS50b29sYmFyLkRyYWdab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLkRyYWdab25lXG4gKi9cbmNsYXNzIERyYWdab25lIGV4dGVuZHMgQmFzZURyYWdab25lIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS50b29sYmFyLkRyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3Rvb2xiYXItZHJhZ3pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndG9vbGJhci1kcmFnem9uZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBvcHRzICAgID0ge2RlbGVnYXRlOiAnLm5lby1kcmFnZ2FibGUnLCBzY29wZTogbWV9O1xuXG4gICAgICAgIG93bmVyLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkRyYWdFbmQsICAgLi4ub3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6bW92ZScgOiBtZS5vbkRyYWdNb3ZlLCAgLi4ub3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkRyYWdTdGFydCwgLi4ub3B0c31cbiAgICAgICAgXSk7XG5cbiAgICAgICAgb3duZXIub24oe1xuICAgICAgICAgICAgaW5zZXJ0ICAgICAgOiBtZS5vbkl0ZW1JbnNlcnQsXG4gICAgICAgICAgICBpdGVtc0NyZWF0ZWQ6IG1lLm9uSXRlbXNDcmVhdGVkLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgdG9vbGJhciBpdGVtcyBjYW4gYWxyZWFkeSBiZSBjcmVhdGVkXG4gICAgICAgIG1lLmFkanVzdFRvb2xiYXJJdGVtQ2xzKHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICAgKi9cbiAgICBhZGp1c3RUb29sYmFySXRlbUNscyhkcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgd3JhcHBlckNscztcblxuICAgICAgICBvd25lci5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgd3JhcHBlckNscyA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXTtcblxuICAgICAgICAgICAgTmVvQXJyYXkudG9nZ2xlKHdyYXBwZXJDbHMsICduZW8tZHJhZ2dhYmxlJywgZHJhZ2dhYmxlKTtcbiAgICAgICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm93bmVyLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJveHkgICAgICAgID0gbWUuZHJhZ1Byb3h5LFxuICAgICAgICAgICAgICAgIGNscyAgICAgICAgICA9IHByb3h5LmNscyB8fCB7fSxcbiAgICAgICAgICAgICAgICByZWN0ICAgICAgICAgPSBtZS5kcmFnRWxlbWVudFJlY3QsXG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gcHJveHkud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWFuaW1hdGUnKTtcbiAgICAgICAgICAgIHByb3h5LmNscyA9IGNscztcblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRvIGdldCBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgbWUudGltZW91dCgzMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS50b3AgID0gYCR7cmVjdC50b3B9cHhgO1xuXG4gICAgICAgICAgICAgICAgcHJveHkud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICAgICAgbWUudGltZW91dCgxMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5kcmFnRW5kKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5vd25lci5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIG1lLmRyYWdFbGVtZW50ID0gVkRvbVV0aWwuZmluZChtZS5vd25lci52ZG9tLCBkYXRhLnBhdGhbMF0uaWQpLnZkb207XG4gICAgICAgICAgICBhd2FpdCBtZS5kcmFnU3RhcnQoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5pdGVtXG4gICAgICovXG4gICAgb25JdGVtSW5zZXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IHtpdGVtfSAgICAgPSBkYXRhLFxuICAgICAgICAgICAgd3JhcHBlckNscyA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXTtcblxuICAgICAgICBOZW9BcnJheS5hZGQod3JhcHBlckNscywgJ25lby1kcmFnZ2FibGUnKTtcbiAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2VbXX0gZGF0YS5pdGVtc1xuICAgICAqL1xuICAgIG9uSXRlbXNDcmVhdGVkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5hZGp1c3RUb29sYmFySXRlbUNscyh0cnVlKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1pvbmUpO1xuIiwiaW1wb3J0IERyYWdab25lIGZyb20gJy4vRHJhZ1pvbmUubWpzJztcbmltcG9ydCBWRG9tVXRpbCBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuRHJhZ1pvbmVcbiAqL1xuY2xhc3MgU29ydFpvbmUgZXh0ZW5kcyBEcmFnWm9uZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUudG9vbGJhci5Tb3J0Wm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyLXNvcnR6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXItc29ydHpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwZW5kaW5nIG9uIHRoZSBwYXJlbnQgc3RydWN0dXJlIHVzaW5nIHBvc2l0aW9uIGFic29sdXRlIGFuZCByZWxhdGl2ZSwgaXQgY2FuIGJlIG5lZWRlZCB0byBzdWJ0cmFjdFxuICAgICAgICAgKiB0aGUgeCAmIHkgcGFyZW50IHJlY3QgdmFsdWVzIGZyb20gdGhlIGl0ZW0gcmVjdHMuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGp1c3RJdGVtUmVjdHNUb1BhcmVudDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbHdheXNGaXJlRHJhZ01vdmU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjdXJyZW50SW5kZXg9LTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudEluZGV4OiAtMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaW5kZXhNYXA9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE1hcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpdGVtTWFyZ2luPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbU1hcmdpbjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1SZWN0cz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1SZWN0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1TdHlsZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtU3R5bGVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBvd25lclJlY3Q9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lclJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG93bmVyU3R5bGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lclN0eWxlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWx3YXlzRmlyZURyYWdNb3ZlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJldmVyc2VkTGF5b3V0RGlyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdD0wXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxUb3A9MFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZzogb25EcmFnU3RhcnQoKSB3aWxsIHNldCB0aGUgdmFsdWUgdG8gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGxheW91dC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzb3J0RGlyZWN0aW9uPSdob3Jpem9udGFsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0RGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHN0YXJ0SW5kZXg9LTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRJbmRleDogLTFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc092ZXJEcmFnZ2luZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc092ZXJEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY2xhc3MgZXh0ZW5zaW9ucyAoZS5nLiB0YWIuaGVhZGVyLlRvb2xiYXIpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgbW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB0aGlzLm93bmVyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1TdHlsZXMsIG93bmVyfSA9IG1lLFxuICAgICAgICAgICAgb3duZXJTdHlsZSAgICAgICAgICA9IG93bmVyLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgaXRlbVN0eWxlO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMTApO1xuXG4gICAgICAgIGlmIChvd25lci5zb3J0YWJsZSkge1xuICAgICAgICAgICAgb3duZXJTdHlsZS5oZWlnaHQgICA9IG1lLm93bmVyU3R5bGUuaGVpZ2h0ICAgIHx8IG51bGw7XG4gICAgICAgICAgICBvd25lclN0eWxlLm1pbldpZHRoID0gbWUub3duZXJTdHlsZS5taW5XaWR0aCAgfHwgbnVsbDtcbiAgICAgICAgICAgIG93bmVyU3R5bGUud2lkdGggICAgPSBtZS5vd25lclN0eWxlLndpZHRoICAgICB8fCBudWxsO1xuXG4gICAgICAgICAgICBvd25lci5zdHlsZSA9IG93bmVyU3R5bGU7XG5cbiAgICAgICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW1TdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgIDogaXRlbVN0eWxlc1tpbmRleF0uaGVpZ2h0IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4gIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogaXRlbVN0eWxlc1tpbmRleF0ud2lkdGggfHwgbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBtZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZS52aXNpYmlsaXR5ID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gaXRlbVN0eWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1lLnN0YXJ0SW5kZXggIT09IG1lLmN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIG1lLm1vdmVUbyhtZS5zdGFydEluZGV4LCBtZS5jdXJyZW50SW5kZXgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIGluZGV4TWFwICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtUmVjdHMgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlcyAgOiBudWxsLFxuICAgICAgICAgICAgICAgIG93bmVyUmVjdCAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ICA6IC0xXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgzMCk7XG5cbiAgICAgICAgICAgIG1lLmRyYWdFbmQoZGF0YSkgLy8gd2UgZG8gbm90IHdhbnQgdG8gdHJpZ2dlciB0aGUgc3VwZXIgY2xhc3MgY2FsbCBoZXJlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ01vdmUoZGF0YSkge1xuICAgICAgICAvLyBUaGUgbWV0aG9kIGNhbiB0cmlnZ2VyIGJlZm9yZSB3ZSBnb3QgdGhlIGNsaWVudCByZWN0cyBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgICAgICBpZiAoIXRoaXMuaXRlbVJlY3RzIHx8IHRoaXMuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xpZW50WCwgY2xpZW50WX0gPSBkYXRhLFxuICAgICAgICAgICAgaW5kZXggICAgICAgICAgICAgID0gbWUuY3VycmVudEluZGV4LFxuICAgICAgICAgICAge2l0ZW1SZWN0c30gICAgICAgID0gbWUsXG4gICAgICAgICAgICBtYXhJdGVtcyAgICAgICAgICAgPSBpdGVtUmVjdHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG93bmVyWCAgICAgICAgICAgICA9IG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gbWUub3duZXJSZWN0LnggOiAwLFxuICAgICAgICAgICAgb3duZXJZICAgICAgICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyBtZS5vd25lclJlY3QueSA6IDAsXG4gICAgICAgICAgICByZXZlcnNlZCAgICAgICAgICAgPSBtZS5yZXZlcnNlZExheW91dERpcmVjdGlvbixcbiAgICAgICAgICAgIGRlbHRhLCBpc092ZXJEcmFnZ2luZywgaXNPdmVyRHJhZ2dpbmdFbmQsIGlzT3ZlckRyYWdnaW5nU3RhcnQsIGl0ZW1IZWlnaHRPcldpZHRoLCBtb3ZlRmFjdG9yO1xuXG4gICAgICAgIGlmIChtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGRlbHRhICAgICAgICAgICAgICAgPSBjbGllbnRYIC0gb3duZXJYICsgbWUuc2Nyb2xsTGVmdCAtIG1lLm9mZnNldFggLSBpdGVtUmVjdHNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WCA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5yaWdodDtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nU3RhcnQgPSBjbGllbnRYIDwgbWUuYm91bmRhcnlDb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ3dpZHRoJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICA9IGNsaWVudFkgLSBvd25lclkgKyBtZS5zY3JvbGxUb3AgLSBtZS5vZmZzZXRZIC0gaXRlbVJlY3RzW2luZGV4XS50b3A7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WSA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5ib3R0b207XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ1N0YXJ0ID0gY2xpZW50WSA8IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ2hlaWdodCdcbiAgICAgICAgfVxuXG4gICAgICAgIGlzT3ZlckRyYWdnaW5nID0gaXNPdmVyRHJhZ2dpbmdFbmQgfHwgaXNPdmVyRHJhZ2dpbmdTdGFydDtcbiAgICAgICAgbW92ZUZhY3RvciAgICAgPSBpc092ZXJEcmFnZ2luZyA/IDAuMDIgOiAwLjU1OyAvLyBXZSBjYW4gbm90IHVzZSAwLjUsIHNpbmNlIGl0ZW1zIHdvdWxkIGp1bXAgYmFjayAmIGZvcnRoXG5cbiAgICAgICAgaWYgKGlzT3ZlckRyYWdnaW5nU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5zY3JvbGxUb0luZGV4KCk7XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGlzT3ZlckRyYWdnaW5nRW5kKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBtYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNjcm9sbFRvSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPiAwICYmICghcmV2ZXJzZWQgJiYgZGVsdGEgPCAwIHx8IHJldmVyc2VkICYmIGRlbHRhID4gMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBpdGVtUmVjdHNbaW5kZXggLSAxXVtpdGVtSGVpZ2h0T3JXaWR0aF0gKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4LS07XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGluZGV4IDwgbWF4SXRlbXMgJiYgKCFyZXZlcnNlZCAmJiBkZWx0YSA+IDAgfHwgcmV2ZXJzZWQgJiYgZGVsdGEgPCAwKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IGl0ZW1SZWN0c1tpbmRleCArIDFdW2l0ZW1IZWlnaHRPcldpZHRoXSAqIG1vdmVGYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNPdmVyRHJhZ2dpbmcgPSBpc092ZXJEcmFnZ2luZyAmJiBtZS5jdXJyZW50SW5kZXggIT09IDAgJiYgbWUuY3VycmVudEluZGV4ICE9PSBtYXhJdGVtcztcblxuICAgICAgICBpZiAobWUuaXNPdmVyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApOyAvLyB3YWl0IGZvciAxIGZyYW1lXG5cbiAgICAgICAgICAgIGlmIChtZS5pc092ZXJEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm9uRHJhZ01vdmUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidXR0b24gICAgID0gTmVvLmdldENvbXBvbmVudChkYXRhLnBhdGhbMF0uaWQpLFxuICAgICAgICAgICAge293bmVyfSAgICA9IG1lLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyA9IG1lLml0ZW1TdHlsZXMgPSBbXSxcbiAgICAgICAgICAgIHtsYXlvdXR9ICAgPSBvd25lcixcbiAgICAgICAgICAgIG93bmVyU3R5bGUgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGluZGV4LCBpbmRleE1hcCwgaXRlbVN0eWxlLCByZWN0O1xuXG4gICAgICAgIGlmIChvd25lci5zb3J0YWJsZSkge1xuICAgICAgICAgICAgaW5kZXggICAgPSBvd25lci5pbmRleE9mKGJ1dHRvbi5pZCk7XG4gICAgICAgICAgICBpbmRleE1hcCA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ICAgICAgICAgICA6IGluZGV4LFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICAgICAgOiBWRG9tVXRpbC5maW5kKG93bmVyLnZkb20sIGJ1dHRvbi5pZCkudmRvbSxcbiAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWcgICAgICAgIDogey4uLm1lLmRyYWdQcm94eUNvbmZpZywgY2xzOiBbLi4ub3duZXIuY2xzXX0sXG4gICAgICAgICAgICAgICAgaW5kZXhNYXAgICAgICAgICAgICAgICA6IGluZGV4TWFwLFxuICAgICAgICAgICAgICAgIG93bmVyU3R5bGUgICAgICAgICAgICAgOiB7aGVpZ2h0OiBvd25lclN0eWxlLmhlaWdodCwgbWluV2lkdGg6IG93bmVyU3R5bGUubWluV2lkdGgsIHdpZHRoOiBvd25lclN0eWxlLndpZHRofSxcbiAgICAgICAgICAgICAgICByZXZlcnNlZExheW91dERpcmVjdGlvbjogbGF5b3V0LmRpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyB8fCBsYXlvdXQuZGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnLFxuICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gICAgICAgICAgOiBsYXlvdXQuZGlyZWN0aW9uPy5pbmNsdWRlcygnY29sdW1uJykgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggICAgICAgICAgICAgOiBpbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmRyYWdTdGFydChkYXRhKTsgLy8gV2UgZG8gbm90IHdhbnQgdG8gdHJpZ2dlciB0aGUgc3VwZXIgY2xhc3MgY2FsbCBoZXJlXG5cbiAgICAgICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaW5kZXhdID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0ID8gYCR7aXRlbS5oZWlnaHR9cHhgIDogIGl0ZW0uc3R5bGU/LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBpdGVtLndpZHRoICA/IGAke2l0ZW0ud2lkdGh9cHhgICA6ICBpdGVtLnN0eWxlPy53aWR0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3duZXIuZ2V0RG9tUmVjdChbb3duZXIuaWRdLmNvbmNhdChvd25lci5pdGVtcy5tYXAoZSA9PiBlLmlkKSkpLnRoZW4oaXRlbVJlY3RzID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QgPSBpdGVtUmVjdHNbMF07XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgb25seSByZWFzb24gd2UgYXJlIGFkanVzdGluZyB0aGUgdG9vbGJhciBzdHlsZSBpcyB0aGF0IHRoZXJlIG1pZ2h0IGJlIG5vIG1pbi1oZWlnaHQgb3IgbWluLXdpZHRoIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgLy8gPT4gUmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgbGF5b3V0IGNvdWxkIHRyaWdnZXIgYSBjaGFuZ2UgaW4gc2l6ZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBvd25lci5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3duZXJTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke2l0ZW1SZWN0c1swXS5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogYCR7aXRlbVJlY3RzWzBdLndpZHRofXB4YCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggICA6IGAke2l0ZW1SZWN0c1swXS53aWR0aH1weGBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaXRlbVJlY3RzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCAmJiBpdGVtUmVjdHMuZm9yRWFjaChyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC54IC09IG1lLm93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLml0ZW1SZWN0cyA9IGl0ZW1SZWN0cztcblxuICAgICAgICAgICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZWN0ICAgICAgPSBpdGVtUmVjdHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmFkanVzdFByb3h5UmVjdFRvUGFyZW50Py4ocmVjdCwgbWUub3duZXJSZWN0KTtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gIDogbWUuaXRlbU1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgICA6IGAke3JlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBhZGQgYSBzaG9ydCAoMSBmcmFtZSkgZGVsYXkgdG8gZW5zdXJlIHRoZSBpdGVtIGhhcyBzd2l0Y2hlZCB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGJ1dHRvbi53cmFwcGVyU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi53cmFwcGVyU3R5bGUgPSBpdGVtU3R5bGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHNjcm9sbFRvSW5kZXgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCBtZS5vd25lci5zY3JvbGxUb0luZGV4Py4obWUuY3VycmVudEluZGV4LCBtZS5pdGVtUmVjdHNbbWUuY3VycmVudEluZGV4XSk7XG4gICAgICAgIG1lLmlzU2Nyb2xsaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MlxuICAgICAqL1xuICAgIHN3aXRjaEl0ZW1zKGluZGV4MSwgaW5kZXgyKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZXZlcnNlZCA9IG1lLnJldmVyc2VkTGF5b3V0RGlyZWN0aW9uLFxuICAgICAgICAgICAgdG1wO1xuXG4gICAgICAgIGlmICgoIXJldmVyc2VkICYmIGluZGV4MiA8IGluZGV4MSkgfHwgKHJldmVyc2VkICYmIGluZGV4MSA8IGluZGV4MikpIHtcbiAgICAgICAgICAgIHRtcCAgICA9IGluZGV4MTtcbiAgICAgICAgICAgIGluZGV4MSA9IGluZGV4MjtcbiAgICAgICAgICAgIGluZGV4MiA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtUmVjdHMgPSBtZS5pdGVtUmVjdHMsXG4gICAgICAgICAgICBtYXAgICAgICAgPSBtZS5pbmRleE1hcCxcbiAgICAgICAgICAgIHJlY3QxICAgICA9IGl0ZW1SZWN0c1tpbmRleDFdLFxuICAgICAgICAgICAgcmVjdDIgICAgID0gaXRlbVJlY3RzW2luZGV4Ml0sXG4gICAgICAgICAgICByZWN0MUNvcHkgPSByZWN0MS5jbG9uZSgpLFxuICAgICAgICAgICAgcmVjdDJDb3B5ID0gcmVjdDIuY2xvbmUoKTtcblxuICAgICAgICBpZiAobWUuc29ydERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICByZWN0MS53aWR0aCA9IHJlY3QyQ29weS53aWR0aDtcbiAgICAgICAgICAgIHJlY3QyLnggICAgID0gcmVjdDFDb3B5LnggKyByZWN0MkNvcHkud2lkdGg7XG4gICAgICAgICAgICByZWN0Mi53aWR0aCA9IHJlY3QxQ29weS53aWR0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdDEuaGVpZ2h0ID0gcmVjdDJDb3B5LmhlaWdodDtcbiAgICAgICAgICAgIHJlY3QyLmhlaWdodCA9IHJlY3QxQ29weS5oZWlnaHQ7XG4gICAgICAgICAgICByZWN0Mi55ICAgICAgPSByZWN0MUNvcHkueSArIHJlY3QyQ29weS5oZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCAgICAgICAgID0gbWFwW2luZGV4MV07XG4gICAgICAgIG1hcFtpbmRleDFdID0gbWFwW2luZGV4Ml07XG4gICAgICAgIG1hcFtpbmRleDJdID0gdG1wO1xuXG4gICAgICAgIG1lLnVwZGF0ZUl0ZW0oaW5kZXgxLCByZWN0MSk7XG4gICAgICAgIG1lLnVwZGF0ZUl0ZW0oaW5kZXgyLCByZWN0MilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxuICAgICAqL1xuICAgIHVwZGF0ZUl0ZW0oaW5kZXgsIHJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gICAgICAgICAgID0gbWUub3duZXIuaXRlbXNbbWUuaW5kZXhNYXBbaW5kZXhdXSxcbiAgICAgICAgICAgIHt3cmFwcGVyU3R5bGV9ID0gaXRlbTtcblxuICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IGAke3JlY3QubGVmdH1weGA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS50b3AgID0gYCR7cmVjdC50b3B9cHhgO1xuXG4gICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTb3J0Wm9uZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=
"use strict";(self.webpackChunkmyapp=self.webpackChunkmyapp||[]).push([[556],{3175:(e,t,r)=>{r.r(t),r.d(t,{default:()=>l});var n=r(6029),i=r(6846),o=r(8825);class a extends n.A{static config={className:"Neo.draggable.toolbar.DragZone",ntype:"toolbar-dragzone"};construct(e){super.construct(e);let t=this,{owner:r}=t,n={delegate:".neo-draggable",scope:t};r.addDomListeners([{"drag:end":t.onDragEnd,...n},{"drag:move":t.onDragMove,...n},{"drag:start":t.onDragStart,...n}]),r.on({insert:t.onItemInsert,itemsCreated:t.onItemsCreated,scope:t}),t.adjustToolbarItemCls(!0)}adjustToolbarItemCls(e){let t,{owner:r}=this;r.items.forEach((r=>{t=r.wrapperCls||[],i.A.toggle(t,"neo-draggable",e),r.wrapperCls=t}))}onDragEnd(e){if(this.owner.draggable){let e=this,t=e.dragProxy,r=t.cls||{},n=e.dragElementRect,o=t.wrapperStyle||{};i.A.add(r,"neo-animate"),t.cls=r,e.timeout(30).then((()=>{o.left=`${n.left}px`,o.top=`${n.top}px`,t.wrapperStyle=o,e.timeout(100).then((()=>{e.dragEnd()}))}))}}async onDragStart(e){let t=this;t.owner.draggable&&(t.dragElement=o.A.find(t.owner.vdom,e.path[0].id).vdom,await t.dragStart(e))}onItemInsert(e){let{item:t}=e,r=t.wrapperCls||[];i.A.add(r,"neo-draggable"),t.wrapperCls=r}onItemsCreated(e){this.adjustToolbarItemCls(!0)}}const s=Neo.setupClass(a),l=Neo.setupClass(class extends s{static config={className:"Neo.draggable.toolbar.SortZone",ntype:"toolbar-sortzone",adjustItemRectsToParent:!1,alwaysFireDragMove:!0,currentIndex:-1,indexMap:null,itemMargin:null,itemRects:null,itemStyles:null,ownerRect:null,ownerStyle:null,reversedLayoutDirection:!1,scrollLeft:0,scrollTop:0,sortDirection:"horizontal",startIndex:-1};isOverDragging=!1;moveTo(e,t){this.owner.moveTo(e,t)}async onDragEnd(e){let t,r=this,{itemStyles:n,owner:i}=r,o=i.style||{};await r.timeout(10),i.sortable&&(o.height=r.ownerStyle.height||null,o.minWidth=r.ownerStyle.minWidth||null,o.width=r.ownerStyle.width||null,i.style=o,i.items.forEach(((e,i)=>{t=e.wrapperStyle||{},Object.assign(t,{height:n[i].height||null,left:null,margin:null,position:null,top:null,width:n[i].width||null}),i===r.startIndex&&(t.visibility=null),e.wrapperStyle=t})),r.startIndex!==r.currentIndex&&r.moveTo(r.startIndex,r.currentIndex),Object.assign(r,{currentIndex:-1,indexMap:null,itemRects:null,itemStyles:null,ownerRect:null,startIndex:-1}),await r.timeout(30),r.dragEnd(e))}async onDragMove(e){if(!this.itemRects||this.isScrolling)return;let t,r,n,i,o,a,s=this,{clientX:l,clientY:d}=e,c=s.currentIndex,{itemRects:h}=s,g=h.length-1,p=s.adjustItemRectsToParent?s.ownerRect.x:0,u=s.adjustItemRectsToParent?s.ownerRect.y:0,m=s.reversedLayoutDirection;"horizontal"===s.sortDirection?(t=l-p+s.scrollLeft-s.offsetX-h[c].left,n=l>s.boundaryContainerRect.right,i=l<s.boundaryContainerRect.left,o="width"):(t=d-u+s.scrollTop-s.offsetY-h[c].top,n=d>s.boundaryContainerRect.bottom,i=d<s.boundaryContainerRect.top,o="height"),r=n||i,a=r?.02:.55,i?c>0&&(s.currentIndex--,await s.scrollToIndex(),s.switchItems(c,s.currentIndex)):n?c<g&&(s.currentIndex++,await s.scrollToIndex(),s.switchItems(c,s.currentIndex)):c>0&&(!m&&t<0||m&&t>0)?Math.abs(t)>h[c-1][o]*a&&(s.currentIndex--,s.switchItems(c,s.currentIndex)):c<g&&(!m&&t>0||m&&t<0)&&Math.abs(t)>h[c+1][o]*a&&(s.currentIndex++,s.switchItems(c,s.currentIndex)),s.isOverDragging=r&&0!==s.currentIndex&&s.currentIndex!==g,s.isOverDragging&&(await s.timeout(30),s.isOverDragging&&await s.onDragMove(e))}async onDragStart(e){let t,r,n,i,a=this,s=Neo.getComponent(e.path[0].id),{owner:l}=a,d=a.itemStyles=[],{layout:c}=l,h=l.style||{};l.sortable&&(t=l.indexOf(s.id),r={},Object.assign(a,{currentIndex:t,dragElement:o.A.find(l.vdom,s.id).vdom,dragProxyConfig:{...a.dragProxyConfig,cls:[...l.cls]},indexMap:r,ownerStyle:{height:h.height,minWidth:h.minWidth,width:h.width},reversedLayoutDirection:"column-reverse"===c.direction||"row-reverse"===c.direction,sortDirection:c.direction?.includes("column")?"vertical":"horizontal",startIndex:t}),await a.dragStart(e),l.items.forEach(((e,t)=>{r[t]=t,d.push({height:e.height?`${e.height}px`:e.style?.height,width:e.width?`${e.width}px`:e.style?.width})})),l.getDomRect([l.id].concat(l.items.map((e=>e.id)))).then((e=>{a.ownerRect=e[0],l.style={...h,height:`${e[0].height}px`,minWidth:`${e[0].width}px`,width:`${e[0].width}px`},e.shift(),a.adjustItemRectsToParent&&e.forEach((e=>{e.x-=a.ownerRect.x,e.y-=a.ownerRect.y})),a.itemRects=e,l.items.forEach(((t,r)=>{n=t.wrapperStyle||{},i=e[r],a.adjustProxyRectToParent?.(i,a.ownerRect),t.wrapperStyle=Object.assign(n,{height:`${i.height}px`,left:`${i.left}px`,margin:a.itemMargin,position:"absolute",top:`${i.top}px`,width:`${i.width}px`})})),a.timeout(5).then((()=>{n=s.wrapperStyle||{},n.visibility="hidden",s.wrapperStyle=n}))})))}async scrollToIndex(){let e=this;e.isScrolling=!0,await(e.owner.scrollToIndex?.(e.currentIndex,e.itemRects[e.currentIndex])),e.isScrolling=!1}switchItems(e,t){let r,n=this,i=n.reversedLayoutDirection;(!i&&t<e||i&&e<t)&&(r=e,e=t,t=r);let o=n.itemRects,a=n.indexMap,s=o[e],l=o[t],d=s.clone(),c=l.clone();"horizontal"===n.sortDirection?(s.width=c.width,l.x=d.x+c.width,l.width=d.width):(s.height=c.height,l.height=d.height,l.y=d.y+c.height),r=a[e],a[e]=a[t],a[t]=r,n.updateItem(e,s),n.updateItem(t,l)}updateItem(e,t){let r=this.owner.items[this.indexMap[e]],{wrapperStyle:n}=r;n.left=`${t.left}px`,n.top=`${t.top}px`,r.wrapperStyle=n}})}}]);
"use strict";(self.webpackChunkmyapp=self.webpackChunkmyapp||[]).push([[556,856],{856:(e,t,r)=>{r.r(t),r.d(t,{default:()=>i});var n=r(3175),o=r(6846);class a extends n.default{static config={className:"Neo.draggable.tab.header.toolbar.SortZone",ntype:"tab-header-toolbar-sortzone",dragProxyConfig:{cls:["neo-tab-header-toolbar","neo-toolbar"]}};moveTo(e,t){this.owner.up().moveTo(e,t)}onDragEnd(e){super.onDragEnd(e),this.timeout(300).then((()=>{let{owner:e}=this,t=e.cls||[];o.A.remove(t,"neo-no-animation"),e.cls=t}))}async onDragStart(e){let{owner:t}=this,r=t.cls||[];o.A.add(r,"neo-no-animation"),t.cls=r,await super.onDragStart(e)}}const i=Neo.setupClass(a)},3175:(e,t,r)=>{r.r(t),r.d(t,{default:()=>l});var n=r(6029),o=r(6846),a=r(8825);class i extends n.A{static config={className:"Neo.draggable.toolbar.DragZone",ntype:"toolbar-dragzone"};construct(e){super.construct(e);let t=this,{owner:r}=t,n={delegate:".neo-draggable",scope:t};r.addDomListeners([{"drag:end":t.onDragEnd,...n},{"drag:move":t.onDragMove,...n},{"drag:start":t.onDragStart,...n}]),r.on({insert:t.onItemInsert,itemsCreated:t.onItemsCreated,scope:t}),t.adjustToolbarItemCls(!0)}adjustToolbarItemCls(e){let t,{owner:r}=this;r.items.forEach((r=>{t=r.wrapperCls||[],o.A.toggle(t,"neo-draggable",e),r.wrapperCls=t}))}onDragEnd(e){if(this.owner.draggable){let e=this,t=e.dragProxy,r=t.cls||{},n=e.dragElementRect,a=t.wrapperStyle||{};o.A.add(r,"neo-animate"),t.cls=r,e.timeout(30).then((()=>{a.left=`${n.left}px`,a.top=`${n.top}px`,t.wrapperStyle=a,e.timeout(100).then((()=>{e.dragEnd()}))}))}}async onDragStart(e){let t=this;t.owner.draggable&&(t.dragElement=a.A.find(t.owner.vdom,e.path[0].id).vdom,await t.dragStart(e))}onItemInsert(e){let{item:t}=e,r=t.wrapperCls||[];o.A.add(r,"neo-draggable"),t.wrapperCls=r}onItemsCreated(e){this.adjustToolbarItemCls(!0)}}const s=Neo.setupClass(i),l=Neo.setupClass(class extends s{static config={className:"Neo.draggable.toolbar.SortZone",ntype:"toolbar-sortzone",adjustItemRectsToParent:!1,alwaysFireDragMove:!0,currentIndex:-1,indexMap:null,itemMargin:null,itemRects:null,itemStyles:null,ownerRect:null,ownerStyle:null,reversedLayoutDirection:!1,scrollLeft:0,scrollTop:0,sortDirection:"horizontal",startIndex:-1};isOverDragging=!1;moveTo(e,t){this.owner.moveTo(e,t)}async onDragEnd(e){let t,r=this,{itemStyles:n,owner:o}=r,a=o.style||{};await r.timeout(10),o.sortable&&(a.height=r.ownerStyle.height||null,a.minWidth=r.ownerStyle.minWidth||null,a.width=r.ownerStyle.width||null,o.style=a,o.items.forEach(((e,o)=>{t=e.wrapperStyle||{},Object.assign(t,{height:n[o].height||null,left:null,margin:null,position:null,top:null,width:n[o].width||null}),o===r.startIndex&&(t.visibility=null),e.wrapperStyle=t})),r.startIndex!==r.currentIndex&&r.moveTo(r.startIndex,r.currentIndex),Object.assign(r,{currentIndex:-1,indexMap:null,itemRects:null,itemStyles:null,ownerRect:null,startIndex:-1}),await r.timeout(30),r.dragEnd(e))}async onDragMove(e){if(!this.itemRects||this.isScrolling)return;let t,r,n,o,a,i,s=this,{clientX:l,clientY:d}=e,c=s.currentIndex,{itemRects:h}=s,g=h.length-1,u=s.adjustItemRectsToParent?s.ownerRect.x:0,p=s.adjustItemRectsToParent?s.ownerRect.y:0,m=s.reversedLayoutDirection;"horizontal"===s.sortDirection?(t=l-u+s.scrollLeft-s.offsetX-h[c].left,n=l>s.boundaryContainerRect.right,o=l<s.boundaryContainerRect.left,a="width"):(t=d-p+s.scrollTop-s.offsetY-h[c].top,n=d>s.boundaryContainerRect.bottom,o=d<s.boundaryContainerRect.top,a="height"),r=n||o,i=r?.02:.55,o?c>0&&(s.currentIndex--,await s.scrollToIndex(),s.switchItems(c,s.currentIndex)):n?c<g&&(s.currentIndex++,await s.scrollToIndex(),s.switchItems(c,s.currentIndex)):c>0&&(!m&&t<0||m&&t>0)?Math.abs(t)>h[c-1][a]*i&&(s.currentIndex--,s.switchItems(c,s.currentIndex)):c<g&&(!m&&t>0||m&&t<0)&&Math.abs(t)>h[c+1][a]*i&&(s.currentIndex++,s.switchItems(c,s.currentIndex)),s.isOverDragging=r&&0!==s.currentIndex&&s.currentIndex!==g,s.isOverDragging&&(await s.timeout(30),s.isOverDragging&&await s.onDragMove(e))}async onDragStart(e){let t,r,n,o,i=this,s=Neo.getComponent(e.path[0].id),{owner:l}=i,d=i.itemStyles=[],{layout:c}=l,h=l.style||{};l.sortable&&(t=l.indexOf(s.id),r={},Object.assign(i,{currentIndex:t,dragElement:a.A.find(l.vdom,s.id).vdom,dragProxyConfig:{...i.dragProxyConfig,cls:[...l.cls]},indexMap:r,ownerStyle:{height:h.height,minWidth:h.minWidth,width:h.width},reversedLayoutDirection:"column-reverse"===c.direction||"row-reverse"===c.direction,sortDirection:c.direction?.includes("column")?"vertical":"horizontal",startIndex:t}),await i.dragStart(e),l.items.forEach(((e,t)=>{r[t]=t,d.push({height:e.height?`${e.height}px`:e.style?.height,width:e.width?`${e.width}px`:e.style?.width})})),l.getDomRect([l.id].concat(l.items.map((e=>e.id)))).then((e=>{i.ownerRect=e[0],l.style={...h,height:`${e[0].height}px`,minWidth:`${e[0].width}px`,width:`${e[0].width}px`},e.shift(),i.adjustItemRectsToParent&&e.forEach((e=>{e.x-=i.ownerRect.x,e.y-=i.ownerRect.y})),i.itemRects=e,l.items.forEach(((t,r)=>{n=t.wrapperStyle||{},o=e[r],i.adjustProxyRectToParent?.(o,i.ownerRect),t.wrapperStyle=Object.assign(n,{height:`${o.height}px`,left:`${o.left}px`,margin:i.itemMargin,position:"absolute",top:`${o.top}px`,width:`${o.width}px`})})),i.timeout(5).then((()=>{n=s.wrapperStyle||{},n.visibility="hidden",s.wrapperStyle=n}))})))}async scrollToIndex(){let e=this;e.isScrolling=!0,await(e.owner.scrollToIndex?.(e.currentIndex,e.itemRects[e.currentIndex])),e.isScrolling=!1}switchItems(e,t){let r,n=this,o=n.reversedLayoutDirection;(!o&&t<e||o&&e<t)&&(r=e,e=t,t=r);let a=n.itemRects,i=n.indexMap,s=a[e],l=a[t],d=s.clone(),c=l.clone();"horizontal"===n.sortDirection?(s.width=c.width,l.x=d.x+c.width,l.width=d.width):(s.height=c.height,l.height=d.height,l.y=d.y+c.height),r=i[e],i[e]=i[t],i[t]=r,n.updateItem(e,s),n.updateItem(t,l)}updateItem(e,t){let r=this.owner.items[this.indexMap[e]],{wrapperStyle:n}=r;n.left=`${t.left}px`,n.top=`${t.top}px`,r.wrapperStyle=n}})}}]);
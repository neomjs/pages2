import e from"./DefaultConfig.mjs";const t=Symbol.for("configSymbol"),r=Symbol("getSetCache");let o=self.Neo||{};o=self.Neo=Object.assign({ntypeMap:{},insideWorker:"undefined"!=typeof DedicatedWorkerGlobalScope||"undefined"!=typeof WorkerGlobalScope,applyClassConfig(e){let s,c,f,p=null,u=null,y=e.prototype||e,m=[];for(;y.__proto__;){if(c=y.constructor,c.hasOwnProperty("classConfigApplied")){p=o.clone(c.config,!0),u=o.clone(c.staticConfig,!0);break}m.unshift(y),y=y.__proto__}s=p||{},f=u||{},m.forEach((p=>{c=p.constructor;let u,y=c.getConfig?.()||{},m=c.getStaticConfig?.()||{};y&&Object.entries(y).forEach((([e,s])=>{"_"===e.slice(-1)?(delete y[e],e=e.slice(0,-1),y[e]=s,function(e,s){if(i(e,s))throw"Config "+s+"_ ("+e.className+") already has a set method, use beforeGet, beforeSet & afterSet instead";o[r]||(o[r]={});o[r][s]||(o[r][s]={get(){let e=this,r=`beforeGet${s[0].toUpperCase()+s.slice(1)}`,o=e[t].hasOwnProperty(s),n=e[t][s],i=o?n:e["_"+s];return Array.isArray(i)?"items"!==s&&(i=[...i]):i instanceof Date&&(i=new Date(i.valueOf())),o&&(e[s]=i,i=e["_"+s],delete e[t][s]),"function"==typeof e[r]&&(i=e[r](i)),i},set(e){let r=this,n="_"+s,i=s[0].toUpperCase()+s.slice(1),a="beforeSet"+i,l="afterSet"+i,c=r[n];if(delete r[t][s],"items"!==s&&(e=o.clone(e,!0,!0)),r[n]=e,"function"==typeof r[a]){if(void 0===(e=r[a](e,c)))return void(r[n]=c);r[n]=e}o.isEqual(e,c)||(r[l]?.(e,c),r.afterSetConfig?.(s,e,c))}});Object.defineProperty(e,s,o[r][s])}(p,e)):i(p,e)||Object.defineProperty(p,e,{enumerable:!0,value:s,writable:!0})})),Object.assign(c,m),y.hasOwnProperty("ntype")&&(o.ntypeMap[y.ntype]=y.className),u=s.hasOwnProperty("mixins")&&s.mixins||[],m?.observable&&u.push("Neo.core.Observable"),y.hasOwnProperty("mixins")&&Array.isArray(y.mixins)&&y.mixins.length>0&&u.push(...y.mixins),u.length>0&&(!function(e,t){Array.isArray(t)||(t=[t]);let r,s,i,c=0,f=t.length,p={};for(;c<f;c++){if(r=t[c],r.isClass)i=r.prototype,s=o.ns(i.className);else{if(!n(r))throw new Error("Attempting to mixin an undefined class: "+r+", "+e.prototype.className);s=o.ns(r),i=s.prototype}i.className.split(".").reduce(l(s),p),Object.getOwnPropertyNames(i).forEach(a(e.prototype,i))}e.prototype.mixins=p}(c,u),o.ns("Neo.core.Observable",!1,c.prototype.mixins)&&(m.observable=!0)),delete y.mixins,delete s.mixins,Object.assign(s,y),Object.assign(f,m),Object.assign(c,{classConfigApplied:!0,config:o.clone(s,!0),isClass:!0,staticConfig:o.clone(f,!0)}),delete c.getConfig,delete c.getStaticConfig,s.singleton||this.applyToGlobalNs(e)}))},applyFromNs(e,t,r,s){let n;return e&&"Object"===o.typeOf(r)&&Object.entries(r).forEach((([r,o])=>{n=t[o],e[r]=s?n.bind(t):n})),e},applyToGlobalNs(e){let t,r,s,n,i="function"==typeof e?e.prototype:e;!0===i.constructor.registerToGlobalNs&&(t=i.isClass?i.config.className:i.className,r=t.split("."),s=r.pop(),n=o.ns(r,!0),n[s]=e)},assignDefaults:(e,t)=>(e&&"Object"===o.typeOf(t)&&Object.entries(t).forEach((([t,r])=>{e.hasOwnProperty(t)||(e[t]=r)})),e),clone(e,t=!1,r=!1){let s;switch(o.typeOf(e)){case"Array":return t?[...e.map((e=>o.clone(e,t,r)))]:[...e];case"Date":return new Date(e.valueOf());case"Map":return new Map(e);case"NeoInstance":return r?e:this.cloneNeoInstance(e);case"Object":return s={},Object.entries(e).forEach((([e,n])=>{s[e]=t?o.clone(n,t,r):n})),s;case"Set":return new Set(e);default:return e}},cloneNeoInstance(e){let t={...e.originalConfig};return delete t._id,delete t.id,o.create(e.className,t)},create(e,t){let r,s,i=o.typeOf(e);if("NeoClass"===i)r=e;else{if("Object"===i){if(!(t=e).className&&!t.module)return console.error("Class created with object configuration missing className or module property",t),null;e=t.className||t.module.prototype.className}if(!n(e))throw new Error("Class "+e+" does not exist");r=o.ns(e)}return s=new r(t),s.onConstructed(),s.onAfterConstructed(),s.init(),s},emptyFn(){},ns:(e,t,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce(((e,r)=>{if(t&&!e[r]&&(e[r]={}),e)return e[r]}),r||self),ntype(e,t){if("object"==typeof e){if(!(t=e).ntype)throw new Error("Class defined with object configuration missing ntype property. "+t.ntype);e=t.ntype}let r=o.ntypeMap[e];if(!r)throw new Error("ntype "+e+" does not exist");return o.create(r,t)},typeOf(e){if(null==e)return null;switch(typeof e){case"function":if(e.prototype?.constructor.isClass)return"NeoClass";break;case"object":if(e.constructor.isClass&&e instanceof o.core.Base)return"NeoInstance"}return e.constructor.name}},o);const s=["_name","classConfigApplied","className","constructor","isClass","mixin","ntype","observable","registerToGlobalNs"];function n(e){try{return!!e.split(".").reduce(((e,t)=>e[t]),self)}catch(e){return!1}}function i(e,t){let r;for(;e.__proto__;){if(r=Object.getOwnPropertyDescriptor(e,t),"object"==typeof r&&"function"==typeof r.set)return!0;e=e.__proto__}return!1}function a(e,t){return function(r){if(!~s.indexOf(r)){if(e[r]?._from){if(t.className===e[r]._from)return void console.warn("Mixin set multiple times or already defined on a Base Class",e.className,t.className,r);throw new Error(`${e.className}: Multiple mixins defining same property (${t.className}, ${e[r]._from}) => ${r}`)}e[r]=t[r],Object.getOwnPropertyDescriptor(e,r)._from=t.className,"function"==typeof e[r]&&(e[r]._name=r)}}}function l(e){return(t,r,o,s)=>t[r]=o!==s.length-1?t[r]||{}:e}o.config=o.config||{},o.assignDefaults(o.config,e);export{o as default};
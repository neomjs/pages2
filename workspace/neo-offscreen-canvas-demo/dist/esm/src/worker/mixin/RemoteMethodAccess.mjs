import e from"../../core/Base.mjs";class t extends e{static getConfig(){return{className:"Neo.worker.mixin.RemoteMethodAccess",mixin:!0}}generateRemote(e,t){let r=this,o=e.origin;return function(a,i){let s={action:"remoteMethod",data:a,destination:o,remoteClassName:e.className,remoteMethod:t};return r.isSharedWorker&&(s.appName=s.appName||a?.appName,s.port=s.port||a?.port),r.promiseMessage(o,s,i)}}onRegisterRemote(e){if(e.destination===Neo.workerId){let t=this,r=e.className,o=!1,a=e.methods,i=Neo.ns(r,!0);a.forEach((function(a){if("main"!==e.origin&&i[a])throw new Error("Duplicate remote method definition "+r+"."+a);i[a]?o=!0:i[a]=t.generateRemote(e,a)})),o||"main"===Neo.workerId||t.fire("remoteregistered",e)}}onRemoteMethod(e){let t,r,o=this,a=Neo.ns(e.remoteClassName);if(!a)throw new Error('Invalid remote namespace "'+e.remoteClassName+'"');if(r=a[e.remoteMethod],!r)throw new Error('Invalid remote method name "'+e.remoteMethod+'"');t=Array.isArray(e.data)?r.call(a,...e.data):r.call(a,e.data),t instanceof Promise?t.then((t=>{o.resolve(e,t)})).catch((t=>{o.reject(e,t)})):o.resolve(e,t)}reject(e,t){let r={action:"reply",data:t,reject:!0,replyId:e.id};this.isSharedWorker&&(r.appName=e.appName,r.port=e.port),this.sendMessage(e.origin,r)}resolve(e,t){let r={action:"reply",data:t,replyId:e.id};this.isSharedWorker&&(r.appName=e.appName,r.port=e.port),this.sendMessage(e.origin,r)}}Neo.applyClassConfig(t);export{t as default};
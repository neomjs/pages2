import e from"./IdGenerator.mjs";const t=Symbol.for("configSymbol"),r=Symbol("forceAssignConfigs"),o=Symbol("isInstance");class s{static getStaticConfig(){return{registerToGlobalNs:!0}}static getConfig(){return{className:"Neo.core.Base",ntype:"base",id_:null,isConstructed:!1,mixins:null,module:null}}constructor(e={}){let r=this;Object.defineProperties(r,{[t]:{configurable:!0,enumerable:!1,value:{},writable:!0},[o]:{enumerable:!1,value:!0}}),r.createId(e.id||r.id),delete e.id,r.constructor.config&&delete r.constructor.config.id,r.getStaticConfig("observable")&&r.initObservable(e),r.initConfig(e),Object.defineProperty(r,"configsApplied",{enumerable:!1,value:!0}),r.remote&&setTimeout(r.initRemote.bind(r),1)}afterSetId(e,t){let r=this;t&&(!0===s.instanceManagerAvailable?Neo.manager.Instance.unregister(t):delete Neo.idMap[t]),!0===s.instanceManagerAvailable?Neo.manager.Instance.register(r):(Neo.idMap=Neo.idMap||{},Neo.idMap[r.id]=r)}beforeSetEnumValue(e,t,r,o=r+"s"){const s=Array.isArray(o)?o:this.getStaticConfig(o);return s.includes(e)?e:(Neo.logError(`Supported values for ${r} are: ${s.join(", ")}`,this),t)}createId(t){this.id=t||e.getId(this.getIdKey())}destroy(){let e=this;!0===s.instanceManagerAvailable?Neo.manager.Instance.unregister(e):Neo.idMap&&delete Neo.idMap[e.id],Object.keys(e).forEach((t=>{Object.getOwnPropertyDescriptor(e,t).writable&&delete e[t]}))}getIdKey(){return this.ntype}getStaticConfig(e){let t=this.constructor.staticConfig;return e?t[e]:t}init(){}initConfig(e,r){let o=this;Object.assign(o[t],o.mergeConfig(e,r)),o.processConfigs()}initRemote(){let e,t=this,r=t.remote,o=t.className,n=Neo.currentWorker;if(!t.singleton)throw new Error("Remote method access is only functional for Singleton classes "+o);!Neo.config.unitTestMode&&Neo.isObject(r)&&("main"!==Neo.workerId&&n.isSharedWorker&&!n.isConnected?e=n.on("connected",(()=>{n.un("connected",e),s.sendRemotes(o,r)})):s.sendRemotes(o,r))}mergeConfig(e,t){let r=this,o=r.constructor;if(!o.config)throw new Error("Neo.applyClassConfig has not been run on "+r.className);return t||(r.originalConfig=Neo.clone(e,!0,!0)),{...o.config,...e}}onAfterConstructed(){let e=this;e.isConstructed=!0,e.getStaticConfig("observable")&&e.fire("constructed",e)}onConstructed(){}parseItemConfigs(e){let r=this;e&&(Array.isArray(e)||(e=[e]),e.forEach((e=>{Object.entries(e).forEach((([o,s])=>{Array.isArray(s)?r.parseItemConfigs(s):"string"==typeof s&&s.startsWith("@config:")&&(s=s.substr(8).trim(),r[s]||r.hasOwnProperty(s)?e[o]=r[t][s]||r[s]:console.error("The used @config does not exist:",s,r))}))})))}processConfigs(e=!1){let o=this,s=Object.keys(o[t]);o[r]=e,s.length>0&&(!e&&o.hasOwnProperty(s[0])||(o[s[0]]=o[t][s[0]]),delete o[t][s[0]],o.processConfigs(e))}static sendRemotes(e,t){let r;Object.entries(t).forEach((([t,o])=>{Neo.workerId!==t&&(r="main"===Neo.workerId?Neo.worker.Manager:Neo.currentWorker,r.sendMessage(t,{action:"registerRemote",methods:o,className:e}))}))}set(e={}){let o=this;!0!==o[r]&&Object.keys(o[t]).length>0&&o.processConfigs(),Object.assign(o[t],e),o.processConfigs(!0)}setStaticConfig(e,t){let r=this.constructor.staticConfig;return!!r.hasOwnProperty(e)&&(r[e]=t,!0)}get[Symbol.toStringTag](){return`${this.className} (id: ${this.id})`}static[Symbol.hasInstance](e){return!!e&&(!0===e[o]&&super[Symbol.hasInstance](e))}}Neo.applyClassConfig(s),s.instanceManagerAvailable=!1;export{s as default};
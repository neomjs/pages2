(self["webpackChunkneo_offscreen_canvas_demo"] = self["webpackChunkneo_offscreen_canvas_demo"] || []).push([["vendors-node_modules_d3fc_d3fc-webgl_build_d3fc-webgl_js"],{

/***/ "./node_modules/@d3fc/d3fc-webgl/build/d3fc-webgl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@d3fc/d3fc-webgl/build/d3fc-webgl.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(/*! @d3fc/d3fc-rebind */ "./node_modules/@d3fc/d3fc-rebind/index.js"), __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/index.js"), __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js")) :
    0;
}(this, function (exports, d3fcRebind, d3Scale, d3Shape) { 'use strict';

    var baseScale = (function () {
      var domain = [0, 1];
      var range = [-1, 1];

      var base = function base() {};

      base.domain = function () {
        if (!arguments.length) {
          return domain;
        }

        domain = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.range = function () {
        if (!arguments.length) {
          return range;
        }

        range = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var bufferBuilder = (function () {
      var attributes = {};
      var uniforms = {};
      var elementIndices = null;

      var bufferBuilder = function bufferBuilder(programBuilder, program) {
        var gl = programBuilder.context();
        Object.keys(attributes).forEach(function (name) {
          var attribute = attributes[name];

          if (typeof attribute !== 'function') {
            throw new Error("Expected an attribute for ".concat(name, ", found ").concat(attribute));
          }

          var location = gl.getAttribLocation(program, name);
          attribute.location(location)(programBuilder);
        });
        Object.keys(uniforms).forEach(function (name) {
          var uniform = uniforms[name];

          if (typeof uniform !== 'function') {
            throw new Error("Expected a uniform for ".concat(name, ", found ").concat(uniform));
          }

          var location = gl.getUniformLocation(program, name);
          uniform.location(location)(programBuilder);
        });

        if (elementIndices !== null) {
          elementIndices(programBuilder);
        }
      };

      bufferBuilder.flush = function () {
        Object.values(attributes).forEach(function (attribute) {
          return attribute.clear();
        });
        Object.values(uniforms).forEach(function (uniform) {
          return uniform.clear();
        });
        if (elementIndices !== null) elementIndices.clear();
      };

      bufferBuilder.attribute = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1) {
          return attributes[args[0]];
        }

        attributes[args[0]] = args[1];
        return bufferBuilder;
      };

      bufferBuilder.uniform = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (args.length === 1) {
          return uniforms[args[0]];
        }

        uniforms[args[0]] = args[1];
        return bufferBuilder;
      };

      bufferBuilder.elementIndices = function () {
        if (!arguments.length) {
          return elementIndices;
        }

        elementIndices = arguments.length <= 0 ? undefined : arguments[0];
        return bufferBuilder;
      };

      return bufferBuilder;
    });

    var uniform = (function (initialData) {
      var location = -1;
      var data = initialData;
      var dirty = true;

      var build = function build(programBuilder) {
        if (!dirty) {
          return;
        }

        var gl = programBuilder.context();

        if (Array.isArray(data)) {
          switch (data.length) {
            case 1:
              gl.uniform1fv(location, data);
              break;

            case 2:
              gl.uniform2fv(location, data);
              break;

            case 3:
              gl.uniform3fv(location, data);
              break;

            case 4:
              gl.uniform4fv(location, data);
              break;

            default:
              throw new Error("Uniform supports up to 4 elements. ".concat(data.length, " provided."));
          }
        } else {
          gl.uniform1f(location, data);
        }

        dirty = false;
      };

      build.clear = function () {
        dirty = true;
      };

      build.location = function () {
        if (!arguments.length) {
          return location;
        }

        if (location !== (arguments.length <= 0 ? undefined : arguments[0])) {
          location = arguments.length <= 0 ? undefined : arguments[0];
          dirty = true;
        }

        return build;
      };

      build.data = function () {
        if (!arguments.length) {
          return data;
        }

        data = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return build;
      };

      return build;
    });

    var drawModes = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };

    var programBuilder = (function () {
      var context = null;
      var program = null;
      var vertexShader = null;
      var fragmentShader = null;
      var programVertexShader = null;
      var programFragmentShader = null;
      var mode = drawModes.TRIANGLES;
      var subInstanceCount = 0;
      var buffers = bufferBuilder();
      var debug = false;
      var extInstancedArrays = null;
      var dirty = true;
      var pixelRatio = 1;

      var build = function build(count) {
        if (context == null) {
          return;
        }

        var vertexShaderSource = vertexShader();
        var fragmentShaderSource = fragmentShader();

        if (newProgram(program, vertexShaderSource, fragmentShaderSource)) {
          program = createProgram(vertexShaderSource, fragmentShaderSource);
          programVertexShader = vertexShaderSource;
          programFragmentShader = fragmentShaderSource;
          dirty = false;
        }

        context.useProgram(program);
        buffers.uniform('uScreen', uniform([context.canvas.width / pixelRatio, context.canvas.height / pixelRatio]));
        buffers(build, program);

        if (subInstanceCount === 0) {
          if (buffers.elementIndices() == null) {
            context.drawArrays(mode, 0, count);
          } else {
            context.drawElements(mode, count, context.UNSIGNED_SHORT, 0);
          }
        } else {
          if (buffers.elementIndices() == null) {
            extInstancedArrays.drawArraysInstancedANGLE(mode, 0, subInstanceCount, count);
          } else {
            var elementIndicesLength = buffers.elementIndices().data().length;

            if (subInstanceCount !== elementIndicesLength) {
              throw new Error("Expected elementIndices length ".concat(elementIndicesLength) + " to match subInstanceCount ".concat(subInstanceCount, "."));
            }

            extInstancedArrays.drawElementsInstancedANGLE(mode, subInstanceCount, context.UNSIGNED_SHORT, 0, count);
          }
        }
      };

      build.extInstancedArrays = function () {
        return extInstancedArrays;
      };

      build.context = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!args.length) {
          return context;
        }

        if (args[0] == null || args[0] !== context) {
          buffers.flush();
          dirty = true;
        }

        if (args[0] != null && args[0] !== context) {
          extInstancedArrays = args[0].getExtension('ANGLE_instanced_arrays');
        }

        context = args[0];
        return build;
      };

      build.buffers = function () {
        if (!arguments.length) {
          return buffers;
        }

        buffers = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.vertexShader = function () {
        if (!arguments.length) {
          return vertexShader;
        }

        vertexShader = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.fragmentShader = function () {
        if (!arguments.length) {
          return fragmentShader;
        }

        fragmentShader = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.mode = function () {
        if (!arguments.length) {
          return mode;
        }

        mode = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.subInstanceCount = function () {
        if (!arguments.length) {
          return subInstanceCount;
        }

        subInstanceCount = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.debug = function () {
        if (!arguments.length) {
          return debug;
        }

        debug = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.pixelRatio = function () {
        if (!arguments.length) {
          return pixelRatio;
        }

        pixelRatio = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      return build;

      function newProgram(program, vertexShader, fragmentShader) {
        if (!program || dirty) {
          return true;
        }

        return vertexShader !== programVertexShader || fragmentShader !== programFragmentShader;
      }

      function createProgram(vertexShaderSource, fragmentShaderSource) {
        var vertexShader = loadShader(vertexShaderSource, context.VERTEX_SHADER);
        var fragmentShader = loadShader(fragmentShaderSource, context.FRAGMENT_SHADER);
        var program = context.createProgram();
        context.attachShader(program, vertexShader);
        context.attachShader(program, fragmentShader);
        context.linkProgram(program);

        if (debug && !context.getProgramParameter(program, context.LINK_STATUS)) {
          var message = context.getProgramInfoLog(program);
          context.deleteProgram(program);
          throw new Error("Failed to link program : ".concat(message, "\n            Vertex Shader : ").concat(vertexShaderSource, "\n            Fragment Shader : ").concat(fragmentShaderSource));
        }

        return program;
      }

      function loadShader(source, type) {
        var shader = context.createShader(type);
        context.shaderSource(shader, source);
        context.compileShader(shader);

        if (debug && !context.getShaderParameter(shader, context.COMPILE_STATUS)) {
          var message = context.getShaderInfoLog(shader);
          context.deleteShader(shader);
          throw new Error("Failed to compile shader : ".concat(message, "\n            Shader : ").concat(source));
        }

        return shader;
      }
    });

    var shaderBuilder = (function (base) {
      var shaderHeaders = [];
      var shaderBodies = [];

      var build = function build() {
        return base(shaderHeaders.join('\n'), shaderBodies.join('\n'));
      };

      function append(array, element) {
        array.push(element);
      }

      function insert(array, element, before) {
        var beforeIndex = array.indexOf(before);
        array.splice(beforeIndex >= 0 ? beforeIndex : array.length, 0, element);
      }

      function appendIfNotExists(array, element) {
        var elementIndex = array.indexOf(element);

        if (elementIndex === -1) {
          array.push(element);
        }
      }

      build.appendHeader = function (header) {
        append(shaderHeaders, header);
        return build;
      };

      build.insertHeader = function (header, before) {
        insert(shaderHeaders, header, before);
        return build;
      };

      build.appendHeaderIfNotExists = function (header) {
        appendIfNotExists(shaderHeaders, header);
        return build;
      };

      build.appendBody = function (body) {
        append(shaderBodies, body);
        return build;
      };

      build.insertBody = function (body, before) {
        insert(shaderBodies, body, before);
        return build;
      };

      build.appendBodyIfNotExists = function (body) {
        appendIfNotExists(shaderBodies, body);
        return build;
      };

      return build;
    }); // inf is precalculated here for use in some functions (e.g. log scale calculations)

    var vertexShaderBase = function vertexShaderBase(header, body) {
      return "\nprecision mediump float;\nfloat inf = 1.0 / 0.0;\n".concat(header, "\nvoid main() {\n    ").concat(body, "\n}");
    };
    var fragmentShaderBase = function fragmentShaderBase(header, body) {
      return "\nprecision mediump float;\n".concat(header, "\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ").concat(body, "\n}");
    };

    var fillColor = {
      header: "attribute vec4 aFillColor;\n             varying vec4 vFillColor;",
      body: "vFillColor = aFillColor;"
    };
    var strokeColor = {
      header: "attribute vec4 aStrokeColor;\n             varying vec4 vStrokeColor;",
      body: "vStrokeColor = aStrokeColor;"
    };
    var circle = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 2.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var star = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 4.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var wye = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var square = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var diamond = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = 2.0 * (vSize + uStrokeWidth + 1.0);\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var triangle = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = sqrt((16.0 * aSize) / (3.0 * sqrt(3.0)));\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var cross = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 5.0);\n        vStrokeWidthRatio = uStrokeWidth / (vSize + uStrokeWidth + 1.0);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var candlestick = {
      header: "\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n         (isPositiveY * isExtremeY * aLowValue) +\n         (isPositiveY * isNotExtremeY * aCloseValue) +\n         (isNotPositiveY * isNotExtremeY * aOpenValue) +\n         (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = (isNotExtremeY * aCorner.x) + (isExtremeY * aCorner.z);\n        float lineWidthYDirection = isNotExtremeY * sign(aCloseValue - aOpenValue) * aCorner.y;\n\n        float bandwidthModifier = aBandwidth * aCorner.x / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"
    };
    var ohlc = {
      header: "\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n            (isPositiveY * isExtremeY * aLowValue) +\n            (isPositiveY * isNotExtremeY * aCloseValue) +\n            (isNotPositiveY * isNotExtremeY * aOpenValue) +\n            (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = isExtremeY * aCorner.z;\n        float lineWidthYDirection = isNotExtremeY * aCorner.z;\n\n        float bandwidthModifier = isNotExtremeY * aCorner.x * aBandwidth / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"
    };
    var bar = {
      header: "\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aMainValue;\n        attribute float aBaseValue;\n        attribute vec2 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        float isBaseline = (1.0 - aCorner.y) / 2.0;\n        float yValue = (isBaseline * aBaseValue) + ((1.0 - isBaseline) * aMainValue);\n\n        float xModifier = aCorner.x * (aBandwidth) / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"
    };
    var preScaleLine = {
      header: "\n        attribute vec3 aCorner;\n        attribute float aCrossNextNextValue;\n        attribute float aMainNextNextValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossPrevValue;\n        attribute float aMainPrevValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        uniform float uStrokeWidth;\n        uniform vec2 uScreen;\n\n        varying float vDefined;",
      body: "\n        vDefined = aDefined * aDefinedNext;\n        vec4 prev = vec4(aCrossPrevValue, aMainPrevValue, 0, 0);\n        vec4 curr = vec4(aCrossValue, aMainValue, 0, 0);\n        gl_Position = vec4(aCrossNextValue, aMainNextValue, 0, 1);\n        vec4 nextNext = vec4(aCrossNextNextValue, aMainNextNextValue, 0, 0);"
    };
    var postScaleLine = {
      body: "\n        vec4 currVertexPosition = gl_Position;\n        vec4 nextVertexPosition = gl_Position;\n\n        if (all(equal(curr.xy, prev.xy))) {\n            prev.xy = curr.xy + normalize(curr.xy - currVertexPosition.xy);\n        }\n        if (all(equal(curr.xy, currVertexPosition.xy))) {\n            currVertexPosition.xy = curr.xy + normalize(curr.xy - prev.xy);\n        }\n        vec2 A = normalize(normalize(curr.xy - prev.xy) * uScreen);\n        vec2 B = normalize(normalize(currVertexPosition.xy - curr.xy) * uScreen);\n        vec2 tangent = normalize(A + B);\n        vec2 miter = vec2(-tangent.y, tangent.x);\n        vec2 normalA = vec2(-A.y, A.x);\n        float miterLength = 1.0 / dot(miter, normalA);\n        vec2 point = normalize(A - B);\n        if (miterLength > 10.0 && sign(aCorner.x * dot(miter, point)) > 0.0) {\n            currVertexPosition.xy = curr.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalA) / uScreen.xy;\n        } else {\n            currVertexPosition.xy = curr.xy + (aCorner.x * miter * uStrokeWidth * miterLength) / uScreen.xy;\n        }\n\n        if (all(equal(nextVertexPosition.xy, curr.xy))) {\n            curr.xy = nextVertexPosition.xy + normalize(nextVertexPosition.xy - nextNext.xy);\n        }\n        if (all(equal(nextVertexPosition.xy, nextNext.xy))) {\n            nextNext.xy = nextVertexPosition.xy + normalize(nextVertexPosition.xy - curr.xy);\n        }\n        vec2 C = normalize(normalize(nextVertexPosition.xy - curr.xy) * uScreen);\n        vec2 D = normalize(normalize(nextNext.xy - nextVertexPosition.xy) * uScreen);\n        vec2 tangentCD = normalize(C + D);\n        vec2 miterCD = vec2(-tangentCD.y, tangentCD.x);\n        vec2 normalC = vec2(-C.y, C.x);\n        float miterCDLength = 1.0 / dot(miterCD, normalC);\n        vec2 pointCD = normalize(C - D);\n        if (miterCDLength > 10.0 && sign(aCorner.x * dot(miterCD, pointCD)) > 0.0) {\n            nextVertexPosition.xy = nextVertexPosition.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalC) / uScreen.xy;\n        } else {\n            nextVertexPosition.xy = nextVertexPosition.xy + (aCorner.x * miterCD * uStrokeWidth * miterCDLength) / uScreen.xy;\n        }\n\n        gl_Position.xy = ((1.0 - aCorner.z) * currVertexPosition.xy) + (aCorner.z * nextVertexPosition.xy);"
    };
    var errorBar = {
      header: "\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        float isLow = (aCorner.y + 1.0) / 2.0;\n        float yValue = isLow * aLowValue + (1.0 - isLow) * aHighValue;\n\n        float isEdgeCorner = abs(aCorner.x);\n        float lineWidthXDirection = (1.0 - isEdgeCorner) * aCorner.z;\n        float lineWidthYDirection = isEdgeCorner * aCorner.z;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection) + (aBandwidth * aCorner.x / 2.0);\n        float yModifier = (uStrokeWidth * lineWidthYDirection);"
    };
    var area = {
      header: "\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aBaseValue;\n        attribute float aBaseNextValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        varying float vDefined;\n\n        float when_lt(float a, float b) {\n            return max(sign(b - a), 0.0);\n        }\n\n        float and(float a, float b) {\n            return a * b;\n        }",
      body: "\n        vDefined = aDefined * aDefinedNext;\n        gl_Position = vec4(0, 0, 0, 1);\n\n        float hasIntercepted = when_lt((aMainNextValue - aBaseNextValue) * (aMainValue - aBaseValue), 0.0);\n        float useIntercept = and(aCorner.z, hasIntercepted);\n\n        float yGradient = (aMainNextValue - aMainValue) / (aCrossNextValue - aCrossValue);\n        float yConstant = aMainNextValue - (yGradient * aCrossNextValue);\n\n        float y0Gradient = (aBaseNextValue - aBaseValue) / (aCrossNextValue - aCrossValue);\n        float y0Constant = aBaseNextValue - (y0Gradient * aCrossNextValue);\n\n        float denominator = (yGradient - y0Gradient) + step(abs(yGradient - y0Gradient), 0.0);\n        float interceptXValue = (y0Constant - yConstant) / denominator;\n        float interceptYValue = (yGradient * interceptXValue) + yConstant;\n\n        gl_Position = vec4(interceptXValue * useIntercept, interceptYValue * useIntercept, 0, 1);\n\n        gl_Position.x += (1.0 - useIntercept) * ((aCorner.x * aCrossNextValue) + ((1.0 - aCorner.x) * aCrossValue));\n        gl_Position.y += (1.0 - useIntercept) * (1.0 - aCorner.y) * ((aCorner.x * aMainNextValue) + ((1.0 - aCorner.x) * aMainValue));\n        gl_Position.y += (1.0 - useIntercept) * aCorner.y * ((aCorner.x * aBaseNextValue) + ((1.0 - aCorner.x) * aBaseValue));"
    };
    var boxPlot = {
      header: "\n        attribute vec4 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aCapWidth;\n        attribute float aHighValue;\n        attribute float aUpperQuartileValue;\n        attribute float aMedianValue;\n        attribute float aLowerQuartileValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;\n    ",
      body: "\n        vDefined = aDefined;\n        float isExtremeY = sign(abs(aCorner.y) - 2.0) + 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n\n        float isNonZeroY = abs(sign(aCorner.y));\n        float isZeroY = 1.0 - isNonZeroY;\n\n        float isQuartileY = isNotExtremeY * isNonZeroY;\n\n        float isPositiveY = (sign(aCorner.y + 0.5) + 1.0) / 2.0;\n        float isNegativeY = 1.0 - isPositiveY;\n\n        float yValue =\n          (isExtremeY * isNegativeY) * aHighValue +\n          (isQuartileY * isNegativeY) * aUpperQuartileValue +\n          isZeroY * aMedianValue +\n          (isQuartileY * isPositiveY) * aLowerQuartileValue +\n          (isExtremeY * isPositiveY) * aLowValue;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float isHorizontal = aCorner.w;\n        float isVertical = 1.0 - isHorizontal;\n\n        float xDisplacement = aCorner.x * (isExtremeY * aCapWidth + isNotExtremeY * aBandwidth) / 2.0;\n\n        float xModifier = (isVertical * uStrokeWidth * aCorner.z / 2.0) + xDisplacement;\n        float yModifier = isHorizontal * uStrokeWidth * aCorner.z / 2.0;"
    };

    var circle$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float distance = length(2.0 * gl_PointCoord - 1.0);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"
    }; // See https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm.

    var star$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;\n\n        // anterior, exterior angles\n        float an = 0.628319;\n        vec2 acs = vec2(0.809017, 0.587786); // (cos, sin)\n        float en = 0.952000;\n        vec2 ecs = vec2(0.580055, 0.814577);\n    ",
      body: "\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        p -= acs;\n        p += ecs * clamp(-dot(p, ecs), 0.0, acs.y / ecs.y);\n        float d = length(p) * sign(p.x);\n\n        float distance = 1.0 + d;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"
    };
    var wye$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;\n    ",
      body: "\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float an = 3.141593 / 3.0;\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        // box\n        vec2 d = abs(p) - vec2(0.9, 0.35);\n        float sdf = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n\n        float distance = 1.0 + sdf;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"
    };
    var square$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float distance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);"
    }; // Diamond is symmetrical about the x, and y axes, so only consider x, y > 0.
    // (x, y) are the coordinates of the fragment within the gl point (after
    // transformed to be [-1, 1]).
    // a, b control the width, height of the triangle, so diamond is 2a, 2b.
    // Line L is a ray from the origin through (x, y), the distance function is then
    // the distance to (x, y) divided by the distance to where L intersects with the
    // diamond, this makes the distance function < 1 inside, 1 on the boundary, and
    // > 1 outside the diamond.
    //    |
    // b ---
    //    |\             L
    //    | -\          /
    //    |   \        /
    //    |    \      /
    //    |     -\   /
    //    |       \ /
    // Y ---       X
    //    |       / -\
    //    |      /    \
    //    |     /      \
    // y ---   X        -\
    //    |   /           \
    //    |  /             \
    //    | /               -\
    //    |/                  \
    //    +----|---|-----------|---
    //         x   X           a

    var diamond$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;\n        float a = 0.6;\n        float b = 1.0;\n    ",
      body: "\n        if (vDefined < 0.5) {\n            discard;\n        }\n\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n\n        float x = abs(pointCoordTransform.x);\n        float y = abs(pointCoordTransform.y);\n\n        float X = (a * b * x) / (a * y + b * x);\n        float Y = (a * b * y) / (a * y + b * x);\n\n        float distance = length(vec2(x, y)) / length(vec2(X, Y));\n\n        if (distance > 1.0) {\n            discard;\n        }\n    "
    };
    var triangle$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float topEdgesDistance = abs(pointCoordTransform.x) - ((pointCoordTransform.y - 0.6) / sqrt(3.0));\n        float bottomEdgeDistance = pointCoordTransform.y + 0.5;\n        float distance = max(topEdgesDistance, bottomEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }"
    };
    var cross$1 = {
      header: "\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float innerCornerDistance = min(abs(pointCoordTransform.x), abs(pointCoordTransform.y)) + 0.66 - vStrokeWidthRatio;\n        float outerEdgeDistance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float distance = max(innerCornerDistance, outerEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }"
    };
    var candlestick$1 = {
      header: "\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }"
    };
    var ohlc$1 = {
      header: "\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }"
    };
    var area$1 = {
      header: "\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.86, 0.86, 0.86, 1);"
    };
    var boxPlot$1 = {
      header: "\n        varying float vDefined;\n    ",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };
    var errorBar$1 = {
      header: "varying float vDefined;",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };
    var bar$1 = {
      header: "varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float canStroke = 0.0;\n\n        gl_FragColor = vec4(0.60, 0.60, 0.60, 1.0);\n\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };
    var fillColor$1 = {
      header: "varying vec4 vFillColor;",
      body: "gl_FragColor = (canFill * vFillColor) + ((1.0 - canFill) * gl_FragColor);"
    };
    var strokeColor$1 = {
      header: "varying vec4 vStrokeColor;",
      body: "gl_FragColor = (canStroke * vStrokeColor) + ((1.0 - canStroke) * gl_FragColor);"
    };
    var line = {
      header: "varying float vDefined;",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };

    var areaShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(area.header).appendBody(area.body);
      fragmentShader.appendHeader(area$1.header).appendBody(area$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var types = {
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      FLOAT: 5126
    };
    function length(type) {
      switch (type) {
        case types.BYTE:
        case types.UNSIGNED_BYTE:
          return 1;

        case types.SHORT:
        case types.UNSIGNED_SHORT:
          return 2;

        case types.FLOAT:
          return 4;

        default:
          throw new Error("Unknown type ".concat(type));
      }
    }
    function getArrayViewConstructor(type) {
      switch (type) {
        case types.BYTE:
          return Int8Array;

        case types.UNSIGNED_BYTE:
          return Uint8Array;

        case types.SHORT:
          return Int16Array;

        case types.UNSIGNED_SHORT:
          return Uint16Array;

        case types.FLOAT:
          return Float32Array;

        default:
          throw new Error("Unknown type ".concat(type));
      }
    }

    var baseAttributeBuilder = (function () {
      var location = -1;
      var buffer = null;
      var size = 1; // per vertex

      var type = types.FLOAT;
      var normalized = false;
      var stride = 0;
      var offset = 0;
      var divisor = null;

      var baseAttribute = function baseAttribute(programBuilder) {
        var gl = programBuilder.context();

        if (buffer == null) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        gl.enableVertexAttribArray(location);
        var extInstancedArrays = programBuilder.extInstancedArrays();
        extInstancedArrays.vertexAttribDivisorANGLE(location, divisor != null ? divisor : programBuilder.subInstanceCount() > 0 ? 1 : 0);
      };

      baseAttribute.location = function () {
        if (!arguments.length) {
          return location;
        }

        location = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.buffer = function () {
        if (!arguments.length) {
          return buffer;
        }

        buffer = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.normalized = function () {
        if (!arguments.length) {
          return normalized;
        }

        normalized = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.stride = function () {
        if (!arguments.length) {
          return stride;
        }

        stride = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.offset = function () {
        if (!arguments.length) {
          return offset;
        }

        offset = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.divisor = function () {
        if (!arguments.length) {
          return divisor;
        }

        divisor = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      return baseAttribute;
    });

    var defaultArrayViewFactory = (function () {
      var type = types.FLOAT;
      var cachedArray = new Float32Array(0);

      var factory = function factory(requiredLength) {
        var ArrayType = getArrayViewConstructor(type);

        if (cachedArray.length > requiredLength) {
          cachedArray = new ArrayType(cachedArray.buffer, 0, requiredLength);
        } else if (cachedArray.length !== requiredLength) {
          cachedArray = new ArrayType(requiredLength);
        }

        return cachedArray;
      };

      factory.type = function () {
        if (!arguments.length) {
          return type;
        }

        if (type !== (arguments.length <= 0 ? undefined : arguments[0])) {
          type = arguments.length <= 0 ? undefined : arguments[0];
          var ArrayType = getArrayViewConstructor(type);
          cachedArray = new ArrayType(0);
        }

        return factory;
      };

      return factory;
    });

    var attributeProjector = (function () {
      var dirty = true;
      var size = 1; // per vertex

      var type = types.FLOAT;
      var arrayViewFactory = defaultArrayViewFactory();

      var value = function value(d, i) {
        return d;
      };

      var data = null;

      var projector = function projector() {
        var length = data.length;
        var projectedData = arrayViewFactory.type(type)(length * size);

        if (size > 1) {
          for (var i = 0; i < length; i++) {
            var componentValues = value(data[i], i);

            if (componentValues.length !== size) {
              throw new Error("Expected components array of size ".concat(size, ", recieved array with length ").concat(componentValues.length, "."));
            }

            for (var component = 0; component < size; component++) {
              projectedData[i * size + component] = componentValues[component];
            }
          }
        } else {
          for (var _i = 0; _i < length; _i++) {
            var componentValue = value(data[_i], _i);

            if (Array.isArray(componentValue)) {
              throw new Error("Expected a single component value, recieved array with length ".concat(componentValue.length, "."));
            }

            projectedData[_i] = componentValue;
          }
        }

        dirty = false;
        return projectedData;
      };

      projector.dirty = function () {
        return dirty;
      };

      projector.clear = function () {
        dirty = true;
      };

      projector.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.arrayViewFactory = function () {
        if (!arguments.length) {
          return arrayViewFactory;
        }

        arrayViewFactory = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.data = function () {
        if (!arguments.length) {
          return data;
        }

        data = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      return projector;
    });

    var attribute = (function () {
      var base = baseAttributeBuilder();
      var projector = attributeProjector();

      var attribute = function attribute(programBuilder) {
        base.size(attribute.size()).type(attribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        var projectedData = projector();
        var gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, projectedData, gl.DYNAMIC_DRAW);
      };

      attribute.clear = function () {
        base.buffer(null);
        projector.clear();
      };

      d3fcRebind.rebind(attribute, base, 'normalized', 'location', 'divisor');
      d3fcRebind.rebind(attribute, projector, 'data', 'value', 'size', 'type');
      return attribute;
    });

    var rebindCurry = (function (target, targetName, source, sourceName) {
      for (var _len = arguments.length, curriedArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        curriedArgs[_key - 4] = arguments[_key];
      }

      target[targetName] = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var result = source[sourceName].apply(source, curriedArgs.concat(args));

        if (result === source) {
          return target;
        }

        return result;
      };
    });

    var area$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(6);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var cornerAttribute = attribute().divisor(0).size(3).type(types.UNSIGNED_BYTE).data([[0, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 0]]);
      program.buffers().attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = areaShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        decorate(program);
        program(numElements - 1);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'crossNextValueAttribute', program.buffers(), 'attribute', 'aCrossNextValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'mainNextValueAttribute', program.buffers(), 'attribute', 'aMainNextValue');
      rebindCurry(draw, 'baseValueAttribute', program.buffers(), 'attribute', 'aBaseValue');
      rebindCurry(draw, 'baseNextValueAttribute', program.buffers(), 'attribute', 'aBaseNextValue');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      rebindCurry(draw, 'definedNextAttribute', program.buffers(), 'attribute', 'aDefinedNext');
      return draw;
    });

    var circlePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(circle.header).appendBody(circle.body);
      fragmentShader.appendHeader(circle$1.header).appendBody(circle$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var point = (function () {
      var program = programBuilder().mode(drawModes.POINTS);
      var xScale = baseScale();
      var yScale = baseScale();
      var type = circlePointShader();

      var decorate = function decorate() {};

      var draw = function draw(numElements) {
        program.vertexShader(type.vertex()).fragmentShader(type.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        decorate(program);
        program(numElements);
      };

      draw.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'sizeAttribute', program.buffers(), 'attribute', 'aSize');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var lineShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(preScaleLine.header).appendBody(preScaleLine.body);
      fragmentShader.appendHeader(line.header).appendBody(line.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var lineWidthShader = (function () {
      var width = 1;

      var lineWidth = function lineWidth(program) {
        program.buffers().uniform('uStrokeWidth', uniform(width));
      };

      lineWidth.lineWidth = function () {
        if (!arguments.length) {
          return width;
        }

        width = arguments.length <= 0 ? undefined : arguments[0];
        return lineWidth;
      };

      return lineWidth;
    });

    var elementIndices = (function (initialData) {
      var buffer = null;
      var data = initialData;
      var dirty = true;

      var base = function base(programBuilder) {
        var gl = programBuilder.context();

        if (buffer == null) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);

        if (!dirty) {
          return;
        }

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW);
        dirty = false;
      };

      base.clear = function () {
        buffer = null;
        dirty = true;
      };

      base.data = function () {
        if (!arguments.length) {
          return data;
        }

        dirty = true;
        data = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var line$1 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(12);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var lineWidth = lineWidthShader();
      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([[-1, 0, 0], [1, 1, 0], [1, -1, 1], [-1, 0, 1], [1, 1, 1]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 1, 2, 3, 0, 2, 3, 2, 3, 4])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = lineShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'prev', 0);
        yScale(program, 'prev', 1);
        xScale(program, 'curr', 0);
        yScale(program, 'curr', 1);
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        xScale(program, 'nextNext', 0);
        yScale(program, 'nextNext', 1);
        program.vertexShader().appendBody(postScaleLine.body);
        lineWidth(program);
        decorate(program);
        program(numElements - 1);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossPreviousValueAttribute', program.buffers(), 'attribute', 'aCrossPrevValue');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'crossNextValueAttribute', program.buffers(), 'attribute', 'aCrossNextValue');
      rebindCurry(draw, 'crossNextNextValueAttribute', program.buffers(), 'attribute', 'aCrossNextNextValue');
      rebindCurry(draw, 'mainPreviousValueAttribute', program.buffers(), 'attribute', 'aMainPrevValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'mainNextValueAttribute', program.buffers(), 'attribute', 'aMainNextValue');
      rebindCurry(draw, 'mainNextNextValueAttribute', program.buffers(), 'attribute', 'aMainNextNextValue');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      rebindCurry(draw, 'definedNextAttribute', program.buffers(), 'attribute', 'aDefinedNext');
      return draw;
    });

    var ohlcShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(ohlc.header).appendBody(ohlc.body);
      fragmentShader.appendHeader(ohlc$1.header).appendBody(ohlc$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var ohlc$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(18);
      var xScale = baseScale();
      var yScale = baseScale();
      var lineWidth = lineWidthShader();

      var decorate = function decorate() {};
      /*
       * x-y coordinate to locate the "corners" of the element.
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: OPEN, 1: CLOSE, 2: LOW
       * Z - Follows convention for X/Y (appropriate direction will be selected by the shader): -1: LEFT/TOP, 1: RIGHT/BOTTOM
       */


      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([// Main stem
      [0, -2, -1], [0, -2, 1], [0, 2, 1], [0, 2, -1], // Open bar
      [-1, -1, -1], [-1, -1, 1], [0, -1, 1], [0, -1, -1], // Close bar
      [1, 1, 1], [0, 1, 1], [0, 1, -1], [1, 1, -1]]);
      program.buffers().elementIndices(elementIndices([// Main stem
      0, 1, 2, 0, 3, 2, // Open bar
      4, 5, 6, 4, 7, 6, // Close bar
      8, 9, 10, 10, 11, 8])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = ohlcShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x * 2.0;\n          gl_Position.y += yModifier / uScreen.y * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'openValueAttribute', program.buffers(), 'attribute', 'aOpenValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'closeValueAttribute', program.buffers(), 'attribute', 'aCloseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var barShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(bar.header).appendBody(bar.body);
      fragmentShader.appendHeader(bar$1.header).appendBody(bar$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    //     .-------------.------------.
    // (x-w/2, y1)    (x, y1)   (x+w/2, y1)
    //     |     \                    |
    //     |        \                 |
    //     |           \              |
    //     |              \           |
    //     |                 \        |
    //     |                    \     |
    //     |                       \  |
    //     L                        R
    //     .-------------.------------.
    // (x-w/2, y0)     (x, y0)   (x+w/2, y0)
    // Drawing order
    // Triangle L, L, R. (bottom)
    //  -> L.
    //  -> L.
    //  -> R.
    // Triangle L, R, R. (top)
    //  -> L.
    //  -> R.
    //  -> R.

    var bar$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(6);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var cornerAttribute = attribute().divisor(0).size(2).type(types.BYTE).data([[-1, -1], [1, 1], [-1, 1], [1, -1]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 0, 1, 3])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = barShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        program.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'baseValueAttribute', program.buffers(), 'attribute', 'aBaseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var errorBarShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(errorBar.header).appendBody(errorBar.body);
      fragmentShader.appendHeader(errorBar$1.header).appendBody(errorBar$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var errorBar$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(18);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var lineWidth = lineWidthShader();
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -1: HIGH, 1: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       */

      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([// Main stem
      [0, 1, 1], [0, 1, -1], [0, -1, -1], [0, -1, 1], // Top cap
      [1, -1, 1], [1, -1, -1], [-1, -1, -1], [-1, -1, 1], // Bottom cap
      [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]]);
      program.buffers().elementIndices(elementIndices([// Main stem
      0, 1, 2, 0, 3, 2, // Top cap
      4, 5, 6, 4, 7, 6, // Bottom cap
      8, 9, 10, 8, 11, 10])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = errorBarShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n                gl_Position.x += xModifier / uScreen.x * 2.0;\n                gl_Position.y += yModifier / uScreen.y * 2.0;\n            ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var candlestickShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(candlestick.header).appendBody(candlestick.body);
      fragmentShader.appendHeader(candlestick$1.header).appendBody(candlestick$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var candlestick$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(12);
      var xScale = baseScale();
      var yScale = baseScale();
      var lineWidth = lineWidthShader();

      var decorate = function decorate() {};
      /*
       * x-y coordinate to locate the "corners" of the element.
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: OPEN, 1: CLOSE, 2: LOW
       * Z: -1: LEFT, 1: RIGHT (only valid for HIGH/LOW corners)
       */


      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([// Vertical line
      [0, 2, 1], [0, 2, -1], [0, -2, -1], [0, -2, 1], // Central box
      [1, -1, 0], [-1, -1, 0], [-1, 1, 0], [1, 1, 0]]);
      program.buffers().elementIndices(elementIndices([// Vertical line
      0, 1, 2, 0, 3, 2, // Central box
      4, 5, 6, 4, 7, 6])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = candlestickShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x * 2.0;\n          gl_Position.y += yModifier / uScreen.y * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'openValueAttribute', program.buffers(), 'attribute', 'aOpenValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'closeValueAttribute', program.buffers(), 'attribute', 'aCloseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var boxPlotShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(boxPlot.header).appendBody(boxPlot.body);
      fragmentShader.appendHeader(boxPlot$1.header).appendBody(boxPlot$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    //            .------.------.
    //                   |
    //                   |
    //                   |
    //    L2                       R2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //     L2                       R2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //    L2                       R2
    //     .-------------.------------.
    //                   |
    //                   |
    //                   |
    //           L1          R1
    //            .------.------.
    // Line drawing order
    // L1 -> R1
    //  -> 
    // L2 -> R2
    // L2 -> R2
    // L2 -> R2
    // L2 -> L2
    // R2 -> R2
    //  -> 
    // L1 -> R1

    var boxPlot$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(54);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var lineWidth = lineWidthShader();
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: UPPER QUARTILE, 0: MEDIAN, 1: LOWER QUARTILE, 2: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       * W: Indicator to determine line orientation (needed because some corners are part of two lines). - 0: VERTICAL, 1: HORIZONTAL
       */

      var cornerAttribute = attribute().divisor(0).size(4).type(types.BYTE).data([// Top cap line
      [-1, -2, -1, 1], [1, -2, -1, 1], [1, -2, 1, 1], [-1, -2, 1, 1], // Top whisker line
      [0, -2, -1, 0], [0, -2, 1, 0], [0, -1, 1, 0], [0, -1, -1, 0], // Upper quartile line
      [-1, -1, -1, 1], [1, -1, -1, 1], [1, -1, 1, 1], [-1, -1, 1, 1], // Median line
      [-1, 0, -1, 1], [1, 0, -1, 1], [1, 0, 1, 1], [-1, 0, 1, 1], // Lower quartile line
      [-1, 1, -1, 1], [1, 1, -1, 1], [1, 1, 1, 1], [-1, 1, 1, 1], // Left box vertical line
      [-1, -1, -1, 0], [-1, -1, 1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], // Right box vertical line
      [1, -1, -1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [1, 1, -1, 0], // Bottom whisker line
      [0, 2, -1, 0], [0, 2, 1, 0], [0, 1, 1, 0], [0, 1, -1, 0], // Bottom cap line
      [-1, 2, -1, 1], [1, 2, -1, 1], [1, 2, 1, 1], [-1, 2, 1, 1]]);
      program.buffers().elementIndices(elementIndices([// Top cap line
      0, 1, 2, 0, 2, 3, // Top whisker line
      4, 5, 6, 4, 6, 7, // Upper quartile line
      8, 9, 10, 8, 10, 11, // Median line
      12, 13, 14, 12, 14, 15, // Lower quartile line
      16, 17, 18, 16, 18, 19, // Left box vertical line
      20, 21, 22, 20, 22, 23, // Right box vertical line
      24, 25, 26, 24, 26, 27, // Bottom whisker line
      28, 29, 30, 28, 30, 31, // Bottom cap line
      32, 33, 34, 32, 34, 35])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = boxPlotShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n            gl_Position.y += yModifier / uScreen.y * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'upperQuartileValueAttribute', program.buffers(), 'attribute', 'aUpperQuartileValue');
      rebindCurry(draw, 'medianValueAttribute', program.buffers(), 'attribute', 'aMedianValue');
      rebindCurry(draw, 'lowerQuartileValueAttribute', program.buffers(), 'attribute', 'aLowerQuartileValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'capAttribute', program.buffers(), 'attribute', 'aCapWidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var adjacentAttribute = (function () {
      var minOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var maxOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (minOffset > 0 || maxOffset < 0) {
        throw new Error("Offset values (".concat(minOffset, " & ").concat(maxOffset, ") must straddle 0 "));
      }

      var base = baseAttributeBuilder();
      var projector = attributeProjector();

      var adjacentAttribute = function adjacentAttribute(programBuilder) {
        var elementSize = adjacentAttribute.size() * length(adjacentAttribute.type());
        var bufferOffset = Math.abs(minOffset) * elementSize;
        base.offset(bufferOffset).size(adjacentAttribute.size()).type(adjacentAttribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        var projectedData = projector();
        var bufferPadding = maxOffset * elementSize;
        var bufferLength = bufferOffset + projectedData.length * length(adjacentAttribute.type()) + bufferPadding;
        var gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, bufferLength, gl.DYNAMIC_DRAW);
        gl.bufferSubData(gl.ARRAY_BUFFER, bufferOffset, projectedData);
      };

      adjacentAttribute.offset = function (offset) {
        if (minOffset > offset || offset > maxOffset) {
          throw new Error("Requested offset ".concat(offset, " exceeds bounds (").concat(minOffset, " & ").concat(maxOffset, ") "));
        }

        var offsetAttribute = function offsetAttribute(programBuilder) {
          base.offset((offset - minOffset) * adjacentAttribute.size() * length(adjacentAttribute.type()));
          base(programBuilder);
        };

        d3fcRebind.rebind(offsetAttribute, adjacentAttribute, 'clear', 'location');
        return offsetAttribute;
      };

      adjacentAttribute.clear = function () {
        base.buffer(null);
        projector.clear();
      };

      d3fcRebind.rebind(adjacentAttribute, base, 'normalized', 'location', 'divisor');
      d3fcRebind.rebind(adjacentAttribute, projector, 'data', 'value', 'size', 'type');
      return adjacentAttribute;
    });

    var linear = (function () {
      var base = baseScale();

      var prefix = function prefix(component) {
        return "linear".concat(component);
      };

      var scale = function scale(programBuilder, identifier, component) {
        programBuilder.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Scale;")).appendBody("".concat(identifier, " = ").concat(identifier, " + ").concat(prefix(component), "Offset;")).appendBody("".concat(identifier, " = ").concat(identifier, " * ").concat(prefix(component), "Scale;"));
        var domainSize = base.domain()[1] - base.domain()[0];
        var rangeSize = base.range()[1] - base.range()[0];
        var translate = base.range()[0] * (domainSize / rangeSize) - base.domain()[0];
        var scaleFactor = rangeSize / domainSize;
        var offset = [0, 0, 0, 0];
        var scale = [1, 1, 1, 1];
        offset[component] = translate;
        scale[component] = scaleFactor;
        programBuilder.buffers().uniform("".concat(prefix(component), "Offset"), uniform(offset)).uniform("".concat(prefix(component), "Scale"), uniform(scale));
      };

      d3fcRebind.rebindAll(scale, base);
      return scale;
    });

    var log = (function () {
      var glBase = baseScale();
      var base = 10;

      function log(v, base) {
        return Math.log10(v) / Math.log10(base);
      }

      var prefix = function prefix(component) {
        return "log".concat(component);
      };

      var scale = function scale(programBuilder, identifier, component) {
        var logPart = "".concat(prefix(component), "Offset + (").concat(prefix(component), "Scale * clamp(log(").concat(identifier, ") / log(").concat(prefix(component), "Base), -inf, inf))");
        programBuilder.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Include;")).appendHeaderIfNotExists("uniform float ".concat(prefix(component), "Base;")).appendBody("".concat(identifier, " = (").concat(prefix(component), "Include * (").concat(logPart, ")) + ((1.0 - ").concat(prefix(component), "Include) * ").concat(identifier, ");"));
        var domainSize = log(glBase.domain()[1], base) - log(glBase.domain()[0], base);
        var rangeSize = glBase.range()[1] - glBase.range()[0];
        var scaleFactor = rangeSize / domainSize;
        var translate = glBase.range()[0] - scaleFactor * log(glBase.domain()[0], base);
        var offset = [0, 0, 0, 0];
        var scale = [0, 0, 0, 0];
        var include = [0, 0, 0, 0];
        offset[component] = translate;
        scale[component] = scaleFactor;
        include[component] = 1;
        programBuilder.buffers().uniform("".concat(prefix(component), "Offset"), uniform(offset)).uniform("".concat(prefix(component), "Scale"), uniform(scale)).uniform("".concat(prefix(component), "Include"), uniform(include)).uniform("".concat(prefix(component), "Base"), uniform(base));
      };

      scale.base = function () {
        if (!arguments.length) {
          return base;
        }

        base = arguments.length <= 0 ? undefined : arguments[0];
        return scale;
      };

      d3fcRebind.rebindAll(scale, glBase);
      return scale;
    });

    var pow = (function () {
      var base = baseScale();
      var exponent = 1;

      function pow(b, e) {
        return Math.sign(b) * Math.pow(Math.abs(b), e);
      }

      var prefix = function prefix(component) {
        return "pow".concat(component);
      };

      var scale = function scale(programBuilder, identifier, component) {
        var powPart = "".concat(prefix(component), "Offset + (").concat(prefix(component), "Scale * sign(").concat(identifier, ") * pow(abs(").concat(identifier, "), vec4(").concat(prefix(component), "Exp)))");
        programBuilder.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Include;")).appendHeaderIfNotExists("uniform float ".concat(prefix(component), "Exp;")).appendBody("".concat(identifier, " = (").concat(prefix(component), "Include * (").concat(powPart, ")) + ((1.0 - ").concat(prefix(component), "Include) * ").concat(identifier, ");"));
        var domainSize = pow(base.domain()[1], exponent) - pow(base.domain()[0], exponent);
        var rangeSize = base.range()[1] - base.range()[0];
        var scaleFactor = rangeSize / domainSize;
        var translate = base.range()[0] - scaleFactor * pow(base.domain()[0], exponent);
        var offset = [0, 0, 0, 0];
        var scale = [0, 0, 0, 0];
        var include = [0, 0, 0, 0];
        offset[component] = translate;
        scale[component] = scaleFactor;
        include[component] = 1;
        programBuilder.buffers().uniform("".concat(prefix(component), "Offset"), uniform(offset)).uniform("".concat(prefix(component), "Scale"), uniform(scale)).uniform("".concat(prefix(component), "Include"), uniform(include)).uniform("".concat(prefix(component), "Exp"), uniform(exponent));
      };

      scale.exponent = function () {
        if (!arguments.length) {
          return exponent;
        }

        exponent = arguments.length <= 0 ? undefined : arguments[0];
        return scale;
      };

      d3fcRebind.rebindAll(scale, base);
      return scale;
    });

    // determine the scale type.

    var scaleLinearCopy = d3Scale.scaleLinear().copy.toString();
    var scaleLogCopy = d3Scale.scaleLog().copy.toString();
    var scalePowCopy = d3Scale.scalePow().copy.toString();
    var scaleTimeCopy = d3Scale.scaleTime().copy.toString(); // always return the same reference to hint to consumers that
    // it is a pure function

    var identity = d3Scale.scaleIdentity(); // offset date values to make the most of the float32 precision

    var epoch = Date.now();

    var reepoch = function reepoch(d) {
      return d - epoch;
    };

    var scaleMapper = (function (scale) {
      switch (scale.copy.toString()) {
        case scaleLinearCopy:
          {
            return {
              scale: identity,
              webglScale: linear().domain(scale.domain())
            };
          }

        case scaleTimeCopy:
          {
            return {
              scale: reepoch,
              webglScale: linear().domain(scale.domain().map(reepoch))
            };
          }

        case scaleLogCopy:
          {
            return {
              scale: identity,
              webglScale: log().domain(scale.domain()).base(scale.base())
            };
          }

        case scalePowCopy:
          {
            return {
              scale: identity,
              webglScale: pow().domain(scale.domain()).exponent(scale.exponent())
            };
          }

        default:
          {
            // always return a copy of the scale to hint to consumers
            // that it may be an impure function
            return {
              scale: scale.copy(),
              webglScale: linear().domain(scale.range())
            };
          }
      }
    });

    var squarePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(square.header).appendBody(square.body);
      fragmentShader.appendHeader(square$1.header).appendBody(square$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var trianglePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(triangle.header).appendBody(triangle.body);
      fragmentShader.appendHeader(triangle$1.header).appendBody(triangle$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var crossPointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(cross.header).appendBody(cross.body);
      fragmentShader.appendHeader(cross$1.header).appendBody(cross$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var diamondPointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(diamond.header).appendBody(diamond.body);
      fragmentShader.appendHeader(diamond$1.header).appendBody(diamond$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var starPointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(star.header).appendBody(star.body);
      fragmentShader.appendHeader(star$1.header).appendBody(star$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var wyePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(wye.header).appendBody(wye.body);
      fragmentShader.appendHeader(wye$1.header).appendBody(wye$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var symbolMapper = (function (symbol) {
      switch (symbol) {
        case d3Shape.symbolCircle:
          return circlePointShader();

        case d3Shape.symbolSquare:
          return squarePointShader();

        case d3Shape.symbolTriangle:
          return trianglePointShader();

        case d3Shape.symbolCross:
          return crossPointShader();

        case d3Shape.symbolDiamond:
          return diamondPointShader();

        case d3Shape.symbolStar:
          return starPointShader();

        case d3Shape.symbolWye:
          return wyePointShader();

        default:
          throw new Error("Unrecognised symbol: ".concat(symbol));
      }
    });

    var constantAttribute = (function (initialValue) {
      var base = baseAttributeBuilder().divisor(1);
      var value = initialValue;
      var dirty = true;

      var constantAttribute = function constantAttribute(programBuilder) {
        base(programBuilder);

        if (!dirty) {
          return;
        }

        if (!Array.isArray(value)) {
          throw new Error("Expected an array, received: ".concat(value));
        }

        if (value.length !== base.size()) {
          throw new Error("Expected array of length: ".concat(base.size(), ", recieved array of length: ").concat(value.length));
        }

        var gl = programBuilder.context();
        gl["vertexAttrib".concat(value.length, "fv")](base.location(), value);
        gl.disableVertexAttribArray(base.location());
        dirty = false;
      };

      constantAttribute.clear = function () {
        dirty = true;
      };

      constantAttribute.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return constantAttribute;
      };

      d3fcRebind.rebind(constantAttribute, base, 'normalized', 'size', 'location');
      return constantAttribute;
    });

    var fillColor$2 = (function () {
      var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var projectedAttribute = attribute().size(4);
      var value = initialValue;
      var dirty = true;

      var fillColor$2 = function fillColor$2(programBuilder) {
        programBuilder.vertexShader().appendHeaderIfNotExists(fillColor.header).appendBodyIfNotExists(fillColor.body);
        programBuilder.fragmentShader().appendHeaderIfNotExists(fillColor$1.header).appendBodyIfNotExists(fillColor$1.body);

        if (Array.isArray(value)) {
          programBuilder.buffers().attribute('aFillColor', constantAttribute(value).size(4));
        } else if (typeof value === 'function') {
          if (!dirty) {
            return;
          } // The following line is expensive and is the one we want to skip,
          // the rest aren't.


          projectedAttribute.value(value);
          programBuilder.buffers().attribute('aFillColor', projectedAttribute);
        } else {
          throw new Error("Expected value to be an array or function, received ".concat(value));
        }

        dirty = false;
      };

      fillColor$2.value = function () {
        if (!arguments.length) {
          return value;
        }

        if (value !== (arguments.length <= 0 ? undefined : arguments[0])) {
          value = arguments.length <= 0 ? undefined : arguments[0];
          dirty = true;
        }

        return fillColor$2;
      };

      d3fcRebind.rebind(fillColor$2, projectedAttribute, 'data');
      return fillColor$2;
    });

    var strokeColor$2 = (function () {
      var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var projectedAttribute = attribute().size(4);
      var value = initialValue;
      var dirty = true;

      var strokeColor$2 = function strokeColor$2(programBuilder) {
        programBuilder.vertexShader().appendHeaderIfNotExists(strokeColor.header).appendBodyIfNotExists(strokeColor.body);
        programBuilder.fragmentShader().appendHeaderIfNotExists(strokeColor$1.header).appendBodyIfNotExists(strokeColor$1.body);

        if (Array.isArray(value)) {
          programBuilder.buffers().attribute('aStrokeColor', constantAttribute(value).size(4));
        } else if (typeof value === 'function') {
          if (!dirty) {
            return;
          } // The following line is expensive and is the one we want to skip,
          // the rest aren't.


          projectedAttribute.value(value);
          programBuilder.buffers().attribute('aStrokeColor', projectedAttribute);
        } else {
          throw new Error("Expected value to be an array or function, received ".concat(value));
        }

        dirty = false;
      };

      strokeColor$2.value = function () {
        if (!arguments.length) {
          return value;
        }

        if (value !== (arguments.length <= 0 ? undefined : arguments[0])) {
          value = arguments.length <= 0 ? undefined : arguments[0];
          dirty = true;
        }

        return strokeColor$2;
      };

      d3fcRebind.rebind(strokeColor$2, projectedAttribute, 'data');
      return strokeColor$2;
    });

    exports.webglAdjacentAttribute = adjacentAttribute;
    exports.webglAttribute = attribute;
    exports.webglBaseAttribute = baseAttributeBuilder;
    exports.webglBufferBuilder = bufferBuilder;
    exports.webglElementIndices = elementIndices;
    exports.webglFillColor = fillColor$2;
    exports.webglProgramBuilder = programBuilder;
    exports.webglScaleLinear = linear;
    exports.webglScaleLog = log;
    exports.webglScaleMapper = scaleMapper;
    exports.webglScalePow = pow;
    exports.webglSeriesArea = area$2;
    exports.webglSeriesBar = bar$2;
    exports.webglSeriesBoxPlot = boxPlot$2;
    exports.webglSeriesCandlestick = candlestick$2;
    exports.webglSeriesErrorBar = errorBar$2;
    exports.webglSeriesLine = line$1;
    exports.webglSeriesOhlc = ohlc$2;
    exports.webglSeriesPoint = point;
    exports.webglShaderBuilder = shaderBuilder;
    exports.webglStrokeColor = strokeColor$2;
    exports.webglSymbolMapper = symbolMapper;
    exports.webglTypes = types;
    exports.webglUniform = uniform;

    Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLW5vZGVfbW9kdWxlc19kM2ZjX2QzZmMtd2ViZ2xfYnVpbGRfZDNmYy13ZWJnbF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsSUFBSSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBbUIsR0FBRyxtQkFBTyxDQUFDLHNEQUFVLEdBQUcsbUJBQU8sQ0FBQyxzREFBVTtBQUN6SixJQUFJLENBQ2dHO0FBQ3BHLENBQUMsMERBQTBEOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBLHdDQUF3Qyx3QkFBd0IsbUNBQW1DLDBCQUEwQjtBQUM3SDtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQyw4Q0FBOEMsMEJBQTBCO0FBQ25KOztBQUVBO0FBQ0EseUNBQXlDLHVDQUF1QztBQUNoRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyx5Q0FBeUM7QUFDcEYseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhDQUE4QyxvREFBb0QsNERBQTREO0FBQ3pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhDQUE4QyxvREFBb0QsNERBQTREO0FBQ3pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhDQUE4QyxvREFBb0QsNERBQTREO0FBQ3pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhCQUE4QixvREFBb0QsNERBQTREO0FBQ3pMO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhCQUE4Qiw0REFBNEQsNERBQTREO0FBQ2pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDJEQUEyRCxvREFBb0QsNERBQTREO0FBQ3ROO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQywwQ0FBMEMsaUNBQWlDO0FBQy9TLDJDQUEyQywwQ0FBMEMsMEVBQTBFLG9EQUFvRCw0REFBNEQ7QUFDL1E7QUFDQTtBQUNBLHFEQUFxRCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxzQ0FBc0Msb0NBQW9DLGlDQUFpQyxtQ0FBbUMsaUNBQWlDLHFDQUFxQywwQ0FBMEMsaUNBQWlDO0FBQ25jLDJDQUEyQywyREFBMkQsOERBQThELG1EQUFtRCxrREFBa0QsaURBQWlELG1QQUFtUCwrRkFBK0YsaUdBQWlHLG1FQUFtRSw2RkFBNkYscUVBQXFFLDBEQUEwRDtBQUM1Z0M7QUFDQTtBQUNBLHFEQUFxRCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxzQ0FBc0Msb0NBQW9DLGlDQUFpQyxtQ0FBbUMsaUNBQWlDLHFDQUFxQywwQ0FBMEMsaUNBQWlDO0FBQ25jLDJDQUEyQywyREFBMkQsOERBQThELG1EQUFtRCxrREFBa0QsaURBQWlELCtQQUErUCwrREFBK0QsZ0VBQWdFLG1GQUFtRiw2RkFBNkYscUVBQXFFLDBEQUEwRDtBQUN2K0I7QUFDQTtBQUNBLHFEQUFxRCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxpQ0FBaUMsbUNBQW1DLGlDQUFpQyxxQ0FBcUMsbUNBQW1DO0FBQ2pWLDJDQUEyQyxxREFBcUQsdUZBQXVGLDZEQUE2RCwwREFBMEQ7QUFDOVM7QUFDQTtBQUNBLGdEQUFnRCw4Q0FBOEMsNkNBQTZDLDBDQUEwQyx5Q0FBeUMsc0NBQXNDLHFDQUFxQywwQ0FBMEMseUNBQXlDLG1DQUFtQyx1Q0FBdUMsdUNBQXVDLCtCQUErQixtQ0FBbUM7QUFDL2lCLDBEQUEwRCxrRUFBa0UsMERBQTBELG9FQUFvRSw4RUFBOEU7QUFDeFU7QUFDQTtBQUNBLDZEQUE2RCxnREFBZ0QsK0NBQStDLDZFQUE2RSxXQUFXLDJEQUEyRCw2RUFBNkUsV0FBVyxxRUFBcUUsbUZBQW1GLDBDQUEwQyxtREFBbUQseUNBQXlDLHdEQUF3RCx3Q0FBd0MsZ0ZBQWdGLDhHQUE4RyxZQUFZLE1BQU0sOEdBQThHLFdBQVcsNkRBQTZELCtGQUErRixXQUFXLCtEQUErRCwrRkFBK0YsV0FBVyxtRkFBbUYsdUZBQXVGLDRDQUE0Qyx5REFBeUQseUNBQXlDLDREQUE0RCwwQ0FBMEMsc0ZBQXNGLDRIQUE0SCxZQUFZLE1BQU0sZ0lBQWdJLFdBQVcsK0dBQStHO0FBQzF4RTtBQUNBO0FBQ0EsZ0RBQWdELHNDQUFzQyxxQ0FBcUMscUNBQXFDLG9DQUFvQyxtQ0FBbUMsaUNBQWlDLHFDQUFxQyxtQ0FBbUM7QUFDaFYsMkNBQTJDLGdEQUFnRCx3RUFBd0UsZ0RBQWdELHVFQUF1RSwrREFBK0QsMERBQTBELG9HQUFvRyxpRUFBaUU7QUFDeGpCO0FBQ0E7QUFDQSxnREFBZ0Qsc0NBQXNDLHFDQUFxQywwQ0FBMEMseUNBQXlDLHFDQUFxQyx5Q0FBeUMsbUNBQW1DLHVDQUF1QyxtQ0FBbUMsNkNBQTZDLDJDQUEyQyxXQUFXLHlDQUF5QywyQkFBMkIsV0FBVztBQUMzakIsMERBQTBELHlDQUF5QywrR0FBK0csOERBQThELDhGQUE4RiwyRUFBMkUsK0ZBQStGLDZFQUE2RSxrR0FBa0cseUVBQXlFLDRFQUE0RSxxR0FBcUcsd0hBQXdILHdJQUF3SSxnSUFBZ0k7QUFDajBDO0FBQ0E7QUFDQSxnREFBZ0Qsc0NBQXNDLHFDQUFxQyxvQ0FBb0MscUNBQXFDLDhDQUE4Qyx1Q0FBdUMsOENBQThDLG9DQUFvQyxtQ0FBbUMsaUNBQWlDLHFDQUFxQyxtQ0FBbUM7QUFDdmYsMkNBQTJDLDhEQUE4RCxpREFBaUQsb0RBQW9ELDJDQUEyQywyREFBMkQsb0VBQW9FLGdEQUFnRCxvU0FBb1MsMERBQTBELDJDQUEyQyxnREFBZ0QsMEdBQTBHLDRGQUE0RiwwRUFBMEU7QUFDam5DOztBQUVBO0FBQ0EsNkNBQTZDLGlDQUFpQztBQUM5RSwyQ0FBMkMsNkRBQTZELDZFQUE2RSxpREFBaUQsc0JBQXNCLHFCQUFxQixXQUFXO0FBQzVSLE9BQU87O0FBRVA7QUFDQSw2Q0FBNkMsaUNBQWlDLHNFQUFzRSwrQ0FBK0MsMkNBQTJDLDhDQUE4QztBQUM1UiwyQ0FBMkMsK0NBQStDLHNCQUFzQiw2RUFBNkUsc0RBQXNELHFCQUFxQiw2REFBNkQsMENBQTBDLHFDQUFxQyw2RUFBNkUsaURBQWlELHNCQUFzQixxQkFBcUIsV0FBVztBQUN4a0I7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUUsMkNBQTJDLCtDQUErQyxzQkFBc0IseURBQXlELHdEQUF3RCxzREFBc0QsOERBQThELG9FQUFvRSx1Q0FBdUMsNkVBQTZFLGlEQUFpRCxzQkFBc0IscUJBQXFCLFdBQVc7QUFDcG5CO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQWlDO0FBQzlFLDJDQUEyQywrQkFBK0Isc0JBQXNCLFdBQVcsK0RBQStELHVGQUF1Riw2RUFBNkU7QUFDOVUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsaUNBQWlDLHdCQUF3Qix3QkFBd0I7QUFDOUgsNENBQTRDLHNCQUFzQixXQUFXLGlFQUFpRSxpREFBaUQsK0NBQStDLG9EQUFvRCxrREFBa0QscUVBQXFFLGlDQUFpQyxzQkFBc0IsV0FBVztBQUMzZDtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFpQztBQUM5RSwyQ0FBMkMsK0RBQStELDRHQUE0RyxpRUFBaUUscUVBQXFFLDZFQUE2RSxpREFBaUQsc0JBQXNCLFdBQVc7QUFDM2Y7QUFDQTtBQUNBLDZDQUE2QywwQ0FBMEMsaUNBQWlDO0FBQ3hILDJDQUEyQywrREFBK0QsNkhBQTZILGdHQUFnRyx1RUFBdUUsNkVBQTZFLGlEQUFpRCxzQkFBc0IsV0FBVztBQUM3aUI7QUFDQTtBQUNBLHVEQUF1RCxpQ0FBaUM7QUFDeEYsMkNBQTJDLGdDQUFnQywrQkFBK0Isc0JBQXNCLFdBQVcsOENBQThDLHNDQUFzQyxrREFBa0QsV0FBVztBQUM1UjtBQUNBO0FBQ0EsdURBQXVELGlDQUFpQztBQUN4RiwyQ0FBMkMsZ0NBQWdDLCtCQUErQixzQkFBc0IsV0FBVyw4Q0FBOEMsc0NBQXNDLGtEQUFrRCxXQUFXO0FBQzVSO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsMkNBQTJDLGdDQUFnQywrQkFBK0Isc0JBQXNCLFdBQVcsbURBQW1EO0FBQzlMO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsMkNBQTJDLGdDQUFnQyxpQ0FBaUMsc0JBQXNCLFdBQVc7QUFDN0k7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywyQ0FBMkMsZ0NBQWdDLCtCQUErQixzQkFBc0IsV0FBVztBQUMzSTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDJDQUEyQyxnQ0FBZ0MsdURBQXVELGlDQUFpQyxzQkFBc0IsV0FBVztBQUNwTTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDJDQUEyQyxnQ0FBZ0MsK0JBQStCLHNCQUFzQixXQUFXO0FBQzNJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkIsYUFBYTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxvR0FBb0csYUFBYTtBQUNqSDtBQUNBOztBQUVBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyx5REFBeUQ7QUFDN0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsK0RBQStEO0FBQ3pLO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLHlEQUF5RDtBQUM3SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csMkRBQTJEO0FBQ2pLO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0hBQWdILDZFQUE2RSx3R0FBd0csdUdBQXVHO0FBQzVZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnSEFBZ0gsNkVBQTZFLCtFQUErRSw2RUFBNkUsc0xBQXNMO0FBQy9nQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnSEFBZ0gsNkVBQTZFLCtFQUErRSw0RUFBNEUsc0xBQXNMO0FBQzlnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQSw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsYUFBYTs7QUFFaEUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby1vZmZzY3JlZW4tY2FudmFzLWRlbW8vLi9ub2RlX21vZHVsZXMvQGQzZmMvZDNmYy13ZWJnbC9idWlsZC9kM2ZjLXdlYmdsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAZDNmYy9kM2ZjLXJlYmluZCcpLCByZXF1aXJlKCdkMy1zY2FsZScpLCByZXF1aXJlKCdkMy1zaGFwZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAZDNmYy9kM2ZjLXJlYmluZCcsICdkMy1zY2FsZScsICdkMy1zaGFwZSddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5mYyA9IGdsb2JhbC5mYyB8fCB7fSwgZ2xvYmFsLmZjLCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNmY1JlYmluZCwgZDNTY2FsZSwgZDNTaGFwZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgYmFzZVNjYWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkb21haW4gPSBbMCwgMV07XG4gICAgICB2YXIgcmFuZ2UgPSBbLTEsIDFdO1xuXG4gICAgICB2YXIgYmFzZSA9IGZ1bmN0aW9uIGJhc2UoKSB7fTtcblxuICAgICAgYmFzZS5kb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkb21haW47XG4gICAgICAgIH1cblxuICAgICAgICBkb21haW4gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfTtcblxuICAgICAgYmFzZS5yYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSk7XG5cbiAgICB2YXIgYnVmZmVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgICB2YXIgZWxlbWVudEluZGljZXMgPSBudWxsO1xuXG4gICAgICB2YXIgYnVmZmVyQnVpbGRlciA9IGZ1bmN0aW9uIGJ1ZmZlckJ1aWxkZXIocHJvZ3JhbUJ1aWxkZXIsIHByb2dyYW0pIHtcbiAgICAgICAgdmFyIGdsID0gcHJvZ3JhbUJ1aWxkZXIuY29udGV4dCgpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYW4gYXR0cmlidXRlIGZvciBcIi5jb25jYXQobmFtZSwgXCIsIGZvdW5kIFwiKS5jb25jYXQoYXR0cmlidXRlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgYXR0cmlidXRlLmxvY2F0aW9uKGxvY2F0aW9uKShwcm9ncmFtQnVpbGRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgdW5pZm9ybSBmb3IgXCIuY29uY2F0KG5hbWUsIFwiLCBmb3VuZCBcIikuY29uY2F0KHVuaWZvcm0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgdW5pZm9ybS5sb2NhdGlvbihsb2NhdGlvbikocHJvZ3JhbUJ1aWxkZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudEluZGljZXMgIT09IG51bGwpIHtcbiAgICAgICAgICBlbGVtZW50SW5kaWNlcyhwcm9ncmFtQnVpbGRlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJ1ZmZlckJ1aWxkZXIuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5jbGVhcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh1bmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybSkge1xuICAgICAgICAgIHJldHVybiB1bmlmb3JtLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxlbWVudEluZGljZXMgIT09IG51bGwpIGVsZW1lbnRJbmRpY2VzLmNsZWFyKCk7XG4gICAgICB9O1xuXG4gICAgICBidWZmZXJCdWlsZGVyLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2FyZ3NbMF1dO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlc1thcmdzWzBdXSA9IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBidWZmZXJCdWlsZGVyO1xuICAgICAgfTtcblxuICAgICAgYnVmZmVyQnVpbGRlci51bmlmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdW5pZm9ybXNbYXJnc1swXV07XG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtc1thcmdzWzBdXSA9IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBidWZmZXJCdWlsZGVyO1xuICAgICAgfTtcblxuICAgICAgYnVmZmVyQnVpbGRlci5lbGVtZW50SW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRJbmRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudEluZGljZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBidWZmZXJCdWlsZGVyO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1ZmZlckJ1aWxkZXI7XG4gICAgfSk7XG5cbiAgICB2YXIgdW5pZm9ybSA9IChmdW5jdGlvbiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IC0xO1xuICAgICAgdmFyIGRhdGEgPSBpbml0aWFsRGF0YTtcbiAgICAgIHZhciBkaXJ0eSA9IHRydWU7XG5cbiAgICAgIHZhciBidWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIGlmICghZGlydHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtQnVpbGRlci5jb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIGRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIGRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pZm9ybSBzdXBwb3J0cyB1cCB0byA0IGVsZW1lbnRzLiBcIi5jb25jYXQoZGF0YS5sZW5ndGgsIFwiIHByb3ZpZGVkLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLmxvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYXRpb24gIT09IChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBidWlsZDtcbiAgICB9KTtcblxuICAgIHZhciBkcmF3TW9kZXMgPSB7XG4gICAgICBQT0lOVFM6IDAsXG4gICAgICBMSU5FUzogMSxcbiAgICAgIExJTkVfTE9PUDogMixcbiAgICAgIExJTkVfU1RSSVA6IDMsXG4gICAgICBUUklBTkdMRVM6IDQsXG4gICAgICBUUklBTkdMRV9TVFJJUDogNSxcbiAgICAgIFRSSUFOR0xFX0ZBTjogNlxuICAgIH07XG5cbiAgICB2YXIgcHJvZ3JhbUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBudWxsO1xuICAgICAgdmFyIHByb2dyYW0gPSBudWxsO1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xuICAgICAgdmFyIHByb2dyYW1WZXJ0ZXhTaGFkZXIgPSBudWxsO1xuICAgICAgdmFyIHByb2dyYW1GcmFnbWVudFNoYWRlciA9IG51bGw7XG4gICAgICB2YXIgbW9kZSA9IGRyYXdNb2Rlcy5UUklBTkdMRVM7XG4gICAgICB2YXIgc3ViSW5zdGFuY2VDb3VudCA9IDA7XG4gICAgICB2YXIgYnVmZmVycyA9IGJ1ZmZlckJ1aWxkZXIoKTtcbiAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgdmFyIGV4dEluc3RhbmNlZEFycmF5cyA9IG51bGw7XG4gICAgICB2YXIgZGlydHkgPSB0cnVlO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuXG4gICAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiBidWlsZChjb3VudCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRleFNoYWRlclNvdXJjZSA9IHZlcnRleFNoYWRlcigpO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlcigpO1xuXG4gICAgICAgIGlmIChuZXdQcm9ncmFtKHByb2dyYW0sIHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpKSB7XG4gICAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgICAgcHJvZ3JhbVZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlclNvdXJjZTtcbiAgICAgICAgICBwcm9ncmFtRnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlclNvdXJjZTtcbiAgICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBidWZmZXJzLnVuaWZvcm0oJ3VTY3JlZW4nLCB1bmlmb3JtKFtjb250ZXh0LmNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8sIGNvbnRleHQuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW9dKSk7XG4gICAgICAgIGJ1ZmZlcnMoYnVpbGQsIHByb2dyYW0pO1xuXG4gICAgICAgIGlmIChzdWJJbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlcnMuZWxlbWVudEluZGljZXMoKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdBcnJheXMobW9kZSwgMCwgY291bnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgY29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChidWZmZXJzLmVsZW1lbnRJbmRpY2VzKCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0SW5zdGFuY2VkQXJyYXlzLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShtb2RlLCAwLCBzdWJJbnN0YW5jZUNvdW50LCBjb3VudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5kaWNlc0xlbmd0aCA9IGJ1ZmZlcnMuZWxlbWVudEluZGljZXMoKS5kYXRhKCkubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoc3ViSW5zdGFuY2VDb3VudCAhPT0gZWxlbWVudEluZGljZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudEluZGljZXMgbGVuZ3RoIFwiLmNvbmNhdChlbGVtZW50SW5kaWNlc0xlbmd0aCkgKyBcIiB0byBtYXRjaCBzdWJJbnN0YW5jZUNvdW50IFwiLmNvbmNhdChzdWJJbnN0YW5jZUNvdW50LCBcIi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRJbnN0YW5jZWRBcnJheXMuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUobW9kZSwgc3ViSW5zdGFuY2VDb3VudCwgY29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCwgY291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYnVpbGQuZXh0SW5zdGFuY2VkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXh0SW5zdGFuY2VkQXJyYXlzO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuY29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzWzBdID09IG51bGwgfHwgYXJnc1swXSAhPT0gY29udGV4dCkge1xuICAgICAgICAgIGJ1ZmZlcnMuZmx1c2goKTtcbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJnc1swXSAhPSBudWxsICYmIGFyZ3NbMF0gIT09IGNvbnRleHQpIHtcbiAgICAgICAgICBleHRJbnN0YW5jZWRBcnJheXMgPSBhcmdzWzBdLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dCA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLmJ1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBidWZmZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVycyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQudmVydGV4U2hhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVydGV4U2hhZGVyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYnVpbGQ7XG4gICAgICB9O1xuXG4gICAgICBidWlsZC5mcmFnbWVudFNoYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLm1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuc3ViSW5zdGFuY2VDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHN1Ykluc3RhbmNlQ291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJJbnN0YW5jZUNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYnVpbGQ7XG4gICAgICB9O1xuXG4gICAgICBidWlsZC5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLnBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1aWxkO1xuXG4gICAgICBmdW5jdGlvbiBuZXdQcm9ncmFtKHByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgaWYgKCFwcm9ncmFtIHx8IGRpcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyICE9PSBwcm9ncmFtVmVydGV4U2hhZGVyIHx8IGZyYWdtZW50U2hhZGVyICE9PSBwcm9ncmFtRnJhZ21lbnRTaGFkZXI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gbG9hZFNoYWRlcih2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGNvbnRleHQuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGxvYWRTaGFkZXIoZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGNvbnRleHQuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgY29udGV4dC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgY29udGV4dC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICBjb250ZXh0LmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAgIGlmIChkZWJ1ZyAmJiAhY29udGV4dC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGNvbnRleHQuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb250ZXh0LmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgICAgIGNvbnRleHQuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGluayBwcm9ncmFtIDogXCIuY29uY2F0KG1lc3NhZ2UsIFwiXFxuICAgICAgICAgICAgVmVydGV4IFNoYWRlciA6IFwiKS5jb25jYXQodmVydGV4U2hhZGVyU291cmNlLCBcIlxcbiAgICAgICAgICAgIEZyYWdtZW50IFNoYWRlciA6IFwiKS5jb25jYXQoZnJhZ21lbnRTaGFkZXJTb3VyY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2FkU2hhZGVyKHNvdXJjZSwgdHlwZSkge1xuICAgICAgICB2YXIgc2hhZGVyID0gY29udGV4dC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGNvbnRleHQuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICAgICAgY29udGV4dC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgaWYgKGRlYnVnICYmICFjb250ZXh0LmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGNvbnRleHQuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb250ZXh0LmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgICBjb250ZXh0LmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHNoYWRlciA6IFwiLmNvbmNhdChtZXNzYWdlLCBcIlxcbiAgICAgICAgICAgIFNoYWRlciA6IFwiKS5jb25jYXQoc291cmNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHNoYWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgIHZhciBzaGFkZXJIZWFkZXJzID0gW107XG4gICAgICB2YXIgc2hhZGVyQm9kaWVzID0gW107XG5cbiAgICAgIHZhciBidWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4gYmFzZShzaGFkZXJIZWFkZXJzLmpvaW4oJ1xcbicpLCBzaGFkZXJCb2RpZXMuam9pbignXFxuJykpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYXBwZW5kKGFycmF5LCBlbGVtZW50KSB7XG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluc2VydChhcnJheSwgZWxlbWVudCwgYmVmb3JlKSB7XG4gICAgICAgIHZhciBiZWZvcmVJbmRleCA9IGFycmF5LmluZGV4T2YoYmVmb3JlKTtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGJlZm9yZUluZGV4ID49IDAgPyBiZWZvcmVJbmRleCA6IGFycmF5Lmxlbmd0aCwgMCwgZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGVuZElmTm90RXhpc3RzKGFycmF5LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBlbGVtZW50SW5kZXggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChlbGVtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWlsZC5hcHBlbmRIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIGFwcGVuZChzaGFkZXJIZWFkZXJzLCBoZWFkZXIpO1xuICAgICAgICByZXR1cm4gYnVpbGQ7XG4gICAgICB9O1xuXG4gICAgICBidWlsZC5pbnNlcnRIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyLCBiZWZvcmUpIHtcbiAgICAgICAgaW5zZXJ0KHNoYWRlckhlYWRlcnMsIGhlYWRlciwgYmVmb3JlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIGFwcGVuZElmTm90RXhpc3RzKHNoYWRlckhlYWRlcnMsIGhlYWRlcik7XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLmFwcGVuZEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBhcHBlbmQoc2hhZGVyQm9kaWVzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuaW5zZXJ0Qm9keSA9IGZ1bmN0aW9uIChib2R5LCBiZWZvcmUpIHtcbiAgICAgICAgaW5zZXJ0KHNoYWRlckJvZGllcywgYm9keSwgYmVmb3JlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuYXBwZW5kQm9keUlmTm90RXhpc3RzID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgYXBwZW5kSWZOb3RFeGlzdHMoc2hhZGVyQm9kaWVzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgIH0pOyAvLyBpbmYgaXMgcHJlY2FsY3VsYXRlZCBoZXJlIGZvciB1c2UgaW4gc29tZSBmdW5jdGlvbnMgKGUuZy4gbG9nIHNjYWxlIGNhbGN1bGF0aW9ucylcblxuICAgIHZhciB2ZXJ0ZXhTaGFkZXJCYXNlID0gZnVuY3Rpb24gdmVydGV4U2hhZGVyQmFzZShoZWFkZXIsIGJvZHkpIHtcbiAgICAgIHJldHVybiBcIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmZsb2F0IGluZiA9IDEuMCAvIDAuMDtcXG5cIi5jb25jYXQoaGVhZGVyLCBcIlxcbnZvaWQgbWFpbigpIHtcXG4gICAgXCIpLmNvbmNhdChib2R5LCBcIlxcbn1cIik7XG4gICAgfTtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXJCYXNlID0gZnVuY3Rpb24gZnJhZ21lbnRTaGFkZXJCYXNlKGhlYWRlciwgYm9keSkge1xuICAgICAgcmV0dXJuIFwiXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXCIuY29uY2F0KGhlYWRlciwgXCJcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG4gICAgXCIpLmNvbmNhdChib2R5LCBcIlxcbn1cIik7XG4gICAgfTtcblxuICAgIHZhciBmaWxsQ29sb3IgPSB7XG4gICAgICBoZWFkZXI6IFwiYXR0cmlidXRlIHZlYzQgYUZpbGxDb2xvcjtcXG4gICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZGaWxsQ29sb3I7XCIsXG4gICAgICBib2R5OiBcInZGaWxsQ29sb3IgPSBhRmlsbENvbG9yO1wiXG4gICAgfTtcbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSB7XG4gICAgICBoZWFkZXI6IFwiYXR0cmlidXRlIHZlYzQgYVN0cm9rZUNvbG9yO1xcbiAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdlN0cm9rZUNvbG9yO1wiLFxuICAgICAgYm9keTogXCJ2U3Ryb2tlQ29sb3IgPSBhU3Ryb2tlQ29sb3I7XCJcbiAgICB9O1xuICAgIHZhciBjaXJjbGUgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhU2l6ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIHZTaXplID0gMi4wICogc3FydChhU2l6ZSAvIDMuMTQxNTkpO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gdlNpemUgKyB1U3Ryb2tlV2lkdGggKyAxLjA7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgc3RhciA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFTaXplO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcblxcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1U3Ryb2tlV2lkdGg7XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgdlNpemUgPSA0LjAgKiBzcXJ0KGFTaXplIC8gMy4xNDE1OSk7XFxuICAgICAgICBnbF9Qb2ludFNpemUgPSB2U2l6ZSArIHVTdHJva2VXaWR0aCArIDEuMDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgYU1haW5WYWx1ZSwgMCwgMSk7XCJcbiAgICB9O1xuICAgIHZhciB3eWUgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhU2l6ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIHZTaXplID0gMy4wICogc3FydChhU2l6ZSAvIDMuMTQxNTkpO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gdlNpemUgKyB1U3Ryb2tlV2lkdGggKyAxLjA7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgc3F1YXJlID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYVNpemU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVTdHJva2VXaWR0aDtcXG5cXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQ7XFxuICAgICAgICB2U2l6ZSA9IHNxcnQoYVNpemUpO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gdlNpemUgKyB1U3Ryb2tlV2lkdGggKyAxLjA7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgZGlhbW9uZCA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFTaXplO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcblxcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1U3Ryb2tlV2lkdGg7XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgdlNpemUgPSBzcXJ0KGFTaXplKTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IDIuMCAqICh2U2l6ZSArIHVTdHJva2VXaWR0aCArIDEuMCk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgdHJpYW5nbGUgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhU2l6ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIHZTaXplID0gc3FydCgoMTYuMCAqIGFTaXplKSAvICgzLjAgKiBzcXJ0KDMuMCkpKTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IHZTaXplICsgdVN0cm9rZVdpZHRoICsgMS4wO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDcm9zc1ZhbHVlLCBhTWFpblZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGNyb3NzID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYVNpemU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVTdHJva2VXaWR0aDtcXG5cXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTdHJva2VXaWR0aFJhdGlvO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgdlNpemUgPSAzLjAgKiBzcXJ0KGFTaXplIC8gNS4wKTtcXG4gICAgICAgIHZTdHJva2VXaWR0aFJhdGlvID0gdVN0cm9rZVdpZHRoIC8gKHZTaXplICsgdVN0cm9rZVdpZHRoICsgMS4wKTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IHZTaXplICsgdVN0cm9rZVdpZHRoICsgMS4wO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDcm9zc1ZhbHVlLCBhTWFpblZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGNhbmRsZXN0aWNrID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYW5kd2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUhpZ2hWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhT3BlblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDbG9zZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFMb3dWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2Q29sb3JJbmRpY2F0b3I7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQ7XFxuICAgICAgICB2Q29sb3JJbmRpY2F0b3IgPSBzaWduKGFDbG9zZVZhbHVlIC0gYU9wZW5WYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBpc1Bvc2l0aXZlWSA9IChzaWduKGFDb3JuZXIueSkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgaXNOb3RQb3NpdGl2ZVkgPSAxLjAgLSBpc1Bvc2l0aXZlWTtcXG4gICAgICAgIGZsb2F0IGlzRXh0cmVtZVkgPSBhYnMoYUNvcm5lci55KSAtIDEuMDtcXG4gICAgICAgIGZsb2F0IGlzTm90RXh0cmVtZVkgPSAxLjAgLSBpc0V4dHJlbWVZO1xcbiAgICAgICAgZmxvYXQgeVZhbHVlID1cXG4gICAgICAgICAoaXNQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUxvd1ZhbHVlKSArXFxuICAgICAgICAgKGlzUG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFDbG9zZVZhbHVlKSArXFxuICAgICAgICAgKGlzTm90UG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFPcGVuVmFsdWUpICtcXG4gICAgICAgICAoaXNOb3RQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUhpZ2hWYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBsaW5lV2lkdGhYRGlyZWN0aW9uID0gKGlzTm90RXh0cmVtZVkgKiBhQ29ybmVyLngpICsgKGlzRXh0cmVtZVkgKiBhQ29ybmVyLnopO1xcbiAgICAgICAgZmxvYXQgbGluZVdpZHRoWURpcmVjdGlvbiA9IGlzTm90RXh0cmVtZVkgKiBzaWduKGFDbG9zZVZhbHVlIC0gYU9wZW5WYWx1ZSkgKiBhQ29ybmVyLnk7XFxuXFxuICAgICAgICBmbG9hdCBiYW5kd2lkdGhNb2RpZmllciA9IGFCYW5kd2lkdGggKiBhQ29ybmVyLnggLyAyLjA7XFxuXFxuICAgICAgICBmbG9hdCB4TW9kaWZpZXIgPSAodVN0cm9rZVdpZHRoICogbGluZVdpZHRoWERpcmVjdGlvbiAvIDIuMCkgKyBiYW5kd2lkdGhNb2RpZmllcjtcXG4gICAgICAgIGZsb2F0IHlNb2RpZmllciA9IHVTdHJva2VXaWR0aCAqIGxpbmVXaWR0aFlEaXJlY3Rpb24gLyAyLjA7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIHlWYWx1ZSwgMCwgMSk7XCJcbiAgICB9O1xuICAgIHZhciBvaGxjID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYW5kd2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUhpZ2hWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhT3BlblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDbG9zZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFMb3dWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2Q29sb3JJbmRpY2F0b3I7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQ7XFxuICAgICAgICB2Q29sb3JJbmRpY2F0b3IgPSBzaWduKGFDbG9zZVZhbHVlIC0gYU9wZW5WYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBpc1Bvc2l0aXZlWSA9IChzaWduKGFDb3JuZXIueSkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgaXNOb3RQb3NpdGl2ZVkgPSAxLjAgLSBpc1Bvc2l0aXZlWTtcXG4gICAgICAgIGZsb2F0IGlzRXh0cmVtZVkgPSBhYnMoYUNvcm5lci55KSAtIDEuMDtcXG4gICAgICAgIGZsb2F0IGlzTm90RXh0cmVtZVkgPSAxLjAgLSBpc0V4dHJlbWVZO1xcbiAgICAgICAgZmxvYXQgeVZhbHVlID1cXG4gICAgICAgICAgICAoaXNQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUxvd1ZhbHVlKSArXFxuICAgICAgICAgICAgKGlzUG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFDbG9zZVZhbHVlKSArXFxuICAgICAgICAgICAgKGlzTm90UG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFPcGVuVmFsdWUpICtcXG4gICAgICAgICAgICAoaXNOb3RQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUhpZ2hWYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBsaW5lV2lkdGhYRGlyZWN0aW9uID0gaXNFeHRyZW1lWSAqIGFDb3JuZXIuejtcXG4gICAgICAgIGZsb2F0IGxpbmVXaWR0aFlEaXJlY3Rpb24gPSBpc05vdEV4dHJlbWVZICogYUNvcm5lci56O1xcblxcbiAgICAgICAgZmxvYXQgYmFuZHdpZHRoTW9kaWZpZXIgPSBpc05vdEV4dHJlbWVZICogYUNvcm5lci54ICogYUJhbmR3aWR0aCAvIDIuMDtcXG5cXG4gICAgICAgIGZsb2F0IHhNb2RpZmllciA9ICh1U3Ryb2tlV2lkdGggKiBsaW5lV2lkdGhYRGlyZWN0aW9uIC8gMi4wKSArIGJhbmR3aWR0aE1vZGlmaWVyO1xcbiAgICAgICAgZmxvYXQgeU1vZGlmaWVyID0gdVN0cm9rZVdpZHRoICogbGluZVdpZHRoWURpcmVjdGlvbiAvIDIuMDtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgeVZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGJhciA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQmFuZHdpZHRoO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUJhc2VWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgZmxvYXQgaXNCYXNlbGluZSA9ICgxLjAgLSBhQ29ybmVyLnkpIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgeVZhbHVlID0gKGlzQmFzZWxpbmUgKiBhQmFzZVZhbHVlKSArICgoMS4wIC0gaXNCYXNlbGluZSkgKiBhTWFpblZhbHVlKTtcXG5cXG4gICAgICAgIGZsb2F0IHhNb2RpZmllciA9IGFDb3JuZXIueCAqIChhQmFuZHdpZHRoKSAvIDIuMDtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgeVZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIHByZVNjYWxlTGluZSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzTmV4dE5leHRWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpbk5leHROZXh0VmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzTmV4dFZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluTmV4dFZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzUHJldlZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluUHJldlZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkTmV4dDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHVTY3JlZW47XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQgKiBhRGVmaW5lZE5leHQ7XFxuICAgICAgICB2ZWM0IHByZXYgPSB2ZWM0KGFDcm9zc1ByZXZWYWx1ZSwgYU1haW5QcmV2VmFsdWUsIDAsIDApO1xcbiAgICAgICAgdmVjNCBjdXJyID0gdmVjNChhQ3Jvc3NWYWx1ZSwgYU1haW5WYWx1ZSwgMCwgMCk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzTmV4dFZhbHVlLCBhTWFpbk5leHRWYWx1ZSwgMCwgMSk7XFxuICAgICAgICB2ZWM0IG5leHROZXh0ID0gdmVjNChhQ3Jvc3NOZXh0TmV4dFZhbHVlLCBhTWFpbk5leHROZXh0VmFsdWUsIDAsIDApO1wiXG4gICAgfTtcbiAgICB2YXIgcG9zdFNjYWxlTGluZSA9IHtcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2ZWM0IGN1cnJWZXJ0ZXhQb3NpdGlvbiA9IGdsX1Bvc2l0aW9uO1xcbiAgICAgICAgdmVjNCBuZXh0VmVydGV4UG9zaXRpb24gPSBnbF9Qb3NpdGlvbjtcXG5cXG4gICAgICAgIGlmIChhbGwoZXF1YWwoY3Vyci54eSwgcHJldi54eSkpKSB7XFxuICAgICAgICAgICAgcHJldi54eSA9IGN1cnIueHkgKyBub3JtYWxpemUoY3Vyci54eSAtIGN1cnJWZXJ0ZXhQb3NpdGlvbi54eSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYWxsKGVxdWFsKGN1cnIueHksIGN1cnJWZXJ0ZXhQb3NpdGlvbi54eSkpKSB7XFxuICAgICAgICAgICAgY3VyclZlcnRleFBvc2l0aW9uLnh5ID0gY3Vyci54eSArIG5vcm1hbGl6ZShjdXJyLnh5IC0gcHJldi54eSk7XFxuICAgICAgICB9XFxuICAgICAgICB2ZWMyIEEgPSBub3JtYWxpemUobm9ybWFsaXplKGN1cnIueHkgLSBwcmV2Lnh5KSAqIHVTY3JlZW4pO1xcbiAgICAgICAgdmVjMiBCID0gbm9ybWFsaXplKG5vcm1hbGl6ZShjdXJyVmVydGV4UG9zaXRpb24ueHkgLSBjdXJyLnh5KSAqIHVTY3JlZW4pO1xcbiAgICAgICAgdmVjMiB0YW5nZW50ID0gbm9ybWFsaXplKEEgKyBCKTtcXG4gICAgICAgIHZlYzIgbWl0ZXIgPSB2ZWMyKC10YW5nZW50LnksIHRhbmdlbnQueCk7XFxuICAgICAgICB2ZWMyIG5vcm1hbEEgPSB2ZWMyKC1BLnksIEEueCk7XFxuICAgICAgICBmbG9hdCBtaXRlckxlbmd0aCA9IDEuMCAvIGRvdChtaXRlciwgbm9ybWFsQSk7XFxuICAgICAgICB2ZWMyIHBvaW50ID0gbm9ybWFsaXplKEEgLSBCKTtcXG4gICAgICAgIGlmIChtaXRlckxlbmd0aCA+IDEwLjAgJiYgc2lnbihhQ29ybmVyLnggKiBkb3QobWl0ZXIsIHBvaW50KSkgPiAwLjApIHtcXG4gICAgICAgICAgICBjdXJyVmVydGV4UG9zaXRpb24ueHkgPSBjdXJyLnh5IC0gKGFDb3JuZXIueCAqIGFDb3JuZXIueSAqIHVTdHJva2VXaWR0aCAqIG5vcm1hbEEpIC8gdVNjcmVlbi54eTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY3VyclZlcnRleFBvc2l0aW9uLnh5ID0gY3Vyci54eSArIChhQ29ybmVyLnggKiBtaXRlciAqIHVTdHJva2VXaWR0aCAqIG1pdGVyTGVuZ3RoKSAvIHVTY3JlZW4ueHk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYWxsKGVxdWFsKG5leHRWZXJ0ZXhQb3NpdGlvbi54eSwgY3Vyci54eSkpKSB7XFxuICAgICAgICAgICAgY3Vyci54eSA9IG5leHRWZXJ0ZXhQb3NpdGlvbi54eSArIG5vcm1hbGl6ZShuZXh0VmVydGV4UG9zaXRpb24ueHkgLSBuZXh0TmV4dC54eSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYWxsKGVxdWFsKG5leHRWZXJ0ZXhQb3NpdGlvbi54eSwgbmV4dE5leHQueHkpKSkge1xcbiAgICAgICAgICAgIG5leHROZXh0Lnh5ID0gbmV4dFZlcnRleFBvc2l0aW9uLnh5ICsgbm9ybWFsaXplKG5leHRWZXJ0ZXhQb3NpdGlvbi54eSAtIGN1cnIueHkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmVjMiBDID0gbm9ybWFsaXplKG5vcm1hbGl6ZShuZXh0VmVydGV4UG9zaXRpb24ueHkgLSBjdXJyLnh5KSAqIHVTY3JlZW4pO1xcbiAgICAgICAgdmVjMiBEID0gbm9ybWFsaXplKG5vcm1hbGl6ZShuZXh0TmV4dC54eSAtIG5leHRWZXJ0ZXhQb3NpdGlvbi54eSkgKiB1U2NyZWVuKTtcXG4gICAgICAgIHZlYzIgdGFuZ2VudENEID0gbm9ybWFsaXplKEMgKyBEKTtcXG4gICAgICAgIHZlYzIgbWl0ZXJDRCA9IHZlYzIoLXRhbmdlbnRDRC55LCB0YW5nZW50Q0QueCk7XFxuICAgICAgICB2ZWMyIG5vcm1hbEMgPSB2ZWMyKC1DLnksIEMueCk7XFxuICAgICAgICBmbG9hdCBtaXRlckNETGVuZ3RoID0gMS4wIC8gZG90KG1pdGVyQ0QsIG5vcm1hbEMpO1xcbiAgICAgICAgdmVjMiBwb2ludENEID0gbm9ybWFsaXplKEMgLSBEKTtcXG4gICAgICAgIGlmIChtaXRlckNETGVuZ3RoID4gMTAuMCAmJiBzaWduKGFDb3JuZXIueCAqIGRvdChtaXRlckNELCBwb2ludENEKSkgPiAwLjApIHtcXG4gICAgICAgICAgICBuZXh0VmVydGV4UG9zaXRpb24ueHkgPSBuZXh0VmVydGV4UG9zaXRpb24ueHkgLSAoYUNvcm5lci54ICogYUNvcm5lci55ICogdVN0cm9rZVdpZHRoICogbm9ybWFsQykgLyB1U2NyZWVuLnh5O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBuZXh0VmVydGV4UG9zaXRpb24ueHkgPSBuZXh0VmVydGV4UG9zaXRpb24ueHkgKyAoYUNvcm5lci54ICogbWl0ZXJDRCAqIHVTdHJva2VXaWR0aCAqIG1pdGVyQ0RMZW5ndGgpIC8gdVNjcmVlbi54eTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uLnh5ID0gKCgxLjAgLSBhQ29ybmVyLnopICogY3VyclZlcnRleFBvc2l0aW9uLnh5KSArIChhQ29ybmVyLnogKiBuZXh0VmVydGV4UG9zaXRpb24ueHkpO1wiXG4gICAgfTtcbiAgICB2YXIgZXJyb3JCYXIgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhQ29ybmVyO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYW5kd2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUhpZ2hWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTG93VmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgZmxvYXQgaXNMb3cgPSAoYUNvcm5lci55ICsgMS4wKSAvIDIuMDtcXG4gICAgICAgIGZsb2F0IHlWYWx1ZSA9IGlzTG93ICogYUxvd1ZhbHVlICsgKDEuMCAtIGlzTG93KSAqIGFIaWdoVmFsdWU7XFxuXFxuICAgICAgICBmbG9hdCBpc0VkZ2VDb3JuZXIgPSBhYnMoYUNvcm5lci54KTtcXG4gICAgICAgIGZsb2F0IGxpbmVXaWR0aFhEaXJlY3Rpb24gPSAoMS4wIC0gaXNFZGdlQ29ybmVyKSAqIGFDb3JuZXIuejtcXG4gICAgICAgIGZsb2F0IGxpbmVXaWR0aFlEaXJlY3Rpb24gPSBpc0VkZ2VDb3JuZXIgKiBhQ29ybmVyLno7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIHlWYWx1ZSwgMCwgMSk7XFxuXFxuICAgICAgICBmbG9hdCB4TW9kaWZpZXIgPSAodVN0cm9rZVdpZHRoICogbGluZVdpZHRoWERpcmVjdGlvbikgKyAoYUJhbmR3aWR0aCAqIGFDb3JuZXIueCAvIDIuMCk7XFxuICAgICAgICBmbG9hdCB5TW9kaWZpZXIgPSAodVN0cm9rZVdpZHRoICogbGluZVdpZHRoWURpcmVjdGlvbik7XCJcbiAgICB9O1xuICAgIHZhciBhcmVhID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYUNvcm5lcjtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc05leHRWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpbk5leHRWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQmFzZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYXNlTmV4dFZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkTmV4dDtcXG5cXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XFxuXFxuICAgICAgICBmbG9hdCB3aGVuX2x0KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgICAgICByZXR1cm4gbWF4KHNpZ24oYiAtIGEpLCAwLjApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgYW5kKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XFxuICAgICAgICB9XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZCAqIGFEZWZpbmVkTmV4dDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgwLCAwLCAwLCAxKTtcXG5cXG4gICAgICAgIGZsb2F0IGhhc0ludGVyY2VwdGVkID0gd2hlbl9sdCgoYU1haW5OZXh0VmFsdWUgLSBhQmFzZU5leHRWYWx1ZSkgKiAoYU1haW5WYWx1ZSAtIGFCYXNlVmFsdWUpLCAwLjApO1xcbiAgICAgICAgZmxvYXQgdXNlSW50ZXJjZXB0ID0gYW5kKGFDb3JuZXIueiwgaGFzSW50ZXJjZXB0ZWQpO1xcblxcbiAgICAgICAgZmxvYXQgeUdyYWRpZW50ID0gKGFNYWluTmV4dFZhbHVlIC0gYU1haW5WYWx1ZSkgLyAoYUNyb3NzTmV4dFZhbHVlIC0gYUNyb3NzVmFsdWUpO1xcbiAgICAgICAgZmxvYXQgeUNvbnN0YW50ID0gYU1haW5OZXh0VmFsdWUgLSAoeUdyYWRpZW50ICogYUNyb3NzTmV4dFZhbHVlKTtcXG5cXG4gICAgICAgIGZsb2F0IHkwR3JhZGllbnQgPSAoYUJhc2VOZXh0VmFsdWUgLSBhQmFzZVZhbHVlKSAvIChhQ3Jvc3NOZXh0VmFsdWUgLSBhQ3Jvc3NWYWx1ZSk7XFxuICAgICAgICBmbG9hdCB5MENvbnN0YW50ID0gYUJhc2VOZXh0VmFsdWUgLSAoeTBHcmFkaWVudCAqIGFDcm9zc05leHRWYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBkZW5vbWluYXRvciA9ICh5R3JhZGllbnQgLSB5MEdyYWRpZW50KSArIHN0ZXAoYWJzKHlHcmFkaWVudCAtIHkwR3JhZGllbnQpLCAwLjApO1xcbiAgICAgICAgZmxvYXQgaW50ZXJjZXB0WFZhbHVlID0gKHkwQ29uc3RhbnQgLSB5Q29uc3RhbnQpIC8gZGVub21pbmF0b3I7XFxuICAgICAgICBmbG9hdCBpbnRlcmNlcHRZVmFsdWUgPSAoeUdyYWRpZW50ICogaW50ZXJjZXB0WFZhbHVlKSArIHlDb25zdGFudDtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChpbnRlcmNlcHRYVmFsdWUgKiB1c2VJbnRlcmNlcHQsIGludGVyY2VwdFlWYWx1ZSAqIHVzZUludGVyY2VwdCwgMCwgMSk7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbi54ICs9ICgxLjAgLSB1c2VJbnRlcmNlcHQpICogKChhQ29ybmVyLnggKiBhQ3Jvc3NOZXh0VmFsdWUpICsgKCgxLjAgLSBhQ29ybmVyLngpICogYUNyb3NzVmFsdWUpKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgKz0gKDEuMCAtIHVzZUludGVyY2VwdCkgKiAoMS4wIC0gYUNvcm5lci55KSAqICgoYUNvcm5lci54ICogYU1haW5OZXh0VmFsdWUpICsgKCgxLjAgLSBhQ29ybmVyLngpICogYU1haW5WYWx1ZSkpO1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueSArPSAoMS4wIC0gdXNlSW50ZXJjZXB0KSAqIGFDb3JuZXIueSAqICgoYUNvcm5lci54ICogYUJhc2VOZXh0VmFsdWUpICsgKCgxLjAgLSBhQ29ybmVyLngpICogYUJhc2VWYWx1ZSkpO1wiXG4gICAgfTtcbiAgICB2YXIgYm94UGxvdCA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUJhbmR3aWR0aDtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ2FwV2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUhpZ2hWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhVXBwZXJRdWFydGlsZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNZWRpYW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTG93ZXJRdWFydGlsZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFMb3dWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gdmVjMiB1U2NyZWVuO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1U3Ryb2tlV2lkdGg7XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1xcbiAgICBcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgZmxvYXQgaXNFeHRyZW1lWSA9IHNpZ24oYWJzKGFDb3JuZXIueSkgLSAyLjApICsgMS4wO1xcbiAgICAgICAgZmxvYXQgaXNOb3RFeHRyZW1lWSA9IDEuMCAtIGlzRXh0cmVtZVk7XFxuXFxuICAgICAgICBmbG9hdCBpc05vblplcm9ZID0gYWJzKHNpZ24oYUNvcm5lci55KSk7XFxuICAgICAgICBmbG9hdCBpc1plcm9ZID0gMS4wIC0gaXNOb25aZXJvWTtcXG5cXG4gICAgICAgIGZsb2F0IGlzUXVhcnRpbGVZID0gaXNOb3RFeHRyZW1lWSAqIGlzTm9uWmVyb1k7XFxuXFxuICAgICAgICBmbG9hdCBpc1Bvc2l0aXZlWSA9IChzaWduKGFDb3JuZXIueSArIDAuNSkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgaXNOZWdhdGl2ZVkgPSAxLjAgLSBpc1Bvc2l0aXZlWTtcXG5cXG4gICAgICAgIGZsb2F0IHlWYWx1ZSA9XFxuICAgICAgICAgIChpc0V4dHJlbWVZICogaXNOZWdhdGl2ZVkpICogYUhpZ2hWYWx1ZSArXFxuICAgICAgICAgIChpc1F1YXJ0aWxlWSAqIGlzTmVnYXRpdmVZKSAqIGFVcHBlclF1YXJ0aWxlVmFsdWUgK1xcbiAgICAgICAgICBpc1plcm9ZICogYU1lZGlhblZhbHVlICtcXG4gICAgICAgICAgKGlzUXVhcnRpbGVZICogaXNQb3NpdGl2ZVkpICogYUxvd2VyUXVhcnRpbGVWYWx1ZSArXFxuICAgICAgICAgIChpc0V4dHJlbWVZICogaXNQb3NpdGl2ZVkpICogYUxvd1ZhbHVlO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDcm9zc1ZhbHVlLCB5VmFsdWUsIDAsIDEpO1xcblxcbiAgICAgICAgZmxvYXQgaXNIb3Jpem9udGFsID0gYUNvcm5lci53O1xcbiAgICAgICAgZmxvYXQgaXNWZXJ0aWNhbCA9IDEuMCAtIGlzSG9yaXpvbnRhbDtcXG5cXG4gICAgICAgIGZsb2F0IHhEaXNwbGFjZW1lbnQgPSBhQ29ybmVyLnggKiAoaXNFeHRyZW1lWSAqIGFDYXBXaWR0aCArIGlzTm90RXh0cmVtZVkgKiBhQmFuZHdpZHRoKSAvIDIuMDtcXG5cXG4gICAgICAgIGZsb2F0IHhNb2RpZmllciA9IChpc1ZlcnRpY2FsICogdVN0cm9rZVdpZHRoICogYUNvcm5lci56IC8gMi4wKSArIHhEaXNwbGFjZW1lbnQ7XFxuICAgICAgICBmbG9hdCB5TW9kaWZpZXIgPSBpc0hvcml6b250YWwgKiB1U3Ryb2tlV2lkdGggKiBhQ29ybmVyLnogLyAyLjA7XCJcbiAgICB9O1xuXG4gICAgdmFyIGNpcmNsZSQxID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gbGVuZ3RoKDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjApO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gc21vb3Roc3RlcCh2U2l6ZSAtIDIuMCwgdlNpemUsIGRpc3RhbmNlICogdlNpemUpO1xcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMS4wIHx8IHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XCJcbiAgICB9OyAvLyBTZWUgaHR0cHM6Ly9pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvZGlzdGZ1bmN0aW9uczJkL2Rpc3RmdW5jdGlvbnMyZC5odG0uXG5cbiAgICB2YXIgc3RhciQxID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XFxuXFxuICAgICAgICAvLyBhbnRlcmlvciwgZXh0ZXJpb3IgYW5nbGVzXFxuICAgICAgICBmbG9hdCBhbiA9IDAuNjI4MzE5O1xcbiAgICAgICAgdmVjMiBhY3MgPSB2ZWMyKDAuODA5MDE3LCAwLjU4Nzc4Nik7IC8vIChjb3MsIHNpbilcXG4gICAgICAgIGZsb2F0IGVuID0gMC45NTIwMDA7XFxuICAgICAgICB2ZWMyIGVjcyA9IHZlYzIoMC41ODAwNTUsIDAuODE0NTc3KTtcXG4gICAgXCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG5cXG4gICAgICAgIHZlYzIgcCA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XFxuICAgICAgICBwLnkgKj0gLTEuMDtcXG5cXG4gICAgICAgIC8vIHNlY3RvclxcbiAgICAgICAgZmxvYXQgYm4gPSBtb2QoYXRhbihwLngsIHAueSksIDIuMCAqIGFuKSAtIGFuO1xcbiAgICAgICAgcCA9IGxlbmd0aChwKSAqIHZlYzIoY29zKGJuKSwgYWJzKHNpbihibikpKTtcXG5cXG4gICAgICAgIHAgLT0gYWNzO1xcbiAgICAgICAgcCArPSBlY3MgKiBjbGFtcCgtZG90KHAsIGVjcyksIDAuMCwgYWNzLnkgLyBlY3MueSk7XFxuICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKHApICogc2lnbihwLngpO1xcblxcbiAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSAxLjAgKyBkO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gc21vb3Roc3RlcCh2U2l6ZSAtIDIuMCwgdlNpemUsIGRpc3RhbmNlICogdlNpemUpO1xcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMS4wIHx8IHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XCJcbiAgICB9O1xuICAgIHZhciB3eWUkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1xcbiAgICBcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMS4wO1xcblxcbiAgICAgICAgdmVjMiBwID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXG4gICAgICAgIHAueSAqPSAtMS4wO1xcblxcbiAgICAgICAgLy8gc2VjdG9yXFxuICAgICAgICBmbG9hdCBhbiA9IDMuMTQxNTkzIC8gMy4wO1xcbiAgICAgICAgZmxvYXQgYm4gPSBtb2QoYXRhbihwLngsIHAueSksIDIuMCAqIGFuKSAtIGFuO1xcbiAgICAgICAgcCA9IGxlbmd0aChwKSAqIHZlYzIoY29zKGJuKSwgYWJzKHNpbihibikpKTtcXG5cXG4gICAgICAgIC8vIGJveFxcbiAgICAgICAgdmVjMiBkID0gYWJzKHApIC0gdmVjMigwLjksIDAuMzUpO1xcbiAgICAgICAgZmxvYXQgc2RmID0gbGVuZ3RoKG1heChkLCAwLjApKSArIG1pbihtYXgoZC54LCBkLnkpLCAwLjApO1xcblxcbiAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSAxLjAgKyBzZGY7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSBzbW9vdGhzdGVwKHZTaXplIC0gMi4wLCB2U2l6ZSwgZGlzdGFuY2UgKiB2U2l6ZSk7XFxuICAgICAgICBpZiAoZGlzdGFuY2UgPiAxLjAgfHwgdkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIHNxdWFyZSQxID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG4gICAgICAgIGlmICh2RGVmaW5lZCA8IDAuNSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XFxuICAgICAgICB2ZWMyIHBvaW50Q29vcmRUcmFuc2Zvcm0gPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xcbiAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSBtYXgoYWJzKHBvaW50Q29vcmRUcmFuc2Zvcm0ueCksIGFicyhwb2ludENvb3JkVHJhbnNmb3JtLnkpKTtcXG4gICAgICAgIGZsb2F0IGNhblN0cm9rZSA9IHNtb290aHN0ZXAodlNpemUgLSAyLjAsIHZTaXplLCBkaXN0YW5jZSAqIHZTaXplKTtcIlxuICAgIH07IC8vIERpYW1vbmQgaXMgc3ltbWV0cmljYWwgYWJvdXQgdGhlIHgsIGFuZCB5IGF4ZXMsIHNvIG9ubHkgY29uc2lkZXIgeCwgeSA+IDAuXG4gICAgLy8gKHgsIHkpIGFyZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGZyYWdtZW50IHdpdGhpbiB0aGUgZ2wgcG9pbnQgKGFmdGVyXG4gICAgLy8gdHJhbnNmb3JtZWQgdG8gYmUgWy0xLCAxXSkuXG4gICAgLy8gYSwgYiBjb250cm9sIHRoZSB3aWR0aCwgaGVpZ2h0IG9mIHRoZSB0cmlhbmdsZSwgc28gZGlhbW9uZCBpcyAyYSwgMmIuXG4gICAgLy8gTGluZSBMIGlzIGEgcmF5IGZyb20gdGhlIG9yaWdpbiB0aHJvdWdoICh4LCB5KSwgdGhlIGRpc3RhbmNlIGZ1bmN0aW9uIGlzIHRoZW5cbiAgICAvLyB0aGUgZGlzdGFuY2UgdG8gKHgsIHkpIGRpdmlkZWQgYnkgdGhlIGRpc3RhbmNlIHRvIHdoZXJlIEwgaW50ZXJzZWN0cyB3aXRoIHRoZVxuICAgIC8vIGRpYW1vbmQsIHRoaXMgbWFrZXMgdGhlIGRpc3RhbmNlIGZ1bmN0aW9uIDwgMSBpbnNpZGUsIDEgb24gdGhlIGJvdW5kYXJ5LCBhbmRcbiAgICAvLyA+IDEgb3V0c2lkZSB0aGUgZGlhbW9uZC5cbiAgICAvLyAgICB8XG4gICAgLy8gYiAtLS1cbiAgICAvLyAgICB8XFwgICAgICAgICAgICAgTFxuICAgIC8vICAgIHwgLVxcICAgICAgICAgIC9cbiAgICAvLyAgICB8ICAgXFwgICAgICAgIC9cbiAgICAvLyAgICB8ICAgIFxcICAgICAgL1xuICAgIC8vICAgIHwgICAgIC1cXCAgIC9cbiAgICAvLyAgICB8ICAgICAgIFxcIC9cbiAgICAvLyBZIC0tLSAgICAgICBYXG4gICAgLy8gICAgfCAgICAgICAvIC1cXFxuICAgIC8vICAgIHwgICAgICAvICAgIFxcXG4gICAgLy8gICAgfCAgICAgLyAgICAgIFxcXG4gICAgLy8geSAtLS0gICBYICAgICAgICAtXFxcbiAgICAvLyAgICB8ICAgLyAgICAgICAgICAgXFxcbiAgICAvLyAgICB8ICAvICAgICAgICAgICAgIFxcXG4gICAgLy8gICAgfCAvICAgICAgICAgICAgICAgLVxcXG4gICAgLy8gICAgfC8gICAgICAgICAgICAgICAgICBcXFxuICAgIC8vICAgICstLS0tfC0tLXwtLS0tLS0tLS0tLXwtLS1cbiAgICAvLyAgICAgICAgIHggICBYICAgICAgICAgICBhXG5cbiAgICB2YXIgZGlhbW9uZCQxID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XFxuICAgICAgICBmbG9hdCBhID0gMC42O1xcbiAgICAgICAgZmxvYXQgYiA9IDEuMDtcXG4gICAgXCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgcG9pbnRDb29yZFRyYW5zZm9ybSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XFxuXFxuICAgICAgICBmbG9hdCB4ID0gYWJzKHBvaW50Q29vcmRUcmFuc2Zvcm0ueCk7XFxuICAgICAgICBmbG9hdCB5ID0gYWJzKHBvaW50Q29vcmRUcmFuc2Zvcm0ueSk7XFxuXFxuICAgICAgICBmbG9hdCBYID0gKGEgKiBiICogeCkgLyAoYSAqIHkgKyBiICogeCk7XFxuICAgICAgICBmbG9hdCBZID0gKGEgKiBiICogeSkgLyAoYSAqIHkgKyBiICogeCk7XFxuXFxuICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aCh2ZWMyKHgsIHkpKSAvIGxlbmd0aCh2ZWMyKFgsIFkpKTtcXG5cXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDEuMCkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XFxuICAgIFwiXG4gICAgfTtcbiAgICB2YXIgdHJpYW5nbGUkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAxLjA7XFxuICAgICAgICB2ZWMyIHBvaW50Q29vcmRUcmFuc2Zvcm0gPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xcbiAgICAgICAgZmxvYXQgdG9wRWRnZXNEaXN0YW5jZSA9IGFicyhwb2ludENvb3JkVHJhbnNmb3JtLngpIC0gKChwb2ludENvb3JkVHJhbnNmb3JtLnkgLSAwLjYpIC8gc3FydCgzLjApKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUVkZ2VEaXN0YW5jZSA9IHBvaW50Q29vcmRUcmFuc2Zvcm0ueSArIDAuNTtcXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gbWF4KHRvcEVkZ2VzRGlzdGFuY2UsIGJvdHRvbUVkZ2VEaXN0YW5jZSk7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSBzbW9vdGhzdGVwKHZTaXplIC0gMi4wLCB2U2l6ZSwgZGlzdGFuY2UgKiB2U2l6ZSk7XFxuICAgICAgICBpZiAoZGlzdGFuY2UgPiAxLjAgfHwgdkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgY3Jvc3MkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTdHJva2VXaWR0aFJhdGlvO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMS4wO1xcbiAgICAgICAgdmVjMiBwb2ludENvb3JkVHJhbnNmb3JtID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXG4gICAgICAgIGZsb2F0IGlubmVyQ29ybmVyRGlzdGFuY2UgPSBtaW4oYWJzKHBvaW50Q29vcmRUcmFuc2Zvcm0ueCksIGFicyhwb2ludENvb3JkVHJhbnNmb3JtLnkpKSArIDAuNjYgLSB2U3Ryb2tlV2lkdGhSYXRpbztcXG4gICAgICAgIGZsb2F0IG91dGVyRWRnZURpc3RhbmNlID0gbWF4KGFicyhwb2ludENvb3JkVHJhbnNmb3JtLngpLCBhYnMocG9pbnRDb29yZFRyYW5zZm9ybS55KSk7XFxuICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IG1heChpbm5lckNvcm5lckRpc3RhbmNlLCBvdXRlckVkZ2VEaXN0YW5jZSk7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSBzbW9vdGhzdGVwKHZTaXplIC0gMi4wLCB2U2l6ZSwgZGlzdGFuY2UgKiB2U2l6ZSk7XFxuICAgICAgICBpZiAoZGlzdGFuY2UgPiAxLjAgfHwgdkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgY2FuZGxlc3RpY2skMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkNvbG9ySW5kaWNhdG9yO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMS4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMC4wO1xcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC40LCAwLjgsIDAsIDEpO1xcbiAgICAgICAgaWYgKHZDb2xvckluZGljYXRvciA8IDAuMCkge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC44LCAwLjQsIDAsIDEpO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgb2hsYyQxID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2Q29sb3JJbmRpY2F0b3I7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAwLjA7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSAxLjA7XFxuICAgICAgICBpZiAodkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjQsIDAuOCwgMCwgMSk7XFxuICAgICAgICBpZiAodkNvbG9ySW5kaWNhdG9yIDwgMC4wKSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjgsIDAuNCwgMCwgMSk7XFxuICAgICAgICB9XCJcbiAgICB9O1xuICAgIHZhciBhcmVhJDEgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAxLjA7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSAwLjA7XFxuICAgICAgICBpZiAodkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjg2LCAwLjg2LCAwLjg2LCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGJveFBsb3QkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XFxuICAgIFwiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAwLjA7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSAxLjA7XFxuXFxuICAgICAgICBpZiAodkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgZXJyb3JCYXIkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJ2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAwLjA7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSAxLjA7XFxuICAgICAgICBpZiAodkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgYmFyJDEgPSB7XG4gICAgICBoZWFkZXI6IFwidmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMS4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMC4wO1xcblxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjYwLCAwLjYwLCAwLjYwLCAxLjApO1xcblxcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIGZpbGxDb2xvciQxID0ge1xuICAgICAgaGVhZGVyOiBcInZhcnlpbmcgdmVjNCB2RmlsbENvbG9yO1wiLFxuICAgICAgYm9keTogXCJnbF9GcmFnQ29sb3IgPSAoY2FuRmlsbCAqIHZGaWxsQ29sb3IpICsgKCgxLjAgLSBjYW5GaWxsKSAqIGdsX0ZyYWdDb2xvcik7XCJcbiAgICB9O1xuICAgIHZhciBzdHJva2VDb2xvciQxID0ge1xuICAgICAgaGVhZGVyOiBcInZhcnlpbmcgdmVjNCB2U3Ryb2tlQ29sb3I7XCIsXG4gICAgICBib2R5OiBcImdsX0ZyYWdDb2xvciA9IChjYW5TdHJva2UgKiB2U3Ryb2tlQ29sb3IpICsgKCgxLjAgLSBjYW5TdHJva2UpICogZ2xfRnJhZ0NvbG9yKTtcIlxuICAgIH07XG4gICAgdmFyIGxpbmUgPSB7XG4gICAgICBoZWFkZXI6IFwidmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMC4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMS4wO1xcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cIlxuICAgIH07XG5cbiAgICB2YXIgYXJlYVNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoYXJlYS5oZWFkZXIpLmFwcGVuZEJvZHkoYXJlYS5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihhcmVhJDEuaGVhZGVyKS5hcHBlbmRCb2R5KGFyZWEkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgdHlwZXMgPSB7XG4gICAgICBCWVRFOiA1MTIwLFxuICAgICAgVU5TSUdORURfQllURTogNTEyMSxcbiAgICAgIFNIT1JUOiA1MTIyLFxuICAgICAgVU5TSUdORURfU0hPUlQ6IDUxMjMsXG4gICAgICBGTE9BVDogNTEyNlxuICAgIH07XG4gICAgZnVuY3Rpb24gbGVuZ3RoKHR5cGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLkJZVEU6XG4gICAgICAgIGNhc2UgdHlwZXMuVU5TSUdORURfQllURTpcbiAgICAgICAgICByZXR1cm4gMTtcblxuICAgICAgICBjYXNlIHR5cGVzLlNIT1JUOlxuICAgICAgICBjYXNlIHR5cGVzLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgIHJldHVybiAyO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuRkxPQVQ6XG4gICAgICAgICAgcmV0dXJuIDQ7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlWaWV3Q29uc3RydWN0b3IodHlwZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuQllURTpcbiAgICAgICAgICByZXR1cm4gSW50OEFycmF5O1xuXG4gICAgICAgIGNhc2UgdHlwZXMuVU5TSUdORURfQllURTpcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheTtcblxuICAgICAgICBjYXNlIHR5cGVzLlNIT1JUOlxuICAgICAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuXG4gICAgICAgIGNhc2UgdHlwZXMuVU5TSUdORURfU0hPUlQ6XG4gICAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuXG4gICAgICAgIGNhc2UgdHlwZXMuRkxPQVQ6XG4gICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIi5jb25jYXQodHlwZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiYXNlQXR0cmlidXRlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSAtMTtcbiAgICAgIHZhciBidWZmZXIgPSBudWxsO1xuICAgICAgdmFyIHNpemUgPSAxOyAvLyBwZXIgdmVydGV4XG5cbiAgICAgIHZhciB0eXBlID0gdHlwZXMuRkxPQVQ7XG4gICAgICB2YXIgbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgICAgdmFyIHN0cmlkZSA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBkaXZpc29yID0gbnVsbDtcblxuICAgICAgdmFyIGJhc2VBdHRyaWJ1dGUgPSBmdW5jdGlvbiBiYXNlQXR0cmlidXRlKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIHZhciBnbCA9IHByb2dyYW1CdWlsZGVyLmNvbnRleHQoKTtcblxuICAgICAgICBpZiAoYnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgdmFyIGV4dEluc3RhbmNlZEFycmF5cyA9IHByb2dyYW1CdWlsZGVyLmV4dEluc3RhbmNlZEFycmF5cygpO1xuICAgICAgICBleHRJbnN0YW5jZWRBcnJheXMudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGxvY2F0aW9uLCBkaXZpc29yICE9IG51bGwgPyBkaXZpc29yIDogcHJvZ3JhbUJ1aWxkZXIuc3ViSW5zdGFuY2VDb3VudCgpID4gMCA/IDEgOiAwKTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUubG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2F0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUuYnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUubm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUuc3RyaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUub2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2VBdHRyaWJ1dGUuZGl2aXNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRpdmlzb3I7XG4gICAgICAgIH1cblxuICAgICAgICBkaXZpc29yID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBiYXNlQXR0cmlidXRlO1xuICAgIH0pO1xuXG4gICAgdmFyIGRlZmF1bHRBcnJheVZpZXdGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZXMuRkxPQVQ7XG4gICAgICB2YXIgY2FjaGVkQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDApO1xuXG4gICAgICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uIGZhY3RvcnkocmVxdWlyZWRMZW5ndGgpIHtcbiAgICAgICAgdmFyIEFycmF5VHlwZSA9IGdldEFycmF5Vmlld0NvbnN0cnVjdG9yKHR5cGUpO1xuXG4gICAgICAgIGlmIChjYWNoZWRBcnJheS5sZW5ndGggPiByZXF1aXJlZExlbmd0aCkge1xuICAgICAgICAgIGNhY2hlZEFycmF5ID0gbmV3IEFycmF5VHlwZShjYWNoZWRBcnJheS5idWZmZXIsIDAsIHJlcXVpcmVkTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWNoZWRBcnJheS5sZW5ndGggIT09IHJlcXVpcmVkTGVuZ3RoKSB7XG4gICAgICAgICAgY2FjaGVkQXJyYXkgPSBuZXcgQXJyYXlUeXBlKHJlcXVpcmVkTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZWRBcnJheTtcbiAgICAgIH07XG5cbiAgICAgIGZhY3RvcnkudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSAhPT0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgIHZhciBBcnJheVR5cGUgPSBnZXRBcnJheVZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgICBjYWNoZWRBcnJheSA9IG5ldyBBcnJheVR5cGUoMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH0pO1xuXG4gICAgdmFyIGF0dHJpYnV0ZVByb2plY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGlydHkgPSB0cnVlO1xuICAgICAgdmFyIHNpemUgPSAxOyAvLyBwZXIgdmVydGV4XG5cbiAgICAgIHZhciB0eXBlID0gdHlwZXMuRkxPQVQ7XG4gICAgICB2YXIgYXJyYXlWaWV3RmFjdG9yeSA9IGRlZmF1bHRBcnJheVZpZXdGYWN0b3J5KCk7XG5cbiAgICAgIHZhciB2YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICAgIHZhciBwcm9qZWN0b3IgPSBmdW5jdGlvbiBwcm9qZWN0b3IoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIHByb2plY3RlZERhdGEgPSBhcnJheVZpZXdGYWN0b3J5LnR5cGUodHlwZSkobGVuZ3RoICogc2l6ZSk7XG5cbiAgICAgICAgaWYgKHNpemUgPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFZhbHVlcyA9IHZhbHVlKGRhdGFbaV0sIGkpO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VmFsdWVzLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBjb21wb25lbnRzIGFycmF5IG9mIHNpemUgXCIuY29uY2F0KHNpemUsIFwiLCByZWNpZXZlZCBhcnJheSB3aXRoIGxlbmd0aCBcIikuY29uY2F0KGNvbXBvbmVudFZhbHVlcy5sZW5ndGgsIFwiLlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNvbXBvbmVudCA9IDA7IGNvbXBvbmVudCA8IHNpemU7IGNvbXBvbmVudCsrKSB7XG4gICAgICAgICAgICAgIHByb2plY3RlZERhdGFbaSAqIHNpemUgKyBjb21wb25lbnRdID0gY29tcG9uZW50VmFsdWVzW2NvbXBvbmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRWYWx1ZSA9IHZhbHVlKGRhdGFbX2ldLCBfaSk7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudFZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHNpbmdsZSBjb21wb25lbnQgdmFsdWUsIHJlY2lldmVkIGFycmF5IHdpdGggbGVuZ3RoIFwiLmNvbmNhdChjb21wb25lbnRWYWx1ZS5sZW5ndGgsIFwiLlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2plY3RlZERhdGFbX2ldID0gY29tcG9uZW50VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RlZERhdGE7XG4gICAgICB9O1xuXG4gICAgICBwcm9qZWN0b3IuZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgIH07XG5cbiAgICAgIHByb2plY3Rvci5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgcHJvamVjdG9yLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJvamVjdG9yO1xuICAgICAgfTtcblxuICAgICAgcHJvamVjdG9yLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJvamVjdG9yO1xuICAgICAgfTtcblxuICAgICAgcHJvamVjdG9yLmFycmF5Vmlld0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBhcnJheVZpZXdGYWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlWaWV3RmFjdG9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJvamVjdG9yO1xuICAgICAgfTtcblxuICAgICAgcHJvamVjdG9yLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJvamVjdG9yO1xuICAgICAgfTtcblxuICAgICAgcHJvamVjdG9yLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJvamVjdG9yO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICB9KTtcblxuICAgIHZhciBhdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJhc2UgPSBiYXNlQXR0cmlidXRlQnVpbGRlcigpO1xuICAgICAgdmFyIHByb2plY3RvciA9IGF0dHJpYnV0ZVByb2plY3RvcigpO1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gZnVuY3Rpb24gYXR0cmlidXRlKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIGJhc2Uuc2l6ZShhdHRyaWJ1dGUuc2l6ZSgpKS50eXBlKGF0dHJpYnV0ZS50eXBlKCkpO1xuICAgICAgICBiYXNlKHByb2dyYW1CdWlsZGVyKTtcblxuICAgICAgICBpZiAoIXByb2plY3Rvci5kaXJ0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb2plY3RlZERhdGEgPSBwcm9qZWN0b3IoKTtcbiAgICAgICAgdmFyIGdsID0gcHJvZ3JhbUJ1aWxkZXIuY29udGV4dCgpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYmFzZS5idWZmZXIoKSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBwcm9qZWN0ZWREYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgfTtcblxuICAgICAgYXR0cmlidXRlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBiYXNlLmJ1ZmZlcihudWxsKTtcbiAgICAgICAgcHJvamVjdG9yLmNsZWFyKCk7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChhdHRyaWJ1dGUsIGJhc2UsICdub3JtYWxpemVkJywgJ2xvY2F0aW9uJywgJ2Rpdmlzb3InKTtcbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGF0dHJpYnV0ZSwgcHJvamVjdG9yLCAnZGF0YScsICd2YWx1ZScsICdzaXplJywgJ3R5cGUnKTtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgfSk7XG5cbiAgICB2YXIgcmViaW5kQ3VycnkgPSAoZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0TmFtZSwgc291cmNlLCBzb3VyY2VOYW1lKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY3VycmllZEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDQgPyBfbGVuIC0gNCA6IDApLCBfa2V5ID0gNDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBjdXJyaWVkQXJnc1tfa2V5IC0gNF0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldFt0YXJnZXROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZVtzb3VyY2VOYW1lXS5hcHBseShzb3VyY2UsIGN1cnJpZWRBcmdzLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZWEkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1CdWlsZGVyKCkubW9kZShkcmF3TW9kZXMuVFJJQU5HTEVTKS5zdWJJbnN0YW5jZUNvdW50KDYpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuXG4gICAgICB2YXIgY29ybmVyQXR0cmlidXRlID0gYXR0cmlidXRlKCkuZGl2aXNvcigwKS5zaXplKDMpLnR5cGUodHlwZXMuVU5TSUdORURfQllURSkuZGF0YShbWzAsIDAsIDBdLCBbMCwgMSwgMF0sIFsxLCAxLCAxXSwgWzAsIDAsIDFdLCBbMSwgMCwgMF0sIFsxLCAxLCAwXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuYXR0cmlidXRlKCdhQ29ybmVyJywgY29ybmVyQXR0cmlidXRlKTtcblxuICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbiBkcmF3KG51bUVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBzaGFkZXJCdWlsZGVyID0gYXJlYVNoYWRlcigpO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcihzaGFkZXJCdWlsZGVyLnZlcnRleCgpKS5mcmFnbWVudFNoYWRlcihzaGFkZXJCdWlsZGVyLmZyYWdtZW50KCkpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAxKTtcbiAgICAgICAgZGVjb3JhdGUocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0obnVtRWxlbWVudHMgLSAxKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYXcuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZWNvcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeFNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeVNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIHByb2dyYW0sICdjb250ZXh0JywgJ3BpeGVsUmF0aW8nKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc05leHRWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc05leHRWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ21haW5WYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FNYWluVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtYWluTmV4dFZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYU1haW5OZXh0VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdiYXNlVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQmFzZVZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFzZU5leHRWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FCYXNlTmV4dFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZE5leHRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZE5leHQnKTtcbiAgICAgIHJldHVybiBkcmF3O1xuICAgIH0pO1xuXG4gICAgdmFyIGNpcmNsZVBvaW50U2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyQnVpbGRlcihmcmFnbWVudFNoYWRlckJhc2UpO1xuICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEhlYWRlcihjaXJjbGUuaGVhZGVyKS5hcHBlbmRCb2R5KGNpcmNsZS5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihjaXJjbGUkMS5oZWFkZXIpLmFwcGVuZEJvZHkoY2lyY2xlJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIHBvaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9ncmFtID0gcHJvZ3JhbUJ1aWxkZXIoKS5tb2RlKGRyYXdNb2Rlcy5QT0lOVFMpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHR5cGUgPSBjaXJjbGVQb2ludFNoYWRlcigpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuXG4gICAgICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcobnVtRWxlbWVudHMpIHtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIodHlwZS52ZXJ0ZXgoKSkuZnJhZ21lbnRTaGFkZXIodHlwZS5mcmFnbWVudCgpKTtcbiAgICAgICAgeFNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDApO1xuICAgICAgICB5U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMSk7XG4gICAgICAgIGRlY29yYXRlKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtKG51bUVsZW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYXcudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZWNvcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeFNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeVNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIHByb2dyYW0sICdjb250ZXh0JywgJ3BpeGVsUmF0aW8nKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtYWluVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTWFpblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnc2l6ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FTaXplJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkJyk7XG4gICAgICByZXR1cm4gZHJhdztcbiAgICB9KTtcblxuICAgIHZhciBsaW5lU2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyQnVpbGRlcihmcmFnbWVudFNoYWRlckJhc2UpO1xuICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEhlYWRlcihwcmVTY2FsZUxpbmUuaGVhZGVyKS5hcHBlbmRCb2R5KHByZVNjYWxlTGluZS5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihsaW5lLmhlYWRlcikuYXBwZW5kQm9keShsaW5lLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBsaW5lV2lkdGhTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdpZHRoID0gMTtcblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IGZ1bmN0aW9uIGxpbmVXaWR0aChwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0uYnVmZmVycygpLnVuaWZvcm0oJ3VTdHJva2VXaWR0aCcsIHVuaWZvcm0od2lkdGgpKTtcbiAgICAgIH07XG5cbiAgICAgIGxpbmVXaWR0aC5saW5lV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gbGluZVdpZHRoO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGxpbmVXaWR0aDtcbiAgICB9KTtcblxuICAgIHZhciBlbGVtZW50SW5kaWNlcyA9IChmdW5jdGlvbiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHZhciBidWZmZXIgPSBudWxsO1xuICAgICAgdmFyIGRhdGEgPSBpbml0aWFsRGF0YTtcbiAgICAgIHZhciBkaXJ0eSA9IHRydWU7XG5cbiAgICAgIHZhciBiYXNlID0gZnVuY3Rpb24gYmFzZShwcm9ncmFtQnVpbGRlcikge1xuICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtQnVpbGRlci5jb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXG4gICAgICAgIGlmICghZGlydHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBuZXcgVWludDE2QXJyYXkoZGF0YSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2UuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIGJhc2UuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSk7XG5cbiAgICB2YXIgbGluZSQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9ncmFtID0gcHJvZ3JhbUJ1aWxkZXIoKS5tb2RlKGRyYXdNb2Rlcy5UUklBTkdMRVMpLnN1Ykluc3RhbmNlQ291bnQoMTIpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuXG4gICAgICB2YXIgbGluZVdpZHRoID0gbGluZVdpZHRoU2hhZGVyKCk7XG4gICAgICB2YXIgY29ybmVyQXR0cmlidXRlID0gYXR0cmlidXRlKCkuZGl2aXNvcigwKS5zaXplKDMpLnR5cGUodHlwZXMuQllURSkuZGF0YShbWy0xLCAwLCAwXSwgWzEsIDEsIDBdLCBbMSwgLTEsIDFdLCBbLTEsIDAsIDFdLCBbMSwgMSwgMV1dKTtcbiAgICAgIHByb2dyYW0uYnVmZmVycygpLmVsZW1lbnRJbmRpY2VzKGVsZW1lbnRJbmRpY2VzKFswLCAxLCAyLCAxLCAyLCAzLCAwLCAyLCAzLCAyLCAzLCA0XSkpLmF0dHJpYnV0ZSgnYUNvcm5lcicsIGNvcm5lckF0dHJpYnV0ZSk7XG5cbiAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgc2hhZGVyQnVpbGRlciA9IGxpbmVTaGFkZXIoKTtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIoc2hhZGVyQnVpbGRlci52ZXJ0ZXgoKSkuZnJhZ21lbnRTaGFkZXIoc2hhZGVyQnVpbGRlci5mcmFnbWVudCgpKTtcbiAgICAgICAgeFNjYWxlKHByb2dyYW0sICdwcmV2JywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAncHJldicsIDEpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ2N1cnInLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdjdXJyJywgMSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ25leHROZXh0JywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAnbmV4dE5leHQnLCAxKTtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIoKS5hcHBlbmRCb2R5KHBvc3RTY2FsZUxpbmUuYm9keSk7XG4gICAgICAgIGxpbmVXaWR0aChwcm9ncmFtKTtcbiAgICAgICAgZGVjb3JhdGUocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0obnVtRWxlbWVudHMgLSAxKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYXcuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZWNvcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeFNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeVNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIHByb2dyYW0sICdjb250ZXh0JywgJ3BpeGVsUmF0aW8nKTtcbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIGxpbmVXaWR0aCwgJ2xpbmVXaWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nyb3NzUHJldmlvdXNWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ByZXZWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nyb3NzVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ3Jvc3NWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nyb3NzTmV4dFZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzTmV4dFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NOZXh0TmV4dFZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzTmV4dE5leHRWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ21haW5QcmV2aW91c1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYU1haW5QcmV2VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtYWluVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTWFpblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbWFpbk5leHRWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FNYWluTmV4dFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbWFpbk5leHROZXh0VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTWFpbk5leHROZXh0VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdkZWZpbmVkQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYURlZmluZWQnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdkZWZpbmVkTmV4dEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkTmV4dCcpO1xuICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSk7XG5cbiAgICB2YXIgb2hsY1NoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIob2hsYy5oZWFkZXIpLmFwcGVuZEJvZHkob2hsYy5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihvaGxjJDEuaGVhZGVyKS5hcHBlbmRCb2R5KG9obGMkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgb2hsYyQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9ncmFtID0gcHJvZ3JhbUJ1aWxkZXIoKS5tb2RlKGRyYXdNb2Rlcy5UUklBTkdMRVMpLnN1Ykluc3RhbmNlQ291bnQoMTgpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVXaWR0aFNoYWRlcigpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuICAgICAgLypcbiAgICAgICAqIHgteSBjb29yZGluYXRlIHRvIGxvY2F0ZSB0aGUgXCJjb3JuZXJzXCIgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgKiBYOiAtMTogTEVGVCwgMDogTUlERExFLCAxOiBSSUdIVFxuICAgICAgICogWTogLTI6IEhJR0gsIC0xOiBPUEVOLCAxOiBDTE9TRSwgMjogTE9XXG4gICAgICAgKiBaIC0gRm9sbG93cyBjb252ZW50aW9uIGZvciBYL1kgKGFwcHJvcHJpYXRlIGRpcmVjdGlvbiB3aWxsIGJlIHNlbGVjdGVkIGJ5IHRoZSBzaGFkZXIpOiAtMTogTEVGVC9UT1AsIDE6IFJJR0hUL0JPVFRPTVxuICAgICAgICovXG5cblxuICAgICAgdmFyIGNvcm5lckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZSgpLmRpdmlzb3IoMCkuc2l6ZSgzKS50eXBlKHR5cGVzLkJZVEUpLmRhdGEoWy8vIE1haW4gc3RlbVxuICAgICAgWzAsIC0yLCAtMV0sIFswLCAtMiwgMV0sIFswLCAyLCAxXSwgWzAsIDIsIC0xXSwgLy8gT3BlbiBiYXJcbiAgICAgIFstMSwgLTEsIC0xXSwgWy0xLCAtMSwgMV0sIFswLCAtMSwgMV0sIFswLCAtMSwgLTFdLCAvLyBDbG9zZSBiYXJcbiAgICAgIFsxLCAxLCAxXSwgWzAsIDEsIDFdLCBbMCwgMSwgLTFdLCBbMSwgMSwgLTFdXSk7XG4gICAgICBwcm9ncmFtLmJ1ZmZlcnMoKS5lbGVtZW50SW5kaWNlcyhlbGVtZW50SW5kaWNlcyhbLy8gTWFpbiBzdGVtXG4gICAgICAwLCAxLCAyLCAwLCAzLCAyLCAvLyBPcGVuIGJhclxuICAgICAgNCwgNSwgNiwgNCwgNywgNiwgLy8gQ2xvc2UgYmFyXG4gICAgICA4LCA5LCAxMCwgMTAsIDExLCA4XSkpLmF0dHJpYnV0ZSgnYUNvcm5lcicsIGNvcm5lckF0dHJpYnV0ZSk7XG5cbiAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgc2hhZGVyQnVpbGRlciA9IG9obGNTaGFkZXIoKTtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIoc2hhZGVyQnVpbGRlci52ZXJ0ZXgoKSkuZnJhZ21lbnRTaGFkZXIoc2hhZGVyQnVpbGRlci5mcmFnbWVudCgpKTtcbiAgICAgICAgeFNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDApO1xuICAgICAgICB5U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMSk7XG4gICAgICAgIGxpbmVXaWR0aChwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIoKS5hcHBlbmRCb2R5KFwiXFxuICAgICAgICAgIGdsX1Bvc2l0aW9uLnggKz0geE1vZGlmaWVyIC8gdVNjcmVlbi54ICogMi4wO1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbi55ICs9IHlNb2RpZmllciAvIHVTY3JlZW4ueSAqIDIuMDtcXG4gICAgICAgIFwiKTtcbiAgICAgICAgZGVjb3JhdGUocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0obnVtRWxlbWVudHMpO1xuICAgICAgfTtcblxuICAgICAgZHJhdy5kZWNvcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29yYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy54U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB4U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB4U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy55U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB5U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB5U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgcHJvZ3JhbSwgJ2NvbnRleHQnLCAncGl4ZWxSYXRpbycpO1xuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgbGluZVdpZHRoLCAnbGluZVdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnb3BlblZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYU9wZW5WYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2hpZ2hWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FIaWdoVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdsb3dWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FMb3dWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nsb3NlVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ2xvc2VWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2JhbmR3aWR0aEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FCYW5kd2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdkZWZpbmVkQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYURlZmluZWQnKTtcbiAgICAgIHJldHVybiBkcmF3O1xuICAgIH0pO1xuXG4gICAgdmFyIGJhclNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoYmFyLmhlYWRlcikuYXBwZW5kQm9keShiYXIuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoYmFyJDEuaGVhZGVyKS5hcHBlbmRCb2R5KGJhciQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vICAgICAuLS0tLS0tLS0tLS0tLS4tLS0tLS0tLS0tLS0uXG4gICAgLy8gKHgtdy8yLCB5MSkgICAgKHgsIHkxKSAgICh4K3cvMiwgeTEpXG4gICAgLy8gICAgIHwgICAgIFxcICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgIFxcICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgIFxcICAgICAgICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgICAgIFxcICAgICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgIFxcICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgICAgIFxcICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgIFxcICB8XG4gICAgLy8gICAgIM6xTCAgICAgICAgICAgIM6xICAgICAgICAgICAgzrFSXG4gICAgLy8gICAgIC4tLS0tLS0tLS0tLS0tLi0tLS0tLS0tLS0tLS5cbiAgICAvLyAoeC13LzIsIHkwKSAgICAgKHgsIHkwKSAgICh4K3cvMiwgeTApXG4gICAgLy8gRHJhd2luZyBvcmRlclxuICAgIC8vIFRyaWFuZ2xlIM6yTCwgzrFMLCDOsVIuIChib3R0b20pXG4gICAgLy8gzrIgLT4gzrJMLlxuICAgIC8vIM6xIC0+IM6xTC5cbiAgICAvLyDOsSAtPiDOsVIuXG4gICAgLy8gVHJpYW5nbGUgzrJMLCDOsVIsIM6yUi4gKHRvcClcbiAgICAvLyDOsiAtPiDOskwuXG4gICAgLy8gzrEgLT4gzrFSLlxuICAgIC8vIM6yIC0+IM6yUi5cblxuICAgIHZhciBiYXIkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1CdWlsZGVyKCkubW9kZShkcmF3TW9kZXMuVFJJQU5HTEVTKS5zdWJJbnN0YW5jZUNvdW50KDYpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuXG4gICAgICB2YXIgY29ybmVyQXR0cmlidXRlID0gYXR0cmlidXRlKCkuZGl2aXNvcigwKS5zaXplKDIpLnR5cGUodHlwZXMuQllURSkuZGF0YShbWy0xLCAtMV0sIFsxLCAxXSwgWy0xLCAxXSwgWzEsIC0xXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuZWxlbWVudEluZGljZXMoZWxlbWVudEluZGljZXMoWzAsIDEsIDIsIDAsIDEsIDNdKSkuYXR0cmlidXRlKCdhQ29ybmVyJywgY29ybmVyQXR0cmlidXRlKTtcblxuICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbiBkcmF3KG51bUVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBzaGFkZXJCdWlsZGVyID0gYmFyU2hhZGVyKCk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHNoYWRlckJ1aWxkZXIudmVydGV4KCkpLmZyYWdtZW50U2hhZGVyKHNoYWRlckJ1aWxkZXIuZnJhZ21lbnQoKSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcigpLmFwcGVuZEJvZHkoXCJcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbi54ICs9IHhNb2RpZmllciAvIHVTY3JlZW4ueCAqIDIuMDtcXG4gICAgICAgIFwiKTtcbiAgICAgICAgZGVjb3JhdGUocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0obnVtRWxlbWVudHMpO1xuICAgICAgfTtcblxuICAgICAgZHJhdy5kZWNvcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29yYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy54U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB4U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB4U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy55U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB5U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB5U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgcHJvZ3JhbSwgJ2NvbnRleHQnLCAncGl4ZWxSYXRpbycpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nyb3NzVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ3Jvc3NWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ21haW5WYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FNYWluVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdiYXNlVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQmFzZVZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFuZHdpZHRoQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUJhbmR3aWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSk7XG5cbiAgICB2YXIgZXJyb3JCYXJTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKGVycm9yQmFyLmhlYWRlcikuYXBwZW5kQm9keShlcnJvckJhci5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihlcnJvckJhciQxLmhlYWRlcikuYXBwZW5kQm9keShlcnJvckJhciQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBlcnJvckJhciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9ncmFtID0gcHJvZ3JhbUJ1aWxkZXIoKS5tb2RlKGRyYXdNb2Rlcy5UUklBTkdMRVMpLnN1Ykluc3RhbmNlQ291bnQoMTgpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuXG4gICAgICB2YXIgbGluZVdpZHRoID0gbGluZVdpZHRoU2hhZGVyKCk7XG4gICAgICAvKlxuICAgICAgICogeC15IGNvb3JkaW5hdGUgdG8gbG9jYXRlIHRoZSBcImNvcm5lcnNcIiBvZiB0aGUgZWxlbWVudCAoaWUgZXJyb3JiYXIpLiBUaGUgYHpgIGNvb3JkaW5hdGUgbG9jYXRlcyB0aGUgY29ybmVyIHJlbGF0aXZlIHRvIHRoZSBsaW5lICh0aGlzIHRha2VzIGxpbmUgd2lkdGggaW50byBhY2NvdW50KS5cbiAgICAgICAqIFg6IC0xOiBMRUZULCAwOiBNSURETEUsIDE6IFJJR0hUXG4gICAgICAgKiBZOiAtMTogSElHSCwgMTogTE9XXG4gICAgICAgKiBaOiBGb2xsb3dzIFggb3IgWSBjb252ZW50aW9uLCBkZXBlbmRpbmcgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBsaW5lIHRoYXQgdGhlIHZlcnRleCBpcyBwYXJ0IG9mLlxuICAgICAgICovXG5cbiAgICAgIHZhciBjb3JuZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5kaXZpc29yKDApLnNpemUoMykudHlwZSh0eXBlcy5CWVRFKS5kYXRhKFsvLyBNYWluIHN0ZW1cbiAgICAgIFswLCAxLCAxXSwgWzAsIDEsIC0xXSwgWzAsIC0xLCAtMV0sIFswLCAtMSwgMV0sIC8vIFRvcCBjYXBcbiAgICAgIFsxLCAtMSwgMV0sIFsxLCAtMSwgLTFdLCBbLTEsIC0xLCAtMV0sIFstMSwgLTEsIDFdLCAvLyBCb3R0b20gY2FwXG4gICAgICBbLTEsIDEsIC0xXSwgWy0xLCAxLCAxXSwgWzEsIDEsIDFdLCBbMSwgMSwgLTFdXSk7XG4gICAgICBwcm9ncmFtLmJ1ZmZlcnMoKS5lbGVtZW50SW5kaWNlcyhlbGVtZW50SW5kaWNlcyhbLy8gTWFpbiBzdGVtXG4gICAgICAwLCAxLCAyLCAwLCAzLCAyLCAvLyBUb3AgY2FwXG4gICAgICA0LCA1LCA2LCA0LCA3LCA2LCAvLyBCb3R0b20gY2FwXG4gICAgICA4LCA5LCAxMCwgOCwgMTEsIDEwXSkpLmF0dHJpYnV0ZSgnYUNvcm5lcicsIGNvcm5lckF0dHJpYnV0ZSk7XG5cbiAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgc2hhZGVyQnVpbGRlciA9IGVycm9yQmFyU2hhZGVyKCk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHNoYWRlckJ1aWxkZXIudmVydGV4KCkpLmZyYWdtZW50U2hhZGVyKHNoYWRlckJ1aWxkZXIuZnJhZ21lbnQoKSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICBsaW5lV2lkdGgocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKCkuYXBwZW5kQm9keShcIlxcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbi54ICs9IHhNb2RpZmllciAvIHVTY3JlZW4ueCAqIDIuMDtcXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24ueSArPSB5TW9kaWZpZXIgLyB1U2NyZWVuLnkgKiAyLjA7XFxuICAgICAgICAgICAgXCIpO1xuICAgICAgICBkZWNvcmF0ZShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbShudW1FbGVtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LmRlY29yYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb3JhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHlTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBwcm9ncmFtLCAnY29udGV4dCcsICdwaXhlbFJhdGlvJyk7XG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBsaW5lV2lkdGgsICdsaW5lV2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdoaWdoVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhSGlnaFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbG93VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTG93VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdiYW5kd2lkdGhBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQmFuZHdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkJyk7XG4gICAgICByZXR1cm4gZHJhdztcbiAgICB9KTtcblxuICAgIHZhciBjYW5kbGVzdGlja1NoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoY2FuZGxlc3RpY2suaGVhZGVyKS5hcHBlbmRCb2R5KGNhbmRsZXN0aWNrLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKGNhbmRsZXN0aWNrJDEuaGVhZGVyKS5hcHBlbmRCb2R5KGNhbmRsZXN0aWNrJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIGNhbmRsZXN0aWNrJDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2dyYW0gPSBwcm9ncmFtQnVpbGRlcigpLm1vZGUoZHJhd01vZGVzLlRSSUFOR0xFUykuc3ViSW5zdGFuY2VDb3VudCgxMik7XG4gICAgICB2YXIgeFNjYWxlID0gYmFzZVNjYWxlKCk7XG4gICAgICB2YXIgeVNjYWxlID0gYmFzZVNjYWxlKCk7XG4gICAgICB2YXIgbGluZVdpZHRoID0gbGluZVdpZHRoU2hhZGVyKCk7XG5cbiAgICAgIHZhciBkZWNvcmF0ZSA9IGZ1bmN0aW9uIGRlY29yYXRlKCkge307XG4gICAgICAvKlxuICAgICAgICogeC15IGNvb3JkaW5hdGUgdG8gbG9jYXRlIHRoZSBcImNvcm5lcnNcIiBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAqIFg6IC0xOiBMRUZULCAwOiBNSURETEUsIDE6IFJJR0hUXG4gICAgICAgKiBZOiAtMjogSElHSCwgLTE6IE9QRU4sIDE6IENMT1NFLCAyOiBMT1dcbiAgICAgICAqIFo6IC0xOiBMRUZULCAxOiBSSUdIVCAob25seSB2YWxpZCBmb3IgSElHSC9MT1cgY29ybmVycylcbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciBjb3JuZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5kaXZpc29yKDApLnNpemUoMykudHlwZSh0eXBlcy5CWVRFKS5kYXRhKFsvLyBWZXJ0aWNhbCBsaW5lXG4gICAgICBbMCwgMiwgMV0sIFswLCAyLCAtMV0sIFswLCAtMiwgLTFdLCBbMCwgLTIsIDFdLCAvLyBDZW50cmFsIGJveFxuICAgICAgWzEsIC0xLCAwXSwgWy0xLCAtMSwgMF0sIFstMSwgMSwgMF0sIFsxLCAxLCAwXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuZWxlbWVudEluZGljZXMoZWxlbWVudEluZGljZXMoWy8vIFZlcnRpY2FsIGxpbmVcbiAgICAgIDAsIDEsIDIsIDAsIDMsIDIsIC8vIENlbnRyYWwgYm94XG4gICAgICA0LCA1LCA2LCA0LCA3LCA2XSkpLmF0dHJpYnV0ZSgnYUNvcm5lcicsIGNvcm5lckF0dHJpYnV0ZSk7XG5cbiAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgc2hhZGVyQnVpbGRlciA9IGNhbmRsZXN0aWNrU2hhZGVyKCk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHNoYWRlckJ1aWxkZXIudmVydGV4KCkpLmZyYWdtZW50U2hhZGVyKHNoYWRlckJ1aWxkZXIuZnJhZ21lbnQoKSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICBsaW5lV2lkdGgocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKCkuYXBwZW5kQm9keShcIlxcbiAgICAgICAgICBnbF9Qb3NpdGlvbi54ICs9IHhNb2RpZmllciAvIHVTY3JlZW4ueCAqIDIuMDtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24ueSArPSB5TW9kaWZpZXIgLyB1U2NyZWVuLnkgKiAyLjA7XFxuICAgICAgICBcIik7XG4gICAgICAgIGRlY29yYXRlKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtKG51bUVsZW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYXcuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZWNvcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeFNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeVNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIHByb2dyYW0sICdjb250ZXh0JywgJ3BpeGVsUmF0aW8nKTtcbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIGxpbmVXaWR0aCwgJ2xpbmVXaWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nyb3NzVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ3Jvc3NWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ29wZW5WYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FPcGVuVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdoaWdoVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhSGlnaFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbG93VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTG93VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjbG9zZVZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNsb3NlVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdiYW5kd2lkdGhBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQmFuZHdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkJyk7XG4gICAgICByZXR1cm4gZHJhdztcbiAgICB9KTtcblxuICAgIHZhciBib3hQbG90U2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyQnVpbGRlcihmcmFnbWVudFNoYWRlckJhc2UpO1xuICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEhlYWRlcihib3hQbG90LmhlYWRlcikuYXBwZW5kQm9keShib3hQbG90LmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKGJveFBsb3QkMS5oZWFkZXIpLmFwcGVuZEJvZHkoYm94UGxvdCQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vICAgICAgICAgICAgLi0tLS0tLS4tLS0tLS0uXG4gICAgLy8gICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgzrJMMiAgICAgICAgICAgIM6yICAgICAgICAgICDOslIyXG4gICAgLy8gICAgIC4tLS0tLS0tLS0tLS0tLi0tLS0tLS0tLS0tLS5cbiAgICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgzrNMMiAgICAgICAgICAgIM6zICAgICAgICAgICDOs1IyXG4gICAgLy8gICAgIC4tLS0tLS0tLS0tLS0tLi0tLS0tLS0tLS0tLS5cbiAgICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICDOtEwyICAgICAgICAgICAgzrQgICAgICAgICAgIM60UjJcbiAgICAvLyAgICAgLi0tLS0tLS0tLS0tLS0uLS0tLS0tLS0tLS0tLlxuICAgIC8vICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICDOtUwxICAgICDOtSAgICAgzrVSMVxuICAgIC8vICAgICAgICAgICAgLi0tLS0tLS4tLS0tLS0uXG4gICAgLy8gTGluZSBkcmF3aW5nIG9yZGVyXG4gICAgLy8gzrFMMSAtPiDOsVIxXG4gICAgLy8gzrEgLT4gzrJcbiAgICAvLyDOskwyIC0+IM6yUjJcbiAgICAvLyDOs0wyIC0+IM6zUjJcbiAgICAvLyDOtEwyIC0+IM60UjJcbiAgICAvLyDOskwyIC0+IM60TDJcbiAgICAvLyDOslIyIC0+IM60UjJcbiAgICAvLyDOtCAtPiDOtVxuICAgIC8vIM61TDEgLT4gzrVSMVxuXG4gICAgdmFyIGJveFBsb3QkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1CdWlsZGVyKCkubW9kZShkcmF3TW9kZXMuVFJJQU5HTEVTKS5zdWJJbnN0YW5jZUNvdW50KDU0KTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVXaWR0aFNoYWRlcigpO1xuICAgICAgLypcbiAgICAgICAqIHgteSBjb29yZGluYXRlIHRvIGxvY2F0ZSB0aGUgXCJjb3JuZXJzXCIgb2YgdGhlIGVsZW1lbnQgKGllIGVycm9yYmFyKS4gVGhlIGB6YCBjb29yZGluYXRlIGxvY2F0ZXMgdGhlIGNvcm5lciByZWxhdGl2ZSB0byB0aGUgbGluZSAodGhpcyB0YWtlcyBsaW5lIHdpZHRoIGludG8gYWNjb3VudCkuXG4gICAgICAgKiBYOiAtMTogTEVGVCwgMDogTUlERExFLCAxOiBSSUdIVFxuICAgICAgICogWTogLTI6IEhJR0gsIC0xOiBVUFBFUiBRVUFSVElMRSwgMDogTUVESUFOLCAxOiBMT1dFUiBRVUFSVElMRSwgMjogTE9XXG4gICAgICAgKiBaOiBGb2xsb3dzIFggb3IgWSBjb252ZW50aW9uLCBkZXBlbmRpbmcgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBsaW5lIHRoYXQgdGhlIHZlcnRleCBpcyBwYXJ0IG9mLlxuICAgICAgICogVzogSW5kaWNhdG9yIHRvIGRldGVybWluZSBsaW5lIG9yaWVudGF0aW9uIChuZWVkZWQgYmVjYXVzZSBzb21lIGNvcm5lcnMgYXJlIHBhcnQgb2YgdHdvIGxpbmVzKS4gLSAwOiBWRVJUSUNBTCwgMTogSE9SSVpPTlRBTFxuICAgICAgICovXG5cbiAgICAgIHZhciBjb3JuZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5kaXZpc29yKDApLnNpemUoNCkudHlwZSh0eXBlcy5CWVRFKS5kYXRhKFsvLyBUb3AgY2FwIGxpbmVcbiAgICAgIFstMSwgLTIsIC0xLCAxXSwgWzEsIC0yLCAtMSwgMV0sIFsxLCAtMiwgMSwgMV0sIFstMSwgLTIsIDEsIDFdLCAvLyBUb3Agd2hpc2tlciBsaW5lXG4gICAgICBbMCwgLTIsIC0xLCAwXSwgWzAsIC0yLCAxLCAwXSwgWzAsIC0xLCAxLCAwXSwgWzAsIC0xLCAtMSwgMF0sIC8vIFVwcGVyIHF1YXJ0aWxlIGxpbmVcbiAgICAgIFstMSwgLTEsIC0xLCAxXSwgWzEsIC0xLCAtMSwgMV0sIFsxLCAtMSwgMSwgMV0sIFstMSwgLTEsIDEsIDFdLCAvLyBNZWRpYW4gbGluZVxuICAgICAgWy0xLCAwLCAtMSwgMV0sIFsxLCAwLCAtMSwgMV0sIFsxLCAwLCAxLCAxXSwgWy0xLCAwLCAxLCAxXSwgLy8gTG93ZXIgcXVhcnRpbGUgbGluZVxuICAgICAgWy0xLCAxLCAtMSwgMV0sIFsxLCAxLCAtMSwgMV0sIFsxLCAxLCAxLCAxXSwgWy0xLCAxLCAxLCAxXSwgLy8gTGVmdCBib3ggdmVydGljYWwgbGluZVxuICAgICAgWy0xLCAtMSwgLTEsIDBdLCBbLTEsIC0xLCAxLCAwXSwgWy0xLCAxLCAxLCAwXSwgWy0xLCAxLCAtMSwgMF0sIC8vIFJpZ2h0IGJveCB2ZXJ0aWNhbCBsaW5lXG4gICAgICBbMSwgLTEsIC0xLCAwXSwgWzEsIC0xLCAxLCAwXSwgWzEsIDEsIDEsIDBdLCBbMSwgMSwgLTEsIDBdLCAvLyBCb3R0b20gd2hpc2tlciBsaW5lXG4gICAgICBbMCwgMiwgLTEsIDBdLCBbMCwgMiwgMSwgMF0sIFswLCAxLCAxLCAwXSwgWzAsIDEsIC0xLCAwXSwgLy8gQm90dG9tIGNhcCBsaW5lXG4gICAgICBbLTEsIDIsIC0xLCAxXSwgWzEsIDIsIC0xLCAxXSwgWzEsIDIsIDEsIDFdLCBbLTEsIDIsIDEsIDFdXSk7XG4gICAgICBwcm9ncmFtLmJ1ZmZlcnMoKS5lbGVtZW50SW5kaWNlcyhlbGVtZW50SW5kaWNlcyhbLy8gVG9wIGNhcCBsaW5lXG4gICAgICAwLCAxLCAyLCAwLCAyLCAzLCAvLyBUb3Agd2hpc2tlciBsaW5lXG4gICAgICA0LCA1LCA2LCA0LCA2LCA3LCAvLyBVcHBlciBxdWFydGlsZSBsaW5lXG4gICAgICA4LCA5LCAxMCwgOCwgMTAsIDExLCAvLyBNZWRpYW4gbGluZVxuICAgICAgMTIsIDEzLCAxNCwgMTIsIDE0LCAxNSwgLy8gTG93ZXIgcXVhcnRpbGUgbGluZVxuICAgICAgMTYsIDE3LCAxOCwgMTYsIDE4LCAxOSwgLy8gTGVmdCBib3ggdmVydGljYWwgbGluZVxuICAgICAgMjAsIDIxLCAyMiwgMjAsIDIyLCAyMywgLy8gUmlnaHQgYm94IHZlcnRpY2FsIGxpbmVcbiAgICAgIDI0LCAyNSwgMjYsIDI0LCAyNiwgMjcsIC8vIEJvdHRvbSB3aGlza2VyIGxpbmVcbiAgICAgIDI4LCAyOSwgMzAsIDI4LCAzMCwgMzEsIC8vIEJvdHRvbSBjYXAgbGluZVxuICAgICAgMzIsIDMzLCAzNCwgMzIsIDM0LCAzNV0pKS5hdHRyaWJ1dGUoJ2FDb3JuZXInLCBjb3JuZXJBdHRyaWJ1dGUpO1xuXG4gICAgICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcobnVtRWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHNoYWRlckJ1aWxkZXIgPSBib3hQbG90U2hhZGVyKCk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHNoYWRlckJ1aWxkZXIudmVydGV4KCkpLmZyYWdtZW50U2hhZGVyKHNoYWRlckJ1aWxkZXIuZnJhZ21lbnQoKSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICBsaW5lV2lkdGgocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKCkuYXBwZW5kQm9keShcIlxcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnggKz0geE1vZGlmaWVyIC8gdVNjcmVlbi54ICogMi4wO1xcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnkgKz0geU1vZGlmaWVyIC8gdVNjcmVlbi55ICogMi4wO1xcbiAgICAgICAgXCIpO1xuICAgICAgICBkZWNvcmF0ZShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbShudW1FbGVtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LmRlY29yYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb3JhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHlTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBwcm9ncmFtLCAnY29udGV4dCcsICdwaXhlbFJhdGlvJyk7XG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBsaW5lV2lkdGgsICdsaW5lV2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdoaWdoVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhSGlnaFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAndXBwZXJRdWFydGlsZVZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYVVwcGVyUXVhcnRpbGVWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ21lZGlhblZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYU1lZGlhblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbG93ZXJRdWFydGlsZVZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUxvd2VyUXVhcnRpbGVWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2xvd1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUxvd1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFuZHdpZHRoQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUJhbmR3aWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2NhcEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDYXBXaWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSk7XG5cbiAgICB2YXIgYWRqYWNlbnRBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1pbk9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBtYXhPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIGlmIChtaW5PZmZzZXQgPiAwIHx8IG1heE9mZnNldCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IHZhbHVlcyAoXCIuY29uY2F0KG1pbk9mZnNldCwgXCIgJiBcIikuY29uY2F0KG1heE9mZnNldCwgXCIpIG11c3Qgc3RyYWRkbGUgMCBcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFzZSA9IGJhc2VBdHRyaWJ1dGVCdWlsZGVyKCk7XG4gICAgICB2YXIgcHJvamVjdG9yID0gYXR0cmlidXRlUHJvamVjdG9yKCk7XG5cbiAgICAgIHZhciBhZGphY2VudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGFkamFjZW50QXR0cmlidXRlKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIHZhciBlbGVtZW50U2l6ZSA9IGFkamFjZW50QXR0cmlidXRlLnNpemUoKSAqIGxlbmd0aChhZGphY2VudEF0dHJpYnV0ZS50eXBlKCkpO1xuICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gTWF0aC5hYnMobWluT2Zmc2V0KSAqIGVsZW1lbnRTaXplO1xuICAgICAgICBiYXNlLm9mZnNldChidWZmZXJPZmZzZXQpLnNpemUoYWRqYWNlbnRBdHRyaWJ1dGUuc2l6ZSgpKS50eXBlKGFkamFjZW50QXR0cmlidXRlLnR5cGUoKSk7XG4gICAgICAgIGJhc2UocHJvZ3JhbUJ1aWxkZXIpO1xuXG4gICAgICAgIGlmICghcHJvamVjdG9yLmRpcnR5KCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvamVjdGVkRGF0YSA9IHByb2plY3RvcigpO1xuICAgICAgICB2YXIgYnVmZmVyUGFkZGluZyA9IG1heE9mZnNldCAqIGVsZW1lbnRTaXplO1xuICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyT2Zmc2V0ICsgcHJvamVjdGVkRGF0YS5sZW5ndGggKiBsZW5ndGgoYWRqYWNlbnRBdHRyaWJ1dGUudHlwZSgpKSArIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIHZhciBnbCA9IHByb2dyYW1CdWlsZGVyLmNvbnRleHQoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJhc2UuYnVmZmVyKCkpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyTGVuZ3RoLCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyT2Zmc2V0LCBwcm9qZWN0ZWREYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIGFkamFjZW50QXR0cmlidXRlLm9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKG1pbk9mZnNldCA+IG9mZnNldCB8fCBvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgb2Zmc2V0IFwiLmNvbmNhdChvZmZzZXQsIFwiIGV4Y2VlZHMgYm91bmRzIChcIikuY29uY2F0KG1pbk9mZnNldCwgXCIgJiBcIikuY29uY2F0KG1heE9mZnNldCwgXCIpIFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gb2Zmc2V0QXR0cmlidXRlKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgICAgYmFzZS5vZmZzZXQoKG9mZnNldCAtIG1pbk9mZnNldCkgKiBhZGphY2VudEF0dHJpYnV0ZS5zaXplKCkgKiBsZW5ndGgoYWRqYWNlbnRBdHRyaWJ1dGUudHlwZSgpKSk7XG4gICAgICAgICAgYmFzZShwcm9ncmFtQnVpbGRlcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZDNmY1JlYmluZC5yZWJpbmQob2Zmc2V0QXR0cmlidXRlLCBhZGphY2VudEF0dHJpYnV0ZSwgJ2NsZWFyJywgJ2xvY2F0aW9uJyk7XG4gICAgICAgIHJldHVybiBvZmZzZXRBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBhZGphY2VudEF0dHJpYnV0ZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYmFzZS5idWZmZXIobnVsbCk7XG4gICAgICAgIHByb2plY3Rvci5jbGVhcigpO1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoYWRqYWNlbnRBdHRyaWJ1dGUsIGJhc2UsICdub3JtYWxpemVkJywgJ2xvY2F0aW9uJywgJ2Rpdmlzb3InKTtcbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGFkamFjZW50QXR0cmlidXRlLCBwcm9qZWN0b3IsICdkYXRhJywgJ3ZhbHVlJywgJ3NpemUnLCAndHlwZScpO1xuICAgICAgcmV0dXJuIGFkamFjZW50QXR0cmlidXRlO1xuICAgIH0pO1xuXG4gICAgdmFyIGxpbmVhciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmFzZSA9IGJhc2VTY2FsZSgpO1xuXG4gICAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gcHJlZml4KGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gXCJsaW5lYXJcIi5jb25jYXQoY29tcG9uZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHByb2dyYW1CdWlsZGVyLCBpZGVudGlmaWVyLCBjb21wb25lbnQpIHtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIudmVydGV4U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoXCJ1bmlmb3JtIHZlYzQgXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIk9mZnNldDtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJTY2FsZTtcIikpLmFwcGVuZEJvZHkoXCJcIi5jb25jYXQoaWRlbnRpZmllciwgXCIgPSBcIikuY29uY2F0KGlkZW50aWZpZXIsIFwiICsgXCIpLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJPZmZzZXQ7XCIpKS5hcHBlbmRCb2R5KFwiXCIuY29uY2F0KGlkZW50aWZpZXIsIFwiID0gXCIpLmNvbmNhdChpZGVudGlmaWVyLCBcIiAqIFwiKS5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGU7XCIpKTtcbiAgICAgICAgdmFyIGRvbWFpblNpemUgPSBiYXNlLmRvbWFpbigpWzFdIC0gYmFzZS5kb21haW4oKVswXTtcbiAgICAgICAgdmFyIHJhbmdlU2l6ZSA9IGJhc2UucmFuZ2UoKVsxXSAtIGJhc2UucmFuZ2UoKVswXTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGJhc2UucmFuZ2UoKVswXSAqIChkb21haW5TaXplIC8gcmFuZ2VTaXplKSAtIGJhc2UuZG9tYWluKClbMF07XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHJhbmdlU2l6ZSAvIGRvbWFpblNpemU7XG4gICAgICAgIHZhciBvZmZzZXQgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIHZhciBzY2FsZSA9IFsxLCAxLCAxLCAxXTtcbiAgICAgICAgb2Zmc2V0W2NvbXBvbmVudF0gPSB0cmFuc2xhdGU7XG4gICAgICAgIHNjYWxlW2NvbXBvbmVudF0gPSBzY2FsZUZhY3RvcjtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuYnVmZmVycygpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiT2Zmc2V0XCIpLCB1bmlmb3JtKG9mZnNldCkpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGVcIiksIHVuaWZvcm0oc2NhbGUpKTtcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kQWxsKHNjYWxlLCBiYXNlKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9KTtcblxuICAgIHZhciBsb2cgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGdsQmFzZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIGJhc2UgPSAxMDtcblxuICAgICAgZnVuY3Rpb24gbG9nKHYsIGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMTAodikgLyBNYXRoLmxvZzEwKGJhc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gcHJlZml4KGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gXCJsb2dcIi5jb25jYXQoY29tcG9uZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHByb2dyYW1CdWlsZGVyLCBpZGVudGlmaWVyLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGxvZ1BhcnQgPSBcIlwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJPZmZzZXQgKyAoXCIpLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJTY2FsZSAqIGNsYW1wKGxvZyhcIikuY29uY2F0KGlkZW50aWZpZXIsIFwiKSAvIGxvZyhcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkJhc2UpLCAtaW5mLCBpbmYpKVwiKTtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIudmVydGV4U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoXCJ1bmlmb3JtIHZlYzQgXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIk9mZnNldDtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJTY2FsZTtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJJbmNsdWRlO1wiKSkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoXCJ1bmlmb3JtIGZsb2F0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJCYXNlO1wiKSkuYXBwZW5kQm9keShcIlwiLmNvbmNhdChpZGVudGlmaWVyLCBcIiA9IChcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkluY2x1ZGUgKiAoXCIpLmNvbmNhdChsb2dQYXJ0LCBcIikpICsgKCgxLjAgLSBcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkluY2x1ZGUpICogXCIpLmNvbmNhdChpZGVudGlmaWVyLCBcIik7XCIpKTtcbiAgICAgICAgdmFyIGRvbWFpblNpemUgPSBsb2coZ2xCYXNlLmRvbWFpbigpWzFdLCBiYXNlKSAtIGxvZyhnbEJhc2UuZG9tYWluKClbMF0sIGJhc2UpO1xuICAgICAgICB2YXIgcmFuZ2VTaXplID0gZ2xCYXNlLnJhbmdlKClbMV0gLSBnbEJhc2UucmFuZ2UoKVswXTtcbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gcmFuZ2VTaXplIC8gZG9tYWluU2l6ZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGdsQmFzZS5yYW5nZSgpWzBdIC0gc2NhbGVGYWN0b3IgKiBsb2coZ2xCYXNlLmRvbWFpbigpWzBdLCBiYXNlKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdmFyIHNjYWxlID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgb2Zmc2V0W2NvbXBvbmVudF0gPSB0cmFuc2xhdGU7XG4gICAgICAgIHNjYWxlW2NvbXBvbmVudF0gPSBzY2FsZUZhY3RvcjtcbiAgICAgICAgaW5jbHVkZVtjb21wb25lbnRdID0gMTtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuYnVmZmVycygpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiT2Zmc2V0XCIpLCB1bmlmb3JtKG9mZnNldCkpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGVcIiksIHVuaWZvcm0oc2NhbGUpKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkluY2x1ZGVcIiksIHVuaWZvcm0oaW5jbHVkZSkpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiQmFzZVwiKSwgdW5pZm9ybShiYXNlKSk7XG4gICAgICB9O1xuXG4gICAgICBzY2FsZS5iYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kQWxsKHNjYWxlLCBnbEJhc2UpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0pO1xuXG4gICAgdmFyIHBvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmFzZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIGV4cG9uZW50ID0gMTtcblxuICAgICAgZnVuY3Rpb24gcG93KGIsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihiKSAqIE1hdGgucG93KE1hdGguYWJzKGIpLCBlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZWZpeCA9IGZ1bmN0aW9uIHByZWZpeChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIFwicG93XCIuY29uY2F0KGNvbXBvbmVudCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShwcm9ncmFtQnVpbGRlciwgaWRlbnRpZmllciwgY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBwb3dQYXJ0ID0gXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiT2Zmc2V0ICsgKFwiKS5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGUgKiBzaWduKFwiKS5jb25jYXQoaWRlbnRpZmllciwgXCIpICogcG93KGFicyhcIikuY29uY2F0KGlkZW50aWZpZXIsIFwiKSwgdmVjNChcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkV4cCkpKVwiKTtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIudmVydGV4U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoXCJ1bmlmb3JtIHZlYzQgXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIk9mZnNldDtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJTY2FsZTtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJJbmNsdWRlO1wiKSkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoXCJ1bmlmb3JtIGZsb2F0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJFeHA7XCIpKS5hcHBlbmRCb2R5KFwiXCIuY29uY2F0KGlkZW50aWZpZXIsIFwiID0gKFwiKS5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiSW5jbHVkZSAqIChcIikuY29uY2F0KHBvd1BhcnQsIFwiKSkgKyAoKDEuMCAtIFwiKS5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiSW5jbHVkZSkgKiBcIikuY29uY2F0KGlkZW50aWZpZXIsIFwiKTtcIikpO1xuICAgICAgICB2YXIgZG9tYWluU2l6ZSA9IHBvdyhiYXNlLmRvbWFpbigpWzFdLCBleHBvbmVudCkgLSBwb3coYmFzZS5kb21haW4oKVswXSwgZXhwb25lbnQpO1xuICAgICAgICB2YXIgcmFuZ2VTaXplID0gYmFzZS5yYW5nZSgpWzFdIC0gYmFzZS5yYW5nZSgpWzBdO1xuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSByYW5nZVNpemUgLyBkb21haW5TaXplO1xuICAgICAgICB2YXIgdHJhbnNsYXRlID0gYmFzZS5yYW5nZSgpWzBdIC0gc2NhbGVGYWN0b3IgKiBwb3coYmFzZS5kb21haW4oKVswXSwgZXhwb25lbnQpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB2YXIgc2NhbGUgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIHZhciBpbmNsdWRlID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBvZmZzZXRbY29tcG9uZW50XSA9IHRyYW5zbGF0ZTtcbiAgICAgICAgc2NhbGVbY29tcG9uZW50XSA9IHNjYWxlRmFjdG9yO1xuICAgICAgICBpbmNsdWRlW2NvbXBvbmVudF0gPSAxO1xuICAgICAgICBwcm9ncmFtQnVpbGRlci5idWZmZXJzKCkudW5pZm9ybShcIlwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJPZmZzZXRcIiksIHVuaWZvcm0ob2Zmc2V0KSkudW5pZm9ybShcIlwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJTY2FsZVwiKSwgdW5pZm9ybShzY2FsZSkpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiSW5jbHVkZVwiKSwgdW5pZm9ybShpbmNsdWRlKSkudW5pZm9ybShcIlwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJFeHBcIiksIHVuaWZvcm0oZXhwb25lbnQpKTtcbiAgICAgIH07XG5cbiAgICAgIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb25lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBleHBvbmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmRBbGwoc2NhbGUsIGJhc2UpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBzY2FsZSB0eXBlLlxuXG4gICAgdmFyIHNjYWxlTGluZWFyQ29weSA9IGQzU2NhbGUuc2NhbGVMaW5lYXIoKS5jb3B5LnRvU3RyaW5nKCk7XG4gICAgdmFyIHNjYWxlTG9nQ29weSA9IGQzU2NhbGUuc2NhbGVMb2coKS5jb3B5LnRvU3RyaW5nKCk7XG4gICAgdmFyIHNjYWxlUG93Q29weSA9IGQzU2NhbGUuc2NhbGVQb3coKS5jb3B5LnRvU3RyaW5nKCk7XG4gICAgdmFyIHNjYWxlVGltZUNvcHkgPSBkM1NjYWxlLnNjYWxlVGltZSgpLmNvcHkudG9TdHJpbmcoKTsgLy8gYWx3YXlzIHJldHVybiB0aGUgc2FtZSByZWZlcmVuY2UgdG8gaGludCB0byBjb25zdW1lcnMgdGhhdFxuICAgIC8vIGl0IGlzIGEgcHVyZSBmdW5jdGlvblxuXG4gICAgdmFyIGlkZW50aXR5ID0gZDNTY2FsZS5zY2FsZUlkZW50aXR5KCk7IC8vIG9mZnNldCBkYXRlIHZhbHVlcyB0byBtYWtlIHRoZSBtb3N0IG9mIHRoZSBmbG9hdDMyIHByZWNpc2lvblxuXG4gICAgdmFyIGVwb2NoID0gRGF0ZS5ub3coKTtcblxuICAgIHZhciByZWVwb2NoID0gZnVuY3Rpb24gcmVlcG9jaChkKSB7XG4gICAgICByZXR1cm4gZCAtIGVwb2NoO1xuICAgIH07XG5cbiAgICB2YXIgc2NhbGVNYXBwZXIgPSAoZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICBzd2l0Y2ggKHNjYWxlLmNvcHkudG9TdHJpbmcoKSkge1xuICAgICAgICBjYXNlIHNjYWxlTGluZWFyQ29weTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzY2FsZTogaWRlbnRpdHksXG4gICAgICAgICAgICAgIHdlYmdsU2NhbGU6IGxpbmVhcigpLmRvbWFpbihzY2FsZS5kb21haW4oKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2Ugc2NhbGVUaW1lQ29weTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzY2FsZTogcmVlcG9jaCxcbiAgICAgICAgICAgICAgd2ViZ2xTY2FsZTogbGluZWFyKCkuZG9tYWluKHNjYWxlLmRvbWFpbigpLm1hcChyZWVwb2NoKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2Ugc2NhbGVMb2dDb3B5OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjYWxlOiBpZGVudGl0eSxcbiAgICAgICAgICAgICAgd2ViZ2xTY2FsZTogbG9nKCkuZG9tYWluKHNjYWxlLmRvbWFpbigpKS5iYXNlKHNjYWxlLmJhc2UoKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2Ugc2NhbGVQb3dDb3B5OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjYWxlOiBpZGVudGl0eSxcbiAgICAgICAgICAgICAgd2ViZ2xTY2FsZTogcG93KCkuZG9tYWluKHNjYWxlLmRvbWFpbigpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBhbHdheXMgcmV0dXJuIGEgY29weSBvZiB0aGUgc2NhbGUgdG8gaGludCB0byBjb25zdW1lcnNcbiAgICAgICAgICAgIC8vIHRoYXQgaXQgbWF5IGJlIGFuIGltcHVyZSBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLmNvcHkoKSxcbiAgICAgICAgICAgICAgd2ViZ2xTY2FsZTogbGluZWFyKCkuZG9tYWluKHNjYWxlLnJhbmdlKCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBzcXVhcmVQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoc3F1YXJlLmhlYWRlcikuYXBwZW5kQm9keShzcXVhcmUuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoc3F1YXJlJDEuaGVhZGVyKS5hcHBlbmRCb2R5KHNxdWFyZSQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciB0cmlhbmdsZVBvaW50U2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyQnVpbGRlcihmcmFnbWVudFNoYWRlckJhc2UpO1xuICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEhlYWRlcih0cmlhbmdsZS5oZWFkZXIpLmFwcGVuZEJvZHkodHJpYW5nbGUuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIodHJpYW5nbGUkMS5oZWFkZXIpLmFwcGVuZEJvZHkodHJpYW5nbGUkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgY3Jvc3NQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoY3Jvc3MuaGVhZGVyKS5hcHBlbmRCb2R5KGNyb3NzLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKGNyb3NzJDEuaGVhZGVyKS5hcHBlbmRCb2R5KGNyb3NzJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIGRpYW1vbmRQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoZGlhbW9uZC5oZWFkZXIpLmFwcGVuZEJvZHkoZGlhbW9uZC5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihkaWFtb25kJDEuaGVhZGVyKS5hcHBlbmRCb2R5KGRpYW1vbmQkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgc3RhclBvaW50U2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyQnVpbGRlcihmcmFnbWVudFNoYWRlckJhc2UpO1xuICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEhlYWRlcihzdGFyLmhlYWRlcikuYXBwZW5kQm9keShzdGFyLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKHN0YXIkMS5oZWFkZXIpLmFwcGVuZEJvZHkoc3RhciQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciB3eWVQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIod3llLmhlYWRlcikuYXBwZW5kQm9keSh3eWUuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIod3llJDEuaGVhZGVyKS5hcHBlbmRCb2R5KHd5ZSQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBzeW1ib2xNYXBwZXIgPSAoZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgICAgY2FzZSBkM1NoYXBlLnN5bWJvbENpcmNsZTpcbiAgICAgICAgICByZXR1cm4gY2lyY2xlUG9pbnRTaGFkZXIoKTtcblxuICAgICAgICBjYXNlIGQzU2hhcGUuc3ltYm9sU3F1YXJlOlxuICAgICAgICAgIHJldHVybiBzcXVhcmVQb2ludFNoYWRlcigpO1xuXG4gICAgICAgIGNhc2UgZDNTaGFwZS5zeW1ib2xUcmlhbmdsZTpcbiAgICAgICAgICByZXR1cm4gdHJpYW5nbGVQb2ludFNoYWRlcigpO1xuXG4gICAgICAgIGNhc2UgZDNTaGFwZS5zeW1ib2xDcm9zczpcbiAgICAgICAgICByZXR1cm4gY3Jvc3NQb2ludFNoYWRlcigpO1xuXG4gICAgICAgIGNhc2UgZDNTaGFwZS5zeW1ib2xEaWFtb25kOlxuICAgICAgICAgIHJldHVybiBkaWFtb25kUG9pbnRTaGFkZXIoKTtcblxuICAgICAgICBjYXNlIGQzU2hhcGUuc3ltYm9sU3RhcjpcbiAgICAgICAgICByZXR1cm4gc3RhclBvaW50U2hhZGVyKCk7XG5cbiAgICAgICAgY2FzZSBkM1NoYXBlLnN5bWJvbFd5ZTpcbiAgICAgICAgICByZXR1cm4gd3llUG9pbnRTaGFkZXIoKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXNlZCBzeW1ib2w6IFwiLmNvbmNhdChzeW1ib2wpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjb25zdGFudEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgYmFzZSA9IGJhc2VBdHRyaWJ1dGVCdWlsZGVyKCkuZGl2aXNvcigxKTtcbiAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgIHZhciBkaXJ0eSA9IHRydWU7XG5cbiAgICAgIHZhciBjb25zdGFudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGNvbnN0YW50QXR0cmlidXRlKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIGJhc2UocHJvZ3JhbUJ1aWxkZXIpO1xuXG4gICAgICAgIGlmICghZGlydHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYW4gYXJyYXksIHJlY2VpdmVkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IGJhc2Uuc2l6ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYXJyYXkgb2YgbGVuZ3RoOiBcIi5jb25jYXQoYmFzZS5zaXplKCksIFwiLCByZWNpZXZlZCBhcnJheSBvZiBsZW5ndGg6IFwiKS5jb25jYXQodmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtQnVpbGRlci5jb250ZXh0KCk7XG4gICAgICAgIGdsW1widmVydGV4QXR0cmliXCIuY29uY2F0KHZhbHVlLmxlbmd0aCwgXCJmdlwiKV0oYmFzZS5sb2NhdGlvbigpLCB2YWx1ZSk7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShiYXNlLmxvY2F0aW9uKCkpO1xuICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgY29uc3RhbnRBdHRyaWJ1dGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0YW50QXR0cmlidXRlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY29uc3RhbnRBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChjb25zdGFudEF0dHJpYnV0ZSwgYmFzZSwgJ25vcm1hbGl6ZWQnLCAnc2l6ZScsICdsb2NhdGlvbicpO1xuICAgICAgcmV0dXJuIGNvbnN0YW50QXR0cmlidXRlO1xuICAgIH0pO1xuXG4gICAgdmFyIGZpbGxDb2xvciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFswLCAwLCAwLCAxXTtcbiAgICAgIHZhciBwcm9qZWN0ZWRBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5zaXplKDQpO1xuICAgICAgdmFyIHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgdmFyIGRpcnR5ID0gdHJ1ZTtcblxuICAgICAgdmFyIGZpbGxDb2xvciQyID0gZnVuY3Rpb24gZmlsbENvbG9yJDIocHJvZ3JhbUJ1aWxkZXIpIHtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIudmVydGV4U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoZmlsbENvbG9yLmhlYWRlcikuYXBwZW5kQm9keUlmTm90RXhpc3RzKGZpbGxDb2xvci5ib2R5KTtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuZnJhZ21lbnRTaGFkZXIoKS5hcHBlbmRIZWFkZXJJZk5vdEV4aXN0cyhmaWxsQ29sb3IkMS5oZWFkZXIpLmFwcGVuZEJvZHlJZk5vdEV4aXN0cyhmaWxsQ29sb3IkMS5ib2R5KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9ncmFtQnVpbGRlci5idWZmZXJzKCkuYXR0cmlidXRlKCdhRmlsbENvbG9yJywgY29uc3RhbnRBdHRyaWJ1dGUodmFsdWUpLnNpemUoNCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICghZGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFRoZSBmb2xsb3dpbmcgbGluZSBpcyBleHBlbnNpdmUgYW5kIGlzIHRoZSBvbmUgd2Ugd2FudCB0byBza2lwLFxuICAgICAgICAgIC8vIHRoZSByZXN0IGFyZW4ndC5cblxuXG4gICAgICAgICAgcHJvamVjdGVkQXR0cmlidXRlLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgICBwcm9ncmFtQnVpbGRlci5idWZmZXJzKCkuYXR0cmlidXRlKCdhRmlsbENvbG9yJywgcHJvamVjdGVkQXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBhbiBhcnJheSBvciBmdW5jdGlvbiwgcmVjZWl2ZWQgXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgZmlsbENvbG9yJDIudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsbENvbG9yJDI7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChmaWxsQ29sb3IkMiwgcHJvamVjdGVkQXR0cmlidXRlLCAnZGF0YScpO1xuICAgICAgcmV0dXJuIGZpbGxDb2xvciQyO1xuICAgIH0pO1xuXG4gICAgdmFyIHN0cm9rZUNvbG9yJDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogWzAsIDAsIDAsIDFdO1xuICAgICAgdmFyIHByb2plY3RlZEF0dHJpYnV0ZSA9IGF0dHJpYnV0ZSgpLnNpemUoNCk7XG4gICAgICB2YXIgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICB2YXIgZGlydHkgPSB0cnVlO1xuXG4gICAgICB2YXIgc3Ryb2tlQ29sb3IkMiA9IGZ1bmN0aW9uIHN0cm9rZUNvbG9yJDIocHJvZ3JhbUJ1aWxkZXIpIHtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIudmVydGV4U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoc3Ryb2tlQ29sb3IuaGVhZGVyKS5hcHBlbmRCb2R5SWZOb3RFeGlzdHMoc3Ryb2tlQ29sb3IuYm9keSk7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLmZyYWdtZW50U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoc3Ryb2tlQ29sb3IkMS5oZWFkZXIpLmFwcGVuZEJvZHlJZk5vdEV4aXN0cyhzdHJva2VDb2xvciQxLmJvZHkpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHByb2dyYW1CdWlsZGVyLmJ1ZmZlcnMoKS5hdHRyaWJ1dGUoJ2FTdHJva2VDb2xvcicsIGNvbnN0YW50QXR0cmlidXRlKHZhbHVlKS5zaXplKDQpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAoIWRpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBUaGUgZm9sbG93aW5nIGxpbmUgaXMgZXhwZW5zaXZlIGFuZCBpcyB0aGUgb25lIHdlIHdhbnQgdG8gc2tpcCxcbiAgICAgICAgICAvLyB0aGUgcmVzdCBhcmVuJ3QuXG5cblxuICAgICAgICAgIHByb2plY3RlZEF0dHJpYnV0ZS52YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuYnVmZmVycygpLmF0dHJpYnV0ZSgnYVN0cm9rZUNvbG9yJywgcHJvamVjdGVkQXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBhbiBhcnJheSBvciBmdW5jdGlvbiwgcmVjZWl2ZWQgXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgc3Ryb2tlQ29sb3IkMi52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJva2VDb2xvciQyO1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoc3Ryb2tlQ29sb3IkMiwgcHJvamVjdGVkQXR0cmlidXRlLCAnZGF0YScpO1xuICAgICAgcmV0dXJuIHN0cm9rZUNvbG9yJDI7XG4gICAgfSk7XG5cbiAgICBleHBvcnRzLndlYmdsQWRqYWNlbnRBdHRyaWJ1dGUgPSBhZGphY2VudEF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLndlYmdsQXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgIGV4cG9ydHMud2ViZ2xCYXNlQXR0cmlidXRlID0gYmFzZUF0dHJpYnV0ZUJ1aWxkZXI7XG4gICAgZXhwb3J0cy53ZWJnbEJ1ZmZlckJ1aWxkZXIgPSBidWZmZXJCdWlsZGVyO1xuICAgIGV4cG9ydHMud2ViZ2xFbGVtZW50SW5kaWNlcyA9IGVsZW1lbnRJbmRpY2VzO1xuICAgIGV4cG9ydHMud2ViZ2xGaWxsQ29sb3IgPSBmaWxsQ29sb3IkMjtcbiAgICBleHBvcnRzLndlYmdsUHJvZ3JhbUJ1aWxkZXIgPSBwcm9ncmFtQnVpbGRlcjtcbiAgICBleHBvcnRzLndlYmdsU2NhbGVMaW5lYXIgPSBsaW5lYXI7XG4gICAgZXhwb3J0cy53ZWJnbFNjYWxlTG9nID0gbG9nO1xuICAgIGV4cG9ydHMud2ViZ2xTY2FsZU1hcHBlciA9IHNjYWxlTWFwcGVyO1xuICAgIGV4cG9ydHMud2ViZ2xTY2FsZVBvdyA9IHBvdztcbiAgICBleHBvcnRzLndlYmdsU2VyaWVzQXJlYSA9IGFyZWEkMjtcbiAgICBleHBvcnRzLndlYmdsU2VyaWVzQmFyID0gYmFyJDI7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc0JveFBsb3QgPSBib3hQbG90JDI7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc0NhbmRsZXN0aWNrID0gY2FuZGxlc3RpY2skMjtcbiAgICBleHBvcnRzLndlYmdsU2VyaWVzRXJyb3JCYXIgPSBlcnJvckJhciQyO1xuICAgIGV4cG9ydHMud2ViZ2xTZXJpZXNMaW5lID0gbGluZSQxO1xuICAgIGV4cG9ydHMud2ViZ2xTZXJpZXNPaGxjID0gb2hsYyQyO1xuICAgIGV4cG9ydHMud2ViZ2xTZXJpZXNQb2ludCA9IHBvaW50O1xuICAgIGV4cG9ydHMud2ViZ2xTaGFkZXJCdWlsZGVyID0gc2hhZGVyQnVpbGRlcjtcbiAgICBleHBvcnRzLndlYmdsU3Ryb2tlQ29sb3IgPSBzdHJva2VDb2xvciQyO1xuICAgIGV4cG9ydHMud2ViZ2xTeW1ib2xNYXBwZXIgPSBzeW1ib2xNYXBwZXI7XG4gICAgZXhwb3J0cy53ZWJnbFR5cGVzID0gdHlwZXM7XG4gICAgZXhwb3J0cy53ZWJnbFVuaWZvcm0gPSB1bmlmb3JtO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
(self.webpackChunkneo_offscreen_canvas_demo=self.webpackChunkneo_offscreen_canvas_demo||[]).push([[537],{537:function(e,n,t){!function(e,n,t,a){"use strict";var r=function(){var e=[0,1],n=[-1,1],t=function(){};return t.domain=function(){return arguments.length?(e=arguments.length<=0?void 0:arguments[0],t):e},t.range=function(){return arguments.length?(n=arguments.length<=0?void 0:arguments[0],t):n},t},i=function(){var e={},n={},t=null,a=function(a,r){var i=a.context();Object.keys(e).forEach((function(n){var t=e[n];if("function"!=typeof t)throw new Error("Expected an attribute for ".concat(n,", found ").concat(t));var o=i.getAttribLocation(r,n);t.location(o)(a)})),Object.keys(n).forEach((function(e){var t=n[e];if("function"!=typeof t)throw new Error("Expected a uniform for ".concat(e,", found ").concat(t));var o=i.getUniformLocation(r,e);t.location(o)(a)})),null!==t&&t(a)};return a.flush=function(){Object.values(e).forEach((function(e){return e.clear()})),Object.values(n).forEach((function(e){return e.clear()})),null!==t&&t.clear()},a.attribute=function(){for(var n=arguments.length,t=new Array(n),r=0;r<n;r++)t[r]=arguments[r];return 1===t.length?e[t[0]]:(e[t[0]]=t[1],a)},a.uniform=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return 1===t.length?n[t[0]]:(n[t[0]]=t[1],a)},a.elementIndices=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],a):t},a},o=function(e){var n=-1,t=e,a=!0,r=function(e){if(a){var r=e.context();if(Array.isArray(t))switch(t.length){case 1:r.uniform1fv(n,t);break;case 2:r.uniform2fv(n,t);break;case 3:r.uniform3fv(n,t);break;case 4:r.uniform4fv(n,t);break;default:throw new Error("Uniform supports up to 4 elements. ".concat(t.length," provided."))}else r.uniform1f(n,t);a=!1}};return r.clear=function(){a=!0},r.location=function(){return arguments.length?(n!==(arguments.length<=0?void 0:arguments[0])&&(n=arguments.length<=0?void 0:arguments[0],a=!0),r):n},r.data=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],a=!0,r):t},r},u=0,l=4,f=function(){var e=null,n=null,t=null,a=null,r=null,u=null,f=l,c=0,d=i(),s=!1,v=null,g=!0,b=1,x=function i(l){if(null!=e){var x=t(),p=a();if(function(e,n,t){return!(e&&!g)||n!==r||t!==u}(n,x,p)&&(n=function(n,t){var a=h(n,e.VERTEX_SHADER),r=h(t,e.FRAGMENT_SHADER),i=e.createProgram();if(e.attachShader(i,a),e.attachShader(i,r),e.linkProgram(i),s&&!e.getProgramParameter(i,e.LINK_STATUS)){var o=e.getProgramInfoLog(i);throw e.deleteProgram(i),new Error("Failed to link program : ".concat(o,"\n            Vertex Shader : ").concat(n,"\n            Fragment Shader : ").concat(t))}return i}(x,p),r=x,u=p,g=!1),e.useProgram(n),d.uniform("uScreen",o([e.canvas.width/b,e.canvas.height/b])),d(i,n),0===c)null==d.elementIndices()?e.drawArrays(f,0,l):e.drawElements(f,l,e.UNSIGNED_SHORT,0);else if(null==d.elementIndices())v.drawArraysInstancedANGLE(f,0,c,l);else{var y=d.elementIndices().data().length;if(c!==y)throw new Error("Expected elementIndices length ".concat(y)+" to match subInstanceCount ".concat(c,"."));v.drawElementsInstancedANGLE(f,c,e.UNSIGNED_SHORT,0,l)}}};return x.extInstancedArrays=function(){return v},x.context=function(){for(var n=arguments.length,t=new Array(n),a=0;a<n;a++)t[a]=arguments[a];return t.length?(null!=t[0]&&t[0]===e||(d.flush(),g=!0),null!=t[0]&&t[0]!==e&&(v=t[0].getExtension("ANGLE_instanced_arrays")),e=t[0],x):e},x.buffers=function(){return arguments.length?(d=arguments.length<=0?void 0:arguments[0],x):d},x.vertexShader=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],x):t},x.fragmentShader=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],x):a},x.mode=function(){return arguments.length?(f=arguments.length<=0?void 0:arguments[0],x):f},x.subInstanceCount=function(){return arguments.length?(c=arguments.length<=0?void 0:arguments[0],x):c},x.debug=function(){return arguments.length?(s=arguments.length<=0?void 0:arguments[0],x):s},x.pixelRatio=function(){return arguments.length?(b=arguments.length<=0?void 0:arguments[0],x):b},x;function h(n,t){var a=e.createShader(t);if(e.shaderSource(a,n),e.compileShader(a),s&&!e.getShaderParameter(a,e.COMPILE_STATUS)){var r=e.getShaderInfoLog(a);throw e.deleteShader(a),new Error("Failed to compile shader : ".concat(r,"\n            Shader : ").concat(n))}return a}},c=function(e){var n=[],t=[],a=function(){return e(n.join("\n"),t.join("\n"))};function r(e,n){e.push(n)}function i(e,n,t){var a=e.indexOf(t);e.splice(a>=0?a:e.length,0,n)}function o(e,n){-1===e.indexOf(n)&&e.push(n)}return a.appendHeader=function(e){return r(n,e),a},a.insertHeader=function(e,t){return i(n,e,t),a},a.appendHeaderIfNotExists=function(e){return o(n,e),a},a.appendBody=function(e){return r(t,e),a},a.insertBody=function(e,n){return i(t,e,n),a},a.appendBodyIfNotExists=function(e){return o(t,e),a},a},d=function(e,n){return"\nprecision mediump float;\nfloat inf = 1.0 / 0.0;\n".concat(e,"\nvoid main() {\n    ").concat(n,"\n}")},s=function(e,n){return"\nprecision mediump float;\n".concat(e,"\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ").concat(n,"\n}")},v="attribute vec4 aFillColor;\n             varying vec4 vFillColor;",g="vFillColor = aFillColor;",b="attribute vec4 aStrokeColor;\n             varying vec4 vStrokeColor;",x="vStrokeColor = aStrokeColor;",h="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",p="\n        vDefined = aDefined;\n        vSize = 2.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",y="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",m="\n        vDefined = aDefined;\n        vSize = 4.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",S="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",V="\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",C="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",D="\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",w="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",A="\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = 2.0 * (vSize + uStrokeWidth + 1.0);\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",E="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",N="\n        vDefined = aDefined;\n        vSize = sqrt((16.0 * aSize) / (3.0 * sqrt(3.0)));\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",z="\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",P="\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 5.0);\n        vStrokeWidthRatio = uStrokeWidth / (vSize + uStrokeWidth + 1.0);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);",B="\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",_="\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n         (isPositiveY * isExtremeY * aLowValue) +\n         (isPositiveY * isNotExtremeY * aCloseValue) +\n         (isNotPositiveY * isNotExtremeY * aOpenValue) +\n         (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = (isNotExtremeY * aCorner.x) + (isExtremeY * aCorner.z);\n        float lineWidthYDirection = isNotExtremeY * sign(aCloseValue - aOpenValue) * aCorner.y;\n\n        float bandwidthModifier = aBandwidth * aCorner.x / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);",Y="\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",I="\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n            (isPositiveY * isExtremeY * aLowValue) +\n            (isPositiveY * isNotExtremeY * aCloseValue) +\n            (isNotPositiveY * isNotExtremeY * aOpenValue) +\n            (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = isExtremeY * aCorner.z;\n        float lineWidthYDirection = isNotExtremeY * aCorner.z;\n\n        float bandwidthModifier = isNotExtremeY * aCorner.x * aBandwidth / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);",M="\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aMainValue;\n        attribute float aBaseValue;\n        attribute vec2 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",k="\n        vDefined = aDefined;\n        float isBaseline = (1.0 - aCorner.y) / 2.0;\n        float yValue = (isBaseline * aBaseValue) + ((1.0 - isBaseline) * aMainValue);\n\n        float xModifier = aCorner.x * (aBandwidth) / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);",H="\n        attribute vec3 aCorner;\n        attribute float aCrossNextNextValue;\n        attribute float aMainNextNextValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossPrevValue;\n        attribute float aMainPrevValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        uniform float uStrokeWidth;\n        uniform vec2 uScreen;\n\n        varying float vDefined;",F="\n        vDefined = aDefined * aDefinedNext;\n        vec4 prev = vec4(aCrossPrevValue, aMainPrevValue, 0, 0);\n        vec4 curr = vec4(aCrossValue, aMainValue, 0, 0);\n        gl_Position = vec4(aCrossNextValue, aMainNextValue, 0, 1);\n        vec4 nextNext = vec4(aCrossNextNextValue, aMainNextNextValue, 0, 0);",W="\n        vec4 currVertexPosition = gl_Position;\n        vec4 nextVertexPosition = gl_Position;\n\n        if (all(equal(curr.xy, prev.xy))) {\n            prev.xy = curr.xy + normalize(curr.xy - currVertexPosition.xy);\n        }\n        if (all(equal(curr.xy, currVertexPosition.xy))) {\n            currVertexPosition.xy = curr.xy + normalize(curr.xy - prev.xy);\n        }\n        vec2 A = normalize(normalize(curr.xy - prev.xy) * uScreen);\n        vec2 B = normalize(normalize(currVertexPosition.xy - curr.xy) * uScreen);\n        vec2 tangent = normalize(A + B);\n        vec2 miter = vec2(-tangent.y, tangent.x);\n        vec2 normalA = vec2(-A.y, A.x);\n        float miterLength = 1.0 / dot(miter, normalA);\n        vec2 point = normalize(A - B);\n        if (miterLength > 10.0 && sign(aCorner.x * dot(miter, point)) > 0.0) {\n            currVertexPosition.xy = curr.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalA) / uScreen.xy;\n        } else {\n            currVertexPosition.xy = curr.xy + (aCorner.x * miter * uStrokeWidth * miterLength) / uScreen.xy;\n        }\n\n        if (all(equal(nextVertexPosition.xy, curr.xy))) {\n            curr.xy = nextVertexPosition.xy + normalize(nextVertexPosition.xy - nextNext.xy);\n        }\n        if (all(equal(nextVertexPosition.xy, nextNext.xy))) {\n            nextNext.xy = nextVertexPosition.xy + normalize(nextVertexPosition.xy - curr.xy);\n        }\n        vec2 C = normalize(normalize(nextVertexPosition.xy - curr.xy) * uScreen);\n        vec2 D = normalize(normalize(nextNext.xy - nextVertexPosition.xy) * uScreen);\n        vec2 tangentCD = normalize(C + D);\n        vec2 miterCD = vec2(-tangentCD.y, tangentCD.x);\n        vec2 normalC = vec2(-C.y, C.x);\n        float miterCDLength = 1.0 / dot(miterCD, normalC);\n        vec2 pointCD = normalize(C - D);\n        if (miterCDLength > 10.0 && sign(aCorner.x * dot(miterCD, pointCD)) > 0.0) {\n            nextVertexPosition.xy = nextVertexPosition.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalC) / uScreen.xy;\n        } else {\n            nextVertexPosition.xy = nextVertexPosition.xy + (aCorner.x * miterCD * uStrokeWidth * miterCDLength) / uScreen.xy;\n        }\n\n        gl_Position.xy = ((1.0 - aCorner.z) * currVertexPosition.xy) + (aCorner.z * nextVertexPosition.xy);",T="\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",R="\n        vDefined = aDefined;\n        float isLow = (aCorner.y + 1.0) / 2.0;\n        float yValue = isLow * aLowValue + (1.0 - isLow) * aHighValue;\n\n        float isEdgeCorner = abs(aCorner.x);\n        float lineWidthXDirection = (1.0 - isEdgeCorner) * aCorner.z;\n        float lineWidthYDirection = isEdgeCorner * aCorner.z;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection) + (aBandwidth * aCorner.x / 2.0);\n        float yModifier = (uStrokeWidth * lineWidthYDirection);",L="\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aBaseValue;\n        attribute float aBaseNextValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        varying float vDefined;\n\n        float when_lt(float a, float b) {\n            return max(sign(b - a), 0.0);\n        }\n\n        float and(float a, float b) {\n            return a * b;\n        }",O="\n        vDefined = aDefined * aDefinedNext;\n        gl_Position = vec4(0, 0, 0, 1);\n\n        float hasIntercepted = when_lt((aMainNextValue - aBaseNextValue) * (aMainValue - aBaseValue), 0.0);\n        float useIntercept = and(aCorner.z, hasIntercepted);\n\n        float yGradient = (aMainNextValue - aMainValue) / (aCrossNextValue - aCrossValue);\n        float yConstant = aMainNextValue - (yGradient * aCrossNextValue);\n\n        float y0Gradient = (aBaseNextValue - aBaseValue) / (aCrossNextValue - aCrossValue);\n        float y0Constant = aBaseNextValue - (y0Gradient * aCrossNextValue);\n\n        float denominator = (yGradient - y0Gradient) + step(abs(yGradient - y0Gradient), 0.0);\n        float interceptXValue = (y0Constant - yConstant) / denominator;\n        float interceptYValue = (yGradient * interceptXValue) + yConstant;\n\n        gl_Position = vec4(interceptXValue * useIntercept, interceptYValue * useIntercept, 0, 1);\n\n        gl_Position.x += (1.0 - useIntercept) * ((aCorner.x * aCrossNextValue) + ((1.0 - aCorner.x) * aCrossValue));\n        gl_Position.y += (1.0 - useIntercept) * (1.0 - aCorner.y) * ((aCorner.x * aMainNextValue) + ((1.0 - aCorner.x) * aMainValue));\n        gl_Position.y += (1.0 - useIntercept) * aCorner.y * ((aCorner.x * aBaseNextValue) + ((1.0 - aCorner.x) * aBaseValue));",U="\n        attribute vec4 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aCapWidth;\n        attribute float aHighValue;\n        attribute float aUpperQuartileValue;\n        attribute float aMedianValue;\n        attribute float aLowerQuartileValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;\n    ",G="\n        vDefined = aDefined;\n        float isExtremeY = sign(abs(aCorner.y) - 2.0) + 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n\n        float isNonZeroY = abs(sign(aCorner.y));\n        float isZeroY = 1.0 - isNonZeroY;\n\n        float isQuartileY = isNotExtremeY * isNonZeroY;\n\n        float isPositiveY = (sign(aCorner.y + 0.5) + 1.0) / 2.0;\n        float isNegativeY = 1.0 - isPositiveY;\n\n        float yValue =\n          (isExtremeY * isNegativeY) * aHighValue +\n          (isQuartileY * isNegativeY) * aUpperQuartileValue +\n          isZeroY * aMedianValue +\n          (isQuartileY * isPositiveY) * aLowerQuartileValue +\n          (isExtremeY * isPositiveY) * aLowValue;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float isHorizontal = aCorner.w;\n        float isVertical = 1.0 - isHorizontal;\n\n        float xDisplacement = aCorner.x * (isExtremeY * aCapWidth + isNotExtremeY * aBandwidth) / 2.0;\n\n        float xModifier = (isVertical * uStrokeWidth * aCorner.z / 2.0) + xDisplacement;\n        float yModifier = isHorizontal * uStrokeWidth * aCorner.z / 2.0;",q="\n        varying float vSize;\n        varying float vDefined;",X="\n        float canFill = 1.0;\n        float distance = length(2.0 * gl_PointCoord - 1.0);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }",Q="\n        varying float vSize;\n        varying float vDefined;\n\n        // anterior, exterior angles\n        float an = 0.628319;\n        vec2 acs = vec2(0.809017, 0.587786); // (cos, sin)\n        float en = 0.952000;\n        vec2 ecs = vec2(0.580055, 0.814577);\n    ",j="\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        p -= acs;\n        p += ecs * clamp(-dot(p, ecs), 0.0, acs.y / ecs.y);\n        float d = length(p) * sign(p.x);\n\n        float distance = 1.0 + d;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }",Z="\n        varying float vSize;\n        varying float vDefined;\n    ",K="\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float an = 3.141593 / 3.0;\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        // box\n        vec2 d = abs(p) - vec2(0.9, 0.35);\n        float sdf = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n\n        float distance = 1.0 + sdf;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }",J="\n        varying float vSize;\n        varying float vDefined;",$="\n        float canFill = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float distance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);",ee="\n        varying float vSize;\n        varying float vDefined;\n        float a = 0.6;\n        float b = 1.0;\n    ",ne="\n        if (vDefined < 0.5) {\n            discard;\n        }\n\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n\n        float x = abs(pointCoordTransform.x);\n        float y = abs(pointCoordTransform.y);\n\n        float X = (a * b * x) / (a * y + b * x);\n        float Y = (a * b * y) / (a * y + b * x);\n\n        float distance = length(vec2(x, y)) / length(vec2(X, Y));\n\n        if (distance > 1.0) {\n            discard;\n        }\n    ",te="\n        varying float vSize;\n        varying float vDefined;",ae="\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float topEdgesDistance = abs(pointCoordTransform.x) - ((pointCoordTransform.y - 0.6) / sqrt(3.0));\n        float bottomEdgeDistance = pointCoordTransform.y + 0.5;\n        float distance = max(topEdgesDistance, bottomEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }",re="\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",ie="\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float innerCornerDistance = min(abs(pointCoordTransform.x), abs(pointCoordTransform.y)) + 0.66 - vStrokeWidthRatio;\n        float outerEdgeDistance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float distance = max(innerCornerDistance, outerEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }",oe="\n        varying float vColorIndicator;\n        varying float vDefined;",ue="\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }",le="\n        varying float vColorIndicator;\n        varying float vDefined;",fe="\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }",ce="\n        varying float vDefined;",de="\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.86, 0.86, 0.86, 1);",se="\n        varying float vDefined;\n    ",ve="\n        float canFill = 0.0;\n        float canStroke = 1.0;\n\n        if (vDefined < 0.5) {\n            discard;\n        }",ge="varying float vDefined;",be="\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }",xe="varying float vDefined;",he="\n        float canFill = 1.0;\n        float canStroke = 0.0;\n\n        gl_FragColor = vec4(0.60, 0.60, 0.60, 1.0);\n\n        if (vDefined < 0.5) {\n            discard;\n        }",pe="varying vec4 vFillColor;",ye="gl_FragColor = (canFill * vFillColor) + ((1.0 - canFill) * gl_FragColor);",me="varying vec4 vStrokeColor;",Se="gl_FragColor = (canStroke * vStrokeColor) + ((1.0 - canStroke) * gl_FragColor);",Ve="varying float vDefined;",Ce="\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }",De=function(){var e=c(d),n=c(s);return e.appendHeader(L).appendBody(O),n.appendHeader(ce).appendBody(de),{vertex:function(){return e},fragment:function(){return n}}},we={BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,FLOAT:5126};function Ae(e){switch(e){case we.BYTE:case we.UNSIGNED_BYTE:return 1;case we.SHORT:case we.UNSIGNED_SHORT:return 2;case we.FLOAT:return 4;default:throw new Error("Unknown type ".concat(e))}}function Ee(e){switch(e){case we.BYTE:return Int8Array;case we.UNSIGNED_BYTE:return Uint8Array;case we.SHORT:return Int16Array;case we.UNSIGNED_SHORT:return Uint16Array;case we.FLOAT:return Float32Array;default:throw new Error("Unknown type ".concat(e))}}var Ne=function(){var e=-1,n=null,t=1,a=we.FLOAT,r=!1,i=0,o=0,u=null,l=function(l){var f=l.context();null==n&&(n=f.createBuffer()),f.bindBuffer(f.ARRAY_BUFFER,n),f.vertexAttribPointer(e,t,a,r,i,o),f.enableVertexAttribArray(e),l.extInstancedArrays().vertexAttribDivisorANGLE(e,null!=u?u:l.subInstanceCount()>0?1:0)};return l.location=function(){return arguments.length?(e=arguments.length<=0?void 0:arguments[0],l):e},l.buffer=function(){return arguments.length?(n=arguments.length<=0?void 0:arguments[0],l):n},l.size=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],l):t},l.type=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],l):a},l.normalized=function(){return arguments.length?(r=arguments.length<=0?void 0:arguments[0],l):r},l.stride=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],l):i},l.offset=function(){return arguments.length?(o=arguments.length<=0?void 0:arguments[0],l):o},l.divisor=function(){return arguments.length?(u=arguments.length<=0?void 0:arguments[0],l):u},l},ze=function(){var e=!0,n=1,t=we.FLOAT,a=function(){var e=we.FLOAT,n=new Float32Array(0),t=function(t){var a=Ee(e);return n.length>t?n=new a(n.buffer,0,t):n.length!==t&&(n=new a(t)),n};return t.type=function(){if(!arguments.length)return e;if(e!==(arguments.length<=0?void 0:arguments[0])){var a=Ee(e=arguments.length<=0?void 0:arguments[0]);n=new a(0)}return t},t}(),r=function(e,n){return e},i=null,o=function(){var o=i.length,u=a.type(t)(o*n);if(n>1)for(var l=0;l<o;l++){var f=r(i[l],l);if(f.length!==n)throw new Error("Expected components array of size ".concat(n,", recieved array with length ").concat(f.length,"."));for(var c=0;c<n;c++)u[l*n+c]=f[c]}else for(var d=0;d<o;d++){var s=r(i[d],d);if(Array.isArray(s))throw new Error("Expected a single component value, recieved array with length ".concat(s.length,"."));u[d]=s}return e=!1,u};return o.dirty=function(){return e},o.clear=function(){e=!0},o.size=function(){return arguments.length?(n=arguments.length<=0?void 0:arguments[0],e=!0,o):n},o.type=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],e=!0,o):t},o.arrayViewFactory=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],e=!0,o):a},o.value=function(){return arguments.length?(r=arguments.length<=0?void 0:arguments[0],e=!0,o):r},o.data=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],e=!0,o):i},o},Pe=function(){var e=Ne(),t=ze(),a=function n(a){if(e.size(n.size()).type(n.type()),e(a),t.dirty()){var r=t(),i=a.context();i.bindBuffer(i.ARRAY_BUFFER,e.buffer()),i.bufferData(i.ARRAY_BUFFER,r,i.DYNAMIC_DRAW)}};return a.clear=function(){e.buffer(null),t.clear()},n.rebind(a,e,"normalized","location","divisor"),n.rebind(a,t,"data","value","size","type"),a},Be=function(e,n,t,a){for(var r=arguments.length,i=new Array(r>4?r-4:0),o=4;o<r;o++)i[o-4]=arguments[o];e[n]=function(){for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];var u=t[a].apply(t,i.concat(r));return u===t?e:u}},_e=function(){var e=c(d),n=c(s);return e.appendHeader(h).appendBody(p),n.appendHeader(q).appendBody(X),{vertex:function(){return e},fragment:function(){return n}}},Ye=function(){var e=c(d),n=c(s);return e.appendHeader(H).appendBody(F),n.appendHeader(Ve).appendBody(Ce),{vertex:function(){return e},fragment:function(){return n}}},Ie=function(){var e=1,n=function(n){n.buffers().uniform("uStrokeWidth",o(e))};return n.lineWidth=function(){return arguments.length?(e=arguments.length<=0?void 0:arguments[0],n):e},n},Me=function(e){var n=null,t=e,a=!0,r=function(e){var r=e.context();null==n&&(n=r.createBuffer()),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,n),a&&(r.bufferData(r.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),r.STATIC_DRAW),a=!1)};return r.clear=function(){n=null,a=!0},r.data=function(){return arguments.length?(a=!0,t=arguments.length<=0?void 0:arguments[0],r):t},r},ke=function(){var e=c(d),n=c(s);return e.appendHeader(Y).appendBody(I),n.appendHeader(le).appendBody(fe),{vertex:function(){return e},fragment:function(){return n}}},He=function(){var e=c(d),n=c(s);return e.appendHeader(M).appendBody(k),n.appendHeader(xe).appendBody(he),{vertex:function(){return e},fragment:function(){return n}}},Fe=function(){var e=c(d),n=c(s);return e.appendHeader(T).appendBody(R),n.appendHeader(ge).appendBody(be),{vertex:function(){return e},fragment:function(){return n}}},We=function(){var e=c(d),n=c(s);return e.appendHeader(B).appendBody(_),n.appendHeader(oe).appendBody(ue),{vertex:function(){return e},fragment:function(){return n}}},Te=function(){var e=c(d),n=c(s);return e.appendHeader(U).appendBody(G),n.appendHeader(se).appendBody(ve),{vertex:function(){return e},fragment:function(){return n}}},Re=function(){var e=r(),t=function(e){return"linear".concat(e)},a=function(n,a,r){n.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(t(r),"Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(t(r),"Scale;")).appendBody("".concat(a," = ").concat(a," + ").concat(t(r),"Offset;")).appendBody("".concat(a," = ").concat(a," * ").concat(t(r),"Scale;"));var i=e.domain()[1]-e.domain()[0],u=e.range()[1]-e.range()[0],l=e.range()[0]*(i/u)-e.domain()[0],f=u/i,c=[0,0,0,0],d=[1,1,1,1];c[r]=l,d[r]=f,n.buffers().uniform("".concat(t(r),"Offset"),o(c)).uniform("".concat(t(r),"Scale"),o(d))};return n.rebindAll(a,e),a},Le=function(){var e=r(),t=10;function a(e,n){return Math.log10(e)/Math.log10(n)}var i=function(e){return"log".concat(e)},u=function(n,r,u){var l="".concat(i(u),"Offset + (").concat(i(u),"Scale * clamp(log(").concat(r,") / log(").concat(i(u),"Base), -inf, inf))");n.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(i(u),"Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(u),"Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(u),"Include;")).appendHeaderIfNotExists("uniform float ".concat(i(u),"Base;")).appendBody("".concat(r," = (").concat(i(u),"Include * (").concat(l,")) + ((1.0 - ").concat(i(u),"Include) * ").concat(r,");"));var f=a(e.domain()[1],t)-a(e.domain()[0],t),c=(e.range()[1]-e.range()[0])/f,d=e.range()[0]-c*a(e.domain()[0],t),s=[0,0,0,0],v=[0,0,0,0],g=[0,0,0,0];s[u]=d,v[u]=c,g[u]=1,n.buffers().uniform("".concat(i(u),"Offset"),o(s)).uniform("".concat(i(u),"Scale"),o(v)).uniform("".concat(i(u),"Include"),o(g)).uniform("".concat(i(u),"Base"),o(t))};return u.base=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],u):t},n.rebindAll(u,e),u},Oe=function(){var e=r(),t=1;function a(e,n){return Math.sign(e)*Math.pow(Math.abs(e),n)}var i=function(e){return"pow".concat(e)},u=function(n,r,u){var l="".concat(i(u),"Offset + (").concat(i(u),"Scale * sign(").concat(r,") * pow(abs(").concat(r,"), vec4(").concat(i(u),"Exp)))");n.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(i(u),"Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(u),"Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(i(u),"Include;")).appendHeaderIfNotExists("uniform float ".concat(i(u),"Exp;")).appendBody("".concat(r," = (").concat(i(u),"Include * (").concat(l,")) + ((1.0 - ").concat(i(u),"Include) * ").concat(r,");"));var f=a(e.domain()[1],t)-a(e.domain()[0],t),c=(e.range()[1]-e.range()[0])/f,d=e.range()[0]-c*a(e.domain()[0],t),s=[0,0,0,0],v=[0,0,0,0],g=[0,0,0,0];s[u]=d,v[u]=c,g[u]=1,n.buffers().uniform("".concat(i(u),"Offset"),o(s)).uniform("".concat(i(u),"Scale"),o(v)).uniform("".concat(i(u),"Include"),o(g)).uniform("".concat(i(u),"Exp"),o(t))};return u.exponent=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],u):t},n.rebindAll(u,e),u},Ue=t.scaleLinear().copy.toString(),Ge=t.scaleLog().copy.toString(),qe=t.scalePow().copy.toString(),Xe=t.scaleTime().copy.toString(),Qe=t.scaleIdentity(),je=Date.now(),Ze=function(e){return e-je},Ke=function(e){var t=Ne().divisor(1),a=e,r=!0,i=function(e){if(t(e),r){if(!Array.isArray(a))throw new Error("Expected an array, received: ".concat(a));if(a.length!==t.size())throw new Error("Expected array of length: ".concat(t.size(),", recieved array of length: ").concat(a.length));var n=e.context();n["vertexAttrib".concat(a.length,"fv")](t.location(),a),n.disableVertexAttribArray(t.location()),r=!1}};return i.clear=function(){r=!0},i.value=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],r=!0,i):a},n.rebind(i,t,"normalized","size","location"),i};e.webglAdjacentAttribute=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(e>0||t<0)throw new Error("Offset values (".concat(e," & ").concat(t,") must straddle 0 "));var a=Ne(),r=ze(),i=function n(i){var o=n.size()*Ae(n.type()),u=Math.abs(e)*o;if(a.offset(u).size(n.size()).type(n.type()),a(i),r.dirty()){var l=r(),f=t*o,c=u+l.length*Ae(n.type())+f,d=i.context();d.bindBuffer(d.ARRAY_BUFFER,a.buffer()),d.bufferData(d.ARRAY_BUFFER,c,d.DYNAMIC_DRAW),d.bufferSubData(d.ARRAY_BUFFER,u,l)}};return i.offset=function(r){if(e>r||r>t)throw new Error("Requested offset ".concat(r," exceeds bounds (").concat(e," & ").concat(t,") "));var o=function(n){a.offset((r-e)*i.size()*Ae(i.type())),a(n)};return n.rebind(o,i,"clear","location"),o},i.clear=function(){a.buffer(null),r.clear()},n.rebind(i,a,"normalized","location","divisor"),n.rebind(i,r,"data","value","size","type"),i},e.webglAttribute=Pe,e.webglBaseAttribute=Ne,e.webglBufferBuilder=i,e.webglElementIndices=Me,e.webglFillColor=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0,1],t=Pe().size(4),a=e,r=!0,i=function(e){if(e.vertexShader().appendHeaderIfNotExists(v).appendBodyIfNotExists(g),e.fragmentShader().appendHeaderIfNotExists(pe).appendBodyIfNotExists(ye),Array.isArray(a))e.buffers().attribute("aFillColor",Ke(a).size(4));else{if("function"!=typeof a)throw new Error("Expected value to be an array or function, received ".concat(a));if(!r)return;t.value(a),e.buffers().attribute("aFillColor",t)}r=!1};return i.value=function(){return arguments.length?(a!==(arguments.length<=0?void 0:arguments[0])&&(a=arguments.length<=0?void 0:arguments[0],r=!0),i):a},n.rebind(i,t,"data"),i},e.webglProgramBuilder=f,e.webglScaleLinear=Re,e.webglScaleLog=Le,e.webglScaleMapper=function(e){switch(e.copy.toString()){case Ue:return{scale:Qe,webglScale:Re().domain(e.domain())};case Xe:return{scale:Ze,webglScale:Re().domain(e.domain().map(Ze))};case Ge:return{scale:Qe,webglScale:Le().domain(e.domain()).base(e.base())};case qe:return{scale:Qe,webglScale:Oe().domain(e.domain()).exponent(e.exponent())};default:return{scale:e.copy(),webglScale:Re().domain(e.range())}}},e.webglScalePow=Oe,e.webglSeriesArea=function(){var e=f().mode(l).subInstanceCount(6),t=r(),a=r(),i=function(){},o=Pe().divisor(0).size(3).type(we.UNSIGNED_BYTE).data([[0,0,0],[0,1,0],[1,1,1],[0,0,1],[1,0,0],[1,1,0]]);e.buffers().attribute("aCorner",o);var u=function(n){var r=De();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),i(e),e(n-1)};return u.decorate=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],u):i},u.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],u):t},u.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],u):a},n.rebind(u,e,"context","pixelRatio"),Be(u,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(u,"crossNextValueAttribute",e.buffers(),"attribute","aCrossNextValue"),Be(u,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),Be(u,"mainNextValueAttribute",e.buffers(),"attribute","aMainNextValue"),Be(u,"baseValueAttribute",e.buffers(),"attribute","aBaseValue"),Be(u,"baseNextValueAttribute",e.buffers(),"attribute","aBaseNextValue"),Be(u,"definedAttribute",e.buffers(),"attribute","aDefined"),Be(u,"definedNextAttribute",e.buffers(),"attribute","aDefinedNext"),u},e.webglSeriesBar=function(){var e=f().mode(l).subInstanceCount(6),t=r(),a=r(),i=function(){},o=Pe().divisor(0).size(2).type(we.BYTE).data([[-1,-1],[1,1],[-1,1],[1,-1]]);e.buffers().elementIndices(Me([0,1,2,0,1,3])).attribute("aCorner",o);var u=function(n){var r=He();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),e.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n        "),i(e),e(n)};return u.decorate=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],u):i},u.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],u):t},u.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],u):a},n.rebind(u,e,"context","pixelRatio"),Be(u,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(u,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),Be(u,"baseValueAttribute",e.buffers(),"attribute","aBaseValue"),Be(u,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),Be(u,"definedAttribute",e.buffers(),"attribute","aDefined"),u},e.webglSeriesBoxPlot=function(){var e=f().mode(l).subInstanceCount(54),t=r(),a=r(),i=function(){},o=Ie(),u=Pe().divisor(0).size(4).type(we.BYTE).data([[-1,-2,-1,1],[1,-2,-1,1],[1,-2,1,1],[-1,-2,1,1],[0,-2,-1,0],[0,-2,1,0],[0,-1,1,0],[0,-1,-1,0],[-1,-1,-1,1],[1,-1,-1,1],[1,-1,1,1],[-1,-1,1,1],[-1,0,-1,1],[1,0,-1,1],[1,0,1,1],[-1,0,1,1],[-1,1,-1,1],[1,1,-1,1],[1,1,1,1],[-1,1,1,1],[-1,-1,-1,0],[-1,-1,1,0],[-1,1,1,0],[-1,1,-1,0],[1,-1,-1,0],[1,-1,1,0],[1,1,1,0],[1,1,-1,0],[0,2,-1,0],[0,2,1,0],[0,1,1,0],[0,1,-1,0],[-1,2,-1,1],[1,2,-1,1],[1,2,1,1],[-1,2,1,1]]);e.buffers().elementIndices(Me([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23,24,25,26,24,26,27,28,29,30,28,30,31,32,33,34,32,34,35])).attribute("aCorner",u);var c=function(n){var r=Te();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),o(e),e.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n            gl_Position.y += yModifier / uScreen.y * 2.0;\n        "),i(e),e(n)};return c.decorate=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],c):i},c.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],c):t},c.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],c):a},n.rebind(c,e,"context","pixelRatio"),n.rebind(c,o,"lineWidth"),Be(c,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(c,"highValueAttribute",e.buffers(),"attribute","aHighValue"),Be(c,"upperQuartileValueAttribute",e.buffers(),"attribute","aUpperQuartileValue"),Be(c,"medianValueAttribute",e.buffers(),"attribute","aMedianValue"),Be(c,"lowerQuartileValueAttribute",e.buffers(),"attribute","aLowerQuartileValue"),Be(c,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),Be(c,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),Be(c,"capAttribute",e.buffers(),"attribute","aCapWidth"),Be(c,"definedAttribute",e.buffers(),"attribute","aDefined"),c},e.webglSeriesCandlestick=function(){var e=f().mode(l).subInstanceCount(12),t=r(),a=r(),i=Ie(),o=function(){},u=Pe().divisor(0).size(3).type(we.BYTE).data([[0,2,1],[0,2,-1],[0,-2,-1],[0,-2,1],[1,-1,0],[-1,-1,0],[-1,1,0],[1,1,0]]);e.buffers().elementIndices(Me([0,1,2,0,3,2,4,5,6,4,7,6])).attribute("aCorner",u);var c=function(n){var r=We();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),i(e),e.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x * 2.0;\n          gl_Position.y += yModifier / uScreen.y * 2.0;\n        "),o(e),e(n)};return c.decorate=function(){return arguments.length?(o=arguments.length<=0?void 0:arguments[0],c):o},c.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],c):t},c.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],c):a},n.rebind(c,e,"context","pixelRatio"),n.rebind(c,i,"lineWidth"),Be(c,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(c,"openValueAttribute",e.buffers(),"attribute","aOpenValue"),Be(c,"highValueAttribute",e.buffers(),"attribute","aHighValue"),Be(c,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),Be(c,"closeValueAttribute",e.buffers(),"attribute","aCloseValue"),Be(c,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),Be(c,"definedAttribute",e.buffers(),"attribute","aDefined"),c},e.webglSeriesErrorBar=function(){var e=f().mode(l).subInstanceCount(18),t=r(),a=r(),i=function(){},o=Ie(),u=Pe().divisor(0).size(3).type(we.BYTE).data([[0,1,1],[0,1,-1],[0,-1,-1],[0,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1],[-1,-1,1],[-1,1,-1],[-1,1,1],[1,1,1],[1,1,-1]]);e.buffers().elementIndices(Me([0,1,2,0,3,2,4,5,6,4,7,6,8,9,10,8,11,10])).attribute("aCorner",u);var c=function(n){var r=Fe();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),o(e),e.vertexShader().appendBody("\n                gl_Position.x += xModifier / uScreen.x * 2.0;\n                gl_Position.y += yModifier / uScreen.y * 2.0;\n            "),i(e),e(n)};return c.decorate=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],c):i},c.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],c):t},c.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],c):a},n.rebind(c,e,"context","pixelRatio"),n.rebind(c,o,"lineWidth"),Be(c,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(c,"highValueAttribute",e.buffers(),"attribute","aHighValue"),Be(c,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),Be(c,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),Be(c,"definedAttribute",e.buffers(),"attribute","aDefined"),c},e.webglSeriesLine=function(){var e=f().mode(l).subInstanceCount(12),t=r(),a=r(),i=function(){},o=Ie(),u=Pe().divisor(0).size(3).type(we.BYTE).data([[-1,0,0],[1,1,0],[1,-1,1],[-1,0,1],[1,1,1]]);e.buffers().elementIndices(Me([0,1,2,1,2,3,0,2,3,2,3,4])).attribute("aCorner",u);var c=function(n){var r=Ye();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"prev",0),a(e,"prev",1),t(e,"curr",0),a(e,"curr",1),t(e,"gl_Position",0),a(e,"gl_Position",1),t(e,"nextNext",0),a(e,"nextNext",1),e.vertexShader().appendBody(W),o(e),i(e),e(n-1)};return c.decorate=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],c):i},c.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],c):t},c.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],c):a},n.rebind(c,e,"context","pixelRatio"),n.rebind(c,o,"lineWidth"),Be(c,"crossPreviousValueAttribute",e.buffers(),"attribute","aCrossPrevValue"),Be(c,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(c,"crossNextValueAttribute",e.buffers(),"attribute","aCrossNextValue"),Be(c,"crossNextNextValueAttribute",e.buffers(),"attribute","aCrossNextNextValue"),Be(c,"mainPreviousValueAttribute",e.buffers(),"attribute","aMainPrevValue"),Be(c,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),Be(c,"mainNextValueAttribute",e.buffers(),"attribute","aMainNextValue"),Be(c,"mainNextNextValueAttribute",e.buffers(),"attribute","aMainNextNextValue"),Be(c,"definedAttribute",e.buffers(),"attribute","aDefined"),Be(c,"definedNextAttribute",e.buffers(),"attribute","aDefinedNext"),c},e.webglSeriesOhlc=function(){var e=f().mode(l).subInstanceCount(18),t=r(),a=r(),i=Ie(),o=function(){},u=Pe().divisor(0).size(3).type(we.BYTE).data([[0,-2,-1],[0,-2,1],[0,2,1],[0,2,-1],[-1,-1,-1],[-1,-1,1],[0,-1,1],[0,-1,-1],[1,1,1],[0,1,1],[0,1,-1],[1,1,-1]]);e.buffers().elementIndices(Me([0,1,2,0,3,2,4,5,6,4,7,6,8,9,10,10,11,8])).attribute("aCorner",u);var c=function(n){var r=ke();e.vertexShader(r.vertex()).fragmentShader(r.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),i(e),e.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x * 2.0;\n          gl_Position.y += yModifier / uScreen.y * 2.0;\n        "),o(e),e(n)};return c.decorate=function(){return arguments.length?(o=arguments.length<=0?void 0:arguments[0],c):o},c.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],c):t},c.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],c):a},n.rebind(c,e,"context","pixelRatio"),n.rebind(c,i,"lineWidth"),Be(c,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(c,"openValueAttribute",e.buffers(),"attribute","aOpenValue"),Be(c,"highValueAttribute",e.buffers(),"attribute","aHighValue"),Be(c,"lowValueAttribute",e.buffers(),"attribute","aLowValue"),Be(c,"closeValueAttribute",e.buffers(),"attribute","aCloseValue"),Be(c,"bandwidthAttribute",e.buffers(),"attribute","aBandwidth"),Be(c,"definedAttribute",e.buffers(),"attribute","aDefined"),c},e.webglSeriesPoint=function(){var e=f().mode(u),t=r(),a=r(),i=_e(),o=function(){},l=function(n){e.vertexShader(i.vertex()).fragmentShader(i.fragment()),t(e,"gl_Position",0),a(e,"gl_Position",1),o(e),e(n)};return l.type=function(){return arguments.length?(i=arguments.length<=0?void 0:arguments[0],l):i},l.decorate=function(){return arguments.length?(o=arguments.length<=0?void 0:arguments[0],l):o},l.xScale=function(){return arguments.length?(t=arguments.length<=0?void 0:arguments[0],l):t},l.yScale=function(){return arguments.length?(a=arguments.length<=0?void 0:arguments[0],l):a},n.rebind(l,e,"context","pixelRatio"),Be(l,"crossValueAttribute",e.buffers(),"attribute","aCrossValue"),Be(l,"mainValueAttribute",e.buffers(),"attribute","aMainValue"),Be(l,"sizeAttribute",e.buffers(),"attribute","aSize"),Be(l,"definedAttribute",e.buffers(),"attribute","aDefined"),l},e.webglShaderBuilder=c,e.webglStrokeColor=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0,1],t=Pe().size(4),a=e,r=!0,i=function(e){if(e.vertexShader().appendHeaderIfNotExists(b).appendBodyIfNotExists(x),e.fragmentShader().appendHeaderIfNotExists(me).appendBodyIfNotExists(Se),Array.isArray(a))e.buffers().attribute("aStrokeColor",Ke(a).size(4));else{if("function"!=typeof a)throw new Error("Expected value to be an array or function, received ".concat(a));if(!r)return;t.value(a),e.buffers().attribute("aStrokeColor",t)}r=!1};return i.value=function(){return arguments.length?(a!==(arguments.length<=0?void 0:arguments[0])&&(a=arguments.length<=0?void 0:arguments[0],r=!0),i):a},n.rebind(i,t,"data"),i},e.webglSymbolMapper=function(e){switch(e){case a.symbolCircle:return _e();case a.symbolSquare:return n=c(d),t=c(s),n.appendHeader(C).appendBody(D),t.appendHeader(J).appendBody($),{vertex:function(){return n},fragment:function(){return t}};case a.symbolTriangle:return function(){var e=c(d),n=c(s);return e.appendHeader(E).appendBody(N),n.appendHeader(te).appendBody(ae),{vertex:function(){return e},fragment:function(){return n}}}();case a.symbolCross:return function(){var e=c(d),n=c(s);return e.appendHeader(z).appendBody(P),n.appendHeader(re).appendBody(ie),{vertex:function(){return e},fragment:function(){return n}}}();case a.symbolDiamond:return function(){var e=c(d),n=c(s);return e.appendHeader(w).appendBody(A),n.appendHeader(ee).appendBody(ne),{vertex:function(){return e},fragment:function(){return n}}}();case a.symbolStar:return function(){var e=c(d),n=c(s);return e.appendHeader(y).appendBody(m),n.appendHeader(Q).appendBody(j),{vertex:function(){return e},fragment:function(){return n}}}();case a.symbolWye:return function(){var e=c(d),n=c(s);return e.appendHeader(S).appendBody(V),n.appendHeader(Z).appendBody(K),{vertex:function(){return e},fragment:function(){return n}}}();default:throw new Error("Unrecognised symbol: ".concat(e))}var n,t},e.webglTypes=we,e.webglUniform=o,Object.defineProperty(e,"__esModule",{value:!0})}(n,t(741),t(427),t(5317))}}]);
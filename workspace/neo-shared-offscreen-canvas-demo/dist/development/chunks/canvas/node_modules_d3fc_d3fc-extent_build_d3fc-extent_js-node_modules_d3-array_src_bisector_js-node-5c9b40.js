(self["webpackChunkmainapp"] = self["webpackChunkmainapp"] || []).push([["node_modules_d3fc_d3fc-extent_build_d3fc-extent_js-node_modules_d3-array_src_bisector_js-node-5c9b40"],{

/***/ "./node_modules/@d3fc/d3fc-extent/build/d3fc-extent.js":
/*!*************************************************************!*\
  !*** ./node_modules/@d3fc/d3fc-extent/build/d3fc-extent.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/index.js")) :
  0;
}(this, function (exports, d3Array) { 'use strict';

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function linearExtent () {
    var accessors = [function (d) {
      return d;
    }];
    var pad = [0, 0];
    var padUnit = 'percent';
    var symmetricalAbout = null;
    var include = [];

    var instance = function instance(data) {
      var values = new Array(data.length);

      for (var _i = 0, _accessors = accessors; _i < _accessors.length; _i++) {
        var accessor = _accessors[_i];

        for (var i = 0; i < data.length; i++) {
          var value = accessor(data[i], i);

          if (Array.isArray(value)) {
            values.push.apply(values, _toConsumableArray(value));
          } else {
            values.push(value);
          }
        }
      }

      var extent = [d3Array.min(values), d3Array.max(values)];
      extent[0] = extent[0] == null ? d3Array.min(include) : d3Array.min([extent[0]].concat(_toConsumableArray(include)));
      extent[1] = extent[1] == null ? d3Array.max(include) : d3Array.max([extent[1]].concat(_toConsumableArray(include)));

      if (symmetricalAbout != null) {
        var halfRange = Math.max(Math.abs(extent[1] - symmetricalAbout), Math.abs(extent[0] - symmetricalAbout));
        extent[0] = symmetricalAbout - halfRange;
        extent[1] = symmetricalAbout + halfRange;
      }

      switch (padUnit) {
        case 'domain':
          {
            extent[0] -= pad[0];
            extent[1] += pad[1];
            break;
          }

        case 'percent':
          {
            var delta = extent[1] - extent[0];
            extent[0] -= pad[0] * delta;
            extent[1] += pad[1] * delta;
            break;
          }

        default:
          throw new Error("Unknown padUnit: ".concat(padUnit));
      }

      return extent;
    };

    instance.accessors = function () {
      if (!arguments.length) {
        return accessors;
      }

      accessors = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.pad = function () {
      if (!arguments.length) {
        return pad;
      }

      pad = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.padUnit = function () {
      if (!arguments.length) {
        return padUnit;
      }

      padUnit = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.include = function () {
      if (!arguments.length) {
        return include;
      }

      include = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.symmetricalAbout = function () {
      if (!arguments.length) {
        return symmetricalAbout;
      }

      symmetricalAbout = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    return instance;
  }

  function time () {
    var accessors = [];
    var pad = [0, 0];
    var padUnit = 'percent';
    var symmetricalAbout = null;
    var include = [];
    var extent = linearExtent();

    var valueOf = function valueOf(date) {
      return date != null ? date.valueOf() : null;
    };

    var instance = function instance(data) {
      var adaptedAccessors = accessors.map(function (accessor) {
        return function () {
          var value = accessor.apply(void 0, arguments);
          return Array.isArray(value) ? value.map(valueOf) : valueOf(value);
        };
      });
      extent.accessors(adaptedAccessors).pad(pad).padUnit(padUnit).symmetricalAbout(symmetricalAbout != null ? symmetricalAbout.valueOf() : null).include(include.map(function (date) {
        return date.valueOf();
      }));
      return extent(data).map(function (value) {
        return new Date(value);
      });
    };

    instance.accessors = function () {
      if (!arguments.length) {
        return accessors;
      }

      accessors = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.pad = function () {
      if (!arguments.length) {
        return pad;
      }

      pad = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.padUnit = function () {
      if (!arguments.length) {
        return padUnit;
      }

      padUnit = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.include = function () {
      if (!arguments.length) {
        return include;
      }

      include = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    instance.symmetricalAbout = function () {
      if (!arguments.length) {
        return symmetricalAbout;
      }

      symmetricalAbout = arguments.length <= 0 ? undefined : arguments[0];
      return instance;
    };

    return instance;
  }

  exports.extentDate = time;
  exports.extentLinear = linearExtent;
  exports.extentTime = time;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ticks),
/* harmony export */   "tickIncrement": () => (/* binding */ tickIncrement),
/* harmony export */   "tickStep": () => (/* binding */ tickStep)
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy9ub2RlX21vZHVsZXNfZDNmY19kM2ZjLWV4dGVudF9idWlsZF9kM2ZjLWV4dGVudF9qcy1ub2RlX21vZHVsZXNfZDMtYXJyYXlfc3JjX2Jpc2VjdG9yX2pzLW5vZGUtNWM5YjQwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHNEQUFVO0FBQ3BHLEVBQUUsQ0FDMEU7QUFDNUUsQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjs7QUFFcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLHdCQUF3QjtBQUN2RTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0TmM7QUFDZjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGdUM7QUFDRTs7QUFFMUI7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCLHlCQUF5Qix5REFBUztBQUNsQztBQUNBLElBQUk7QUFDSixxQkFBcUIscURBQVMsVUFBVSxzREFBVTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkRlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFpbmFwcC8uL25vZGVfbW9kdWxlcy9AZDNmYy9kM2ZjLWV4dGVudC9idWlsZC9kM2ZjLWV4dGVudC5qcyIsIndlYnBhY2s6Ly9tYWluYXBwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vbWFpbmFwcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0b3IuanMiLCJ3ZWJwYWNrOi8vbWFpbmFwcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZGVzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9tYWluYXBwLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aWNrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1hcnJheSddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZmMgPSBnbG9iYWwuZmMgfHwge30sIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNBcnJheSkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZWFyRXh0ZW50ICgpIHtcbiAgICB2YXIgYWNjZXNzb3JzID0gW2Z1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XTtcbiAgICB2YXIgcGFkID0gWzAsIDBdO1xuICAgIHZhciBwYWRVbml0ID0gJ3BlcmNlbnQnO1xuICAgIHZhciBzeW1tZXRyaWNhbEFib3V0ID0gbnVsbDtcbiAgICB2YXIgaW5jbHVkZSA9IFtdO1xuXG4gICAgdmFyIGluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2UoZGF0YSkge1xuICAgICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2FjY2Vzc29ycyA9IGFjY2Vzc29yczsgX2kgPCBfYWNjZXNzb3JzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgYWNjZXNzb3IgPSBfYWNjZXNzb3JzW19pXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhY2Nlc3NvcihkYXRhW2ldLCBpKTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZXh0ZW50ID0gW2QzQXJyYXkubWluKHZhbHVlcyksIGQzQXJyYXkubWF4KHZhbHVlcyldO1xuICAgICAgZXh0ZW50WzBdID0gZXh0ZW50WzBdID09IG51bGwgPyBkM0FycmF5Lm1pbihpbmNsdWRlKSA6IGQzQXJyYXkubWluKFtleHRlbnRbMF1dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5jbHVkZSkpKTtcbiAgICAgIGV4dGVudFsxXSA9IGV4dGVudFsxXSA9PSBudWxsID8gZDNBcnJheS5tYXgoaW5jbHVkZSkgOiBkM0FycmF5Lm1heChbZXh0ZW50WzFdXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGluY2x1ZGUpKSk7XG5cbiAgICAgIGlmIChzeW1tZXRyaWNhbEFib3V0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGhhbGZSYW5nZSA9IE1hdGgubWF4KE1hdGguYWJzKGV4dGVudFsxXSAtIHN5bW1ldHJpY2FsQWJvdXQpLCBNYXRoLmFicyhleHRlbnRbMF0gLSBzeW1tZXRyaWNhbEFib3V0KSk7XG4gICAgICAgIGV4dGVudFswXSA9IHN5bW1ldHJpY2FsQWJvdXQgLSBoYWxmUmFuZ2U7XG4gICAgICAgIGV4dGVudFsxXSA9IHN5bW1ldHJpY2FsQWJvdXQgKyBoYWxmUmFuZ2U7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocGFkVW5pdCkge1xuICAgICAgICBjYXNlICdkb21haW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4dGVudFswXSAtPSBwYWRbMF07XG4gICAgICAgICAgICBleHRlbnRbMV0gKz0gcGFkWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3BlcmNlbnQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIGV4dGVudFswXSAtPSBwYWRbMF0gKiBkZWx0YTtcbiAgICAgICAgICAgIGV4dGVudFsxXSArPSBwYWRbMV0gKiBkZWx0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcGFkVW5pdDogXCIuY29uY2F0KHBhZFVuaXQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuYWNjZXNzb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NvcnM7XG4gICAgICB9XG5cbiAgICAgIGFjY2Vzc29ycyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UucGFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwYWQ7XG4gICAgICB9XG5cbiAgICAgIHBhZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UucGFkVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFkVW5pdDtcbiAgICAgIH1cblxuICAgICAgcGFkVW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuaW5jbHVkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgIH1cblxuICAgICAgaW5jbHVkZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2Uuc3ltbWV0cmljYWxBYm91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3ltbWV0cmljYWxBYm91dDtcbiAgICAgIH1cblxuICAgICAgc3ltbWV0cmljYWxBYm91dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZSAoKSB7XG4gICAgdmFyIGFjY2Vzc29ycyA9IFtdO1xuICAgIHZhciBwYWQgPSBbMCwgMF07XG4gICAgdmFyIHBhZFVuaXQgPSAncGVyY2VudCc7XG4gICAgdmFyIHN5bW1ldHJpY2FsQWJvdXQgPSBudWxsO1xuICAgIHZhciBpbmNsdWRlID0gW107XG4gICAgdmFyIGV4dGVudCA9IGxpbmVhckV4dGVudCgpO1xuXG4gICAgdmFyIHZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKGRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlICE9IG51bGwgPyBkYXRlLnZhbHVlT2YoKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBpbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKGRhdGEpIHtcbiAgICAgIHZhciBhZGFwdGVkQWNjZXNzb3JzID0gYWNjZXNzb3JzLm1hcChmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhY2Nlc3Nvci5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHZhbHVlT2YpIDogdmFsdWVPZih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGV4dGVudC5hY2Nlc3NvcnMoYWRhcHRlZEFjY2Vzc29ycykucGFkKHBhZCkucGFkVW5pdChwYWRVbml0KS5zeW1tZXRyaWNhbEFib3V0KHN5bW1ldHJpY2FsQWJvdXQgIT0gbnVsbCA/IHN5bW1ldHJpY2FsQWJvdXQudmFsdWVPZigpIDogbnVsbCkuaW5jbHVkZShpbmNsdWRlLm1hcChmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZXh0ZW50KGRhdGEpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5hY2Nlc3NvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc29ycztcbiAgICAgIH1cblxuICAgICAgYWNjZXNzb3JzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5wYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhZDtcbiAgICAgIH1cblxuICAgICAgcGFkID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5wYWRVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwYWRVbml0O1xuICAgICAgfVxuXG4gICAgICBwYWRVbml0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5pbmNsdWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgfVxuXG4gICAgICBpbmNsdWRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5zeW1tZXRyaWNhbEFib3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzeW1tZXRyaWNhbEFib3V0O1xuICAgICAgfVxuXG4gICAgICBzeW1tZXRyaWNhbEFib3V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBleHBvcnRzLmV4dGVudERhdGUgPSB0aW1lO1xuICBleHBvcnRzLmV4dGVudExpbmVhciA9IGxpbmVhckV4dGVudDtcbiAgZXhwb3J0cy5leHRlbnRUaW1lID0gdGltZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA9PSBudWxsIHx8IGIgPT0gbnVsbCA/IE5hTiA6IGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmlzZWN0b3IoZikge1xuICBsZXQgY29tcGFyZTEsIGNvbXBhcmUyLCBkZWx0YTtcblxuICAvLyBJZiBhbiBhY2Nlc3NvciBpcyBzcGVjaWZpZWQsIHByb21vdGUgaXQgdG8gYSBjb21wYXJhdG9yLiBJbiB0aGlzIGNhc2Ugd2VcbiAgLy8gY2FuIHRlc3Qgd2hldGhlciB0aGUgc2VhcmNoIHZhbHVlIGlzIChzZWxmLSkgY29tcGFyYWJsZS4gV2UgY2Fu4oCZdCBkbyB0aGlzXG4gIC8vIGZvciBhIGNvbXBhcmF0b3IgKGV4Y2VwdCBmb3Igc3BlY2lmaWMsIGtub3duIGNvbXBhcmF0b3JzKSBiZWNhdXNlIHdlIGNhbuKAmXRcbiAgLy8gdGVsbCBpZiB0aGUgY29tcGFyYXRvciBpcyBzeW1tZXRyaWMsIGFuZCBhbiBhc3ltbWV0cmljIGNvbXBhcmF0b3IgY2Fu4oCZdCBiZVxuICAvLyB1c2VkIHRvIHRlc3Qgd2hldGhlciBhIHNpbmdsZSB2YWx1ZSBpcyBjb21wYXJhYmxlLlxuICBpZiAoZi5sZW5ndGggIT09IDIpIHtcbiAgICBjb21wYXJlMSA9IGFzY2VuZGluZztcbiAgICBjb21wYXJlMiA9IChkLCB4KSA9PiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7XG4gIH0gZWxzZSB7XG4gICAgY29tcGFyZTEgPSBmID09PSBhc2NlbmRpbmcgfHwgZiA9PT0gZGVzY2VuZGluZyA/IGYgOiB6ZXJvO1xuICAgIGNvbXBhcmUyID0gZjtcbiAgICBkZWx0YSA9IGY7XG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvID0gMCwgaGkgPSBhLmxlbmd0aCkge1xuICAgIGlmIChsbyA8IGhpKSB7XG4gICAgICBpZiAoY29tcGFyZTEoeCwgeCkgIT09IDApIHJldHVybiBoaTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH0gd2hpbGUgKGxvIDwgaGkpO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiByaWdodChhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBpZiAobG8gPCBoaSkge1xuICAgICAgaWYgKGNvbXBhcmUxKHgsIHgpICE9PSAwKSByZXR1cm4gaGk7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPD0gMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfSB3aGlsZSAobG8gPCBoaSk7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgY2VudGVyLCByaWdodH07XG59XG5cbmZ1bmN0aW9uIHplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOXG4gICAgOiBiIDwgYSA/IC0xXG4gICAgOiBiID4gYSA/IDFcbiAgICA6IGIgPj0gYSA/IDBcbiAgICA6IE5hTjtcbn1cbiIsInZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGlja3Moc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgbGV0IHIwID0gTWF0aC5yb3VuZChzdGFydCAvIHN0ZXApLCByMSA9IE1hdGgucm91bmQoc3RvcCAvIHN0ZXApO1xuICAgIGlmIChyMCAqIHN0ZXAgPCBzdGFydCkgKytyMDtcbiAgICBpZiAocjEgKiBzdGVwID4gc3RvcCkgLS1yMTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gcjEgLSByMCArIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChyMCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGVwID0gLXN0ZXA7XG4gICAgbGV0IHIwID0gTWF0aC5yb3VuZChzdGFydCAqIHN0ZXApLCByMSA9IE1hdGgucm91bmQoc3RvcCAqIHN0ZXApO1xuICAgIGlmIChyMCAvIHN0ZXAgPCBzdGFydCkgKytyMDtcbiAgICBpZiAocjEgLyBzdGVwID4gc3RvcCkgLS1yMTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gcjEgLSByMCArIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChyMCArIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
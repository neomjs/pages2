(self["webpackChunkmainapp"] = self["webpackChunkmainapp"] || []).push([["vendors-node_modules_d3fc_d3fc-webgl_build_d3fc-webgl_js"],{

/***/ "./node_modules/@d3fc/d3fc-webgl/build/d3fc-webgl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@d3fc/d3fc-webgl/build/d3fc-webgl.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(/*! @d3fc/d3fc-rebind */ "./node_modules/@d3fc/d3fc-rebind/index.js"), __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/index.js"), __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js")) :
    0;
}(this, (function (exports, d3fcRebind, d3Scale, d3Shape) { 'use strict';

    var baseScale = (function () {
      var domain = [0, 1];
      var range = [-1, 1];

      var base = function base() {};

      base.domain = function () {
        if (!arguments.length) {
          return domain;
        }

        domain = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.range = function () {
        if (!arguments.length) {
          return range;
        }

        range = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var bufferBuilder = (function () {
      var attributes = {};
      var uniforms = {};
      var elementIndices = null;

      var bufferBuilder = function bufferBuilder(programBuilder, program) {
        var gl = programBuilder.context();
        Object.keys(attributes).forEach(function (name) {
          var attribute = attributes[name];

          if (typeof attribute !== 'function') {
            throw new Error("Expected an attribute for ".concat(name, ", found ").concat(attribute));
          }

          var location = gl.getAttribLocation(program, name);
          attribute.location(location)(programBuilder);
        });
        Object.keys(uniforms).forEach(function (name) {
          var uniform = uniforms[name];

          if (typeof uniform !== 'function') {
            throw new Error("Expected a uniform for ".concat(name, ", found ").concat(uniform));
          }

          var location = gl.getUniformLocation(program, name);
          uniform.location(location)(programBuilder);
        });

        if (elementIndices !== null) {
          elementIndices(programBuilder);
        }
      };

      bufferBuilder.flush = function () {
        Object.values(attributes).forEach(function (attribute) {
          return attribute.clear();
        });
        Object.values(uniforms).forEach(function (uniform) {
          return uniform.clear();
        });
        if (elementIndices !== null) elementIndices.clear();
      };

      bufferBuilder.attribute = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1) {
          return attributes[args[0]];
        }

        attributes[args[0]] = args[1];
        return bufferBuilder;
      };

      bufferBuilder.uniform = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (args.length === 1) {
          return uniforms[args[0]];
        }

        uniforms[args[0]] = args[1];
        return bufferBuilder;
      };

      bufferBuilder.elementIndices = function () {
        if (!arguments.length) {
          return elementIndices;
        }

        elementIndices = arguments.length <= 0 ? undefined : arguments[0];
        return bufferBuilder;
      };

      return bufferBuilder;
    });

    var uniform = (function (initialData) {
      var location = -1;
      var data = initialData;
      var dirty = true;

      var build = function build(programBuilder) {
        if (!dirty) {
          return;
        }

        var gl = programBuilder.context();

        if (Array.isArray(data)) {
          switch (data.length) {
            case 1:
              gl.uniform1fv(location, data);
              break;

            case 2:
              gl.uniform2fv(location, data);
              break;

            case 3:
              gl.uniform3fv(location, data);
              break;

            case 4:
              gl.uniform4fv(location, data);
              break;

            default:
              throw new Error("Uniform supports up to 4 elements. ".concat(data.length, " provided."));
          }
        } else {
          gl.uniform1f(location, data);
        }

        dirty = false;
      };

      build.clear = function () {
        dirty = true;
      };

      build.location = function () {
        if (!arguments.length) {
          return location;
        }

        if (location !== (arguments.length <= 0 ? undefined : arguments[0])) {
          location = arguments.length <= 0 ? undefined : arguments[0];
          dirty = true;
        }

        return build;
      };

      build.data = function () {
        if (!arguments.length) {
          return data;
        }

        data = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return build;
      };

      return build;
    });

    var drawModes = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };

    var programBuilder = (function () {
      var context = null;
      var program = null;
      var vertexShader = null;
      var fragmentShader = null;
      var programVertexShader = null;
      var programFragmentShader = null;
      var mode = drawModes.TRIANGLES;
      var subInstanceCount = 0;
      var buffers = bufferBuilder();
      var debug = false;
      var extInstancedArrays = null;
      var dirty = true;
      var pixelRatio = 1;

      var build = function build(count) {
        if (context == null) {
          return;
        }

        var vertexShaderSource = vertexShader();
        var fragmentShaderSource = fragmentShader();

        if (newProgram(program, vertexShaderSource, fragmentShaderSource)) {
          program = createProgram(vertexShaderSource, fragmentShaderSource);
          programVertexShader = vertexShaderSource;
          programFragmentShader = fragmentShaderSource;
          dirty = false;
        }

        context.useProgram(program);
        buffers.uniform('uScreen', uniform([context.canvas.width / pixelRatio, context.canvas.height / pixelRatio]));
        buffers(build, program);

        if (subInstanceCount === 0) {
          if (buffers.elementIndices() == null) {
            context.drawArrays(mode, 0, count);
          } else {
            context.drawElements(mode, count, context.UNSIGNED_SHORT, 0);
          }
        } else {
          if (buffers.elementIndices() == null) {
            extInstancedArrays.drawArraysInstancedANGLE(mode, 0, subInstanceCount, count);
          } else {
            var elementIndicesLength = buffers.elementIndices().data().length;

            if (subInstanceCount !== elementIndicesLength) {
              throw new Error("Expected elementIndices length ".concat(elementIndicesLength) + " to match subInstanceCount ".concat(subInstanceCount, "."));
            }

            extInstancedArrays.drawElementsInstancedANGLE(mode, subInstanceCount, context.UNSIGNED_SHORT, 0, count);
          }
        }
      };

      build.extInstancedArrays = function () {
        return extInstancedArrays;
      };

      build.context = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!args.length) {
          return context;
        }

        if (args[0] == null || args[0] !== context) {
          buffers.flush();
          dirty = true;
        }

        if (args[0] != null && args[0] !== context) {
          extInstancedArrays = args[0].getExtension('ANGLE_instanced_arrays');
        }

        context = args[0];
        return build;
      };

      build.buffers = function () {
        if (!arguments.length) {
          return buffers;
        }

        buffers = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.vertexShader = function () {
        if (!arguments.length) {
          return vertexShader;
        }

        vertexShader = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.fragmentShader = function () {
        if (!arguments.length) {
          return fragmentShader;
        }

        fragmentShader = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.mode = function () {
        if (!arguments.length) {
          return mode;
        }

        mode = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.subInstanceCount = function () {
        if (!arguments.length) {
          return subInstanceCount;
        }

        subInstanceCount = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.debug = function () {
        if (!arguments.length) {
          return debug;
        }

        debug = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      build.pixelRatio = function () {
        if (!arguments.length) {
          return pixelRatio;
        }

        pixelRatio = arguments.length <= 0 ? undefined : arguments[0];
        return build;
      };

      return build;

      function newProgram(program, vertexShader, fragmentShader) {
        if (!program || dirty) {
          return true;
        }

        return vertexShader !== programVertexShader || fragmentShader !== programFragmentShader;
      }

      function createProgram(vertexShaderSource, fragmentShaderSource) {
        var vertexShader = loadShader(vertexShaderSource, context.VERTEX_SHADER);
        var fragmentShader = loadShader(fragmentShaderSource, context.FRAGMENT_SHADER);
        var program = context.createProgram();
        context.attachShader(program, vertexShader);
        context.attachShader(program, fragmentShader);
        context.linkProgram(program);

        if (debug && !context.getProgramParameter(program, context.LINK_STATUS)) {
          var message = context.getProgramInfoLog(program);
          context.deleteProgram(program);
          throw new Error("Failed to link program : ".concat(message, "\n            Vertex Shader : ").concat(vertexShaderSource, "\n            Fragment Shader : ").concat(fragmentShaderSource));
        }

        return program;
      }

      function loadShader(source, type) {
        var shader = context.createShader(type);
        context.shaderSource(shader, source);
        context.compileShader(shader);

        if (debug && !context.getShaderParameter(shader, context.COMPILE_STATUS)) {
          var message = context.getShaderInfoLog(shader);
          context.deleteShader(shader);
          throw new Error("Failed to compile shader : ".concat(message, "\n            Shader : ").concat(source));
        }

        return shader;
      }
    });

    var shaderBuilder = (function (base) {
      var shaderHeaders = [];
      var shaderBodies = [];

      var build = function build() {
        return base(shaderHeaders.join('\n'), shaderBodies.join('\n'));
      };

      function append(array, element) {
        array.push(element);
      }

      function insert(array, element, before) {
        var beforeIndex = array.indexOf(before);
        array.splice(beforeIndex >= 0 ? beforeIndex : array.length, 0, element);
      }

      function appendIfNotExists(array, element) {
        var elementIndex = array.indexOf(element);

        if (elementIndex === -1) {
          array.push(element);
        }
      }

      build.appendHeader = function (header) {
        append(shaderHeaders, header);
        return build;
      };

      build.insertHeader = function (header, before) {
        insert(shaderHeaders, header, before);
        return build;
      };

      build.appendHeaderIfNotExists = function (header) {
        appendIfNotExists(shaderHeaders, header);
        return build;
      };

      build.appendBody = function (body) {
        append(shaderBodies, body);
        return build;
      };

      build.insertBody = function (body, before) {
        insert(shaderBodies, body, before);
        return build;
      };

      build.appendBodyIfNotExists = function (body) {
        appendIfNotExists(shaderBodies, body);
        return build;
      };

      return build;
    }); // inf is precalculated here for use in some functions (e.g. log scale calculations)

    var vertexShaderBase = function vertexShaderBase(header, body) {
      return "\nprecision mediump float;\nfloat inf = 1.0 / 0.0;\n".concat(header, "\nvoid main() {\n    ").concat(body, "\n}");
    };
    var fragmentShaderBase = function fragmentShaderBase(header, body) {
      return "\nprecision mediump float;\n".concat(header, "\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ").concat(body, "\n}");
    };

    var fillColor = {
      header: "attribute vec4 aFillColor;\n             varying vec4 vFillColor;",
      body: "vFillColor = aFillColor;"
    };
    var strokeColor = {
      header: "attribute vec4 aStrokeColor;\n             varying vec4 vStrokeColor;",
      body: "vStrokeColor = aStrokeColor;"
    };
    var circle = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 2.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var star = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 4.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var wye = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 3.14159);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var square = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var diamond = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = sqrt(aSize);\n        gl_PointSize = 2.0 * (vSize + uStrokeWidth + 1.0);\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var triangle = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = sqrt((16.0 * aSize) / (3.0 * sqrt(3.0)));\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var cross = {
      header: "\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aSize;\n        attribute float aDefined;\n\n        uniform float uStrokeWidth;\n\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vSize = 3.0 * sqrt(aSize / 5.0);\n        vStrokeWidthRatio = uStrokeWidth / (vSize + uStrokeWidth + 1.0);\n        gl_PointSize = vSize + uStrokeWidth + 1.0;\n        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);"
    };
    var candlestick = {
      header: "\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n         (isPositiveY * isExtremeY * aLowValue) +\n         (isPositiveY * isNotExtremeY * aCloseValue) +\n         (isNotPositiveY * isNotExtremeY * aOpenValue) +\n         (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = (isNotExtremeY * aCorner.x) + (isExtremeY * aCorner.z);\n        float lineWidthYDirection = isNotExtremeY * sign(aCloseValue - aOpenValue) * aCorner.y;\n\n        float bandwidthModifier = aBandwidth * aCorner.x / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"
    };
    var ohlc = {
      header: "\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aOpenValue;\n        attribute float aCloseValue;\n        attribute float aLowValue;\n        attribute vec3 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        vColorIndicator = sign(aCloseValue - aOpenValue);\n\n        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;\n        float isNotPositiveY = 1.0 - isPositiveY;\n        float isExtremeY = abs(aCorner.y) - 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n        float yValue =\n            (isPositiveY * isExtremeY * aLowValue) +\n            (isPositiveY * isNotExtremeY * aCloseValue) +\n            (isNotPositiveY * isNotExtremeY * aOpenValue) +\n            (isNotPositiveY * isExtremeY * aHighValue);\n\n        float lineWidthXDirection = isExtremeY * aCorner.z;\n        float lineWidthYDirection = isNotExtremeY * aCorner.z;\n\n        float bandwidthModifier = isNotExtremeY * aCorner.x * aBandwidth / 2.0;\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;\n        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"
    };
    var bar = {
      header: "\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aMainValue;\n        attribute float aBaseValue;\n        attribute vec2 aCorner;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        float isBaseline = (1.0 - aCorner.y) / 2.0;\n        float yValue = (isBaseline * aBaseValue) + ((1.0 - isBaseline) * aMainValue);\n\n        float xModifier = aCorner.x * (aBandwidth) / 2.0;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);"
    };
    var errorBar = {
      header: "\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aHighValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;",
      body: "\n        vDefined = aDefined;\n        float isLow = (aCorner.y + 1.0) / 2.0;\n        float yValue = isLow * aLowValue + (1.0 - isLow) * aHighValue;\n\n        float isEdgeCorner = abs(aCorner.x);\n        float lineWidthXDirection = (1.0 - isEdgeCorner) * aCorner.z;\n        float lineWidthYDirection = isEdgeCorner * aCorner.z;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float xModifier = (uStrokeWidth * lineWidthXDirection) + (aBandwidth * aCorner.x / 2.0);\n        float yModifier = (uStrokeWidth * lineWidthYDirection);"
    };
    var area = {
      header: "\n        attribute vec3 aCorner;\n        attribute float aCrossValue;\n        attribute float aMainValue;\n        attribute float aCrossNextValue;\n        attribute float aMainNextValue;\n        attribute float aBaseValue;\n        attribute float aBaseNextValue;\n        attribute float aDefined;\n        attribute float aDefinedNext;\n\n        varying float vDefined;\n\n        float when_lt(float a, float b) {\n            return max(sign(b - a), 0.0);\n        }\n\n        float and(float a, float b) {\n            return a * b;\n        }",
      body: "\n        vDefined = aDefined * aDefinedNext;\n        gl_Position = vec4(0, 0, 0, 1);\n\n        float hasIntercepted = when_lt((aMainNextValue - aBaseNextValue) * (aMainValue - aBaseValue), 0.0);\n        float useIntercept = and(aCorner.z, hasIntercepted);\n\n        float yGradient = (aMainNextValue - aMainValue) / (aCrossNextValue - aCrossValue);\n        float yConstant = aMainNextValue - (yGradient * aCrossNextValue);\n\n        float y0Gradient = (aBaseNextValue - aBaseValue) / (aCrossNextValue - aCrossValue);\n        float y0Constant = aBaseNextValue - (y0Gradient * aCrossNextValue);\n\n        float denominator = (yGradient - y0Gradient) + step(abs(yGradient - y0Gradient), 0.0);\n        float interceptXValue = (y0Constant - yConstant) / denominator;\n        float interceptYValue = (yGradient * interceptXValue) + yConstant;\n\n        gl_Position = vec4(interceptXValue * useIntercept, interceptYValue * useIntercept, 0, 1);\n\n        gl_Position.x += (1.0 - useIntercept) * ((aCorner.x * aCrossNextValue) + ((1.0 - aCorner.x) * aCrossValue));\n        gl_Position.y += (1.0 - useIntercept) * (1.0 - aCorner.y) * ((aCorner.x * aMainNextValue) + ((1.0 - aCorner.x) * aMainValue));\n        gl_Position.y += (1.0 - useIntercept) * aCorner.y * ((aCorner.x * aBaseNextValue) + ((1.0 - aCorner.x) * aBaseValue));"
    };
    var boxPlot = {
      header: "\n        attribute vec4 aCorner;\n        attribute float aCrossValue;\n        attribute float aBandwidth;\n        attribute float aCapWidth;\n        attribute float aHighValue;\n        attribute float aUpperQuartileValue;\n        attribute float aMedianValue;\n        attribute float aLowerQuartileValue;\n        attribute float aLowValue;\n        attribute float aDefined;\n\n        uniform vec2 uScreen;\n        uniform float uStrokeWidth;\n\n        varying float vDefined;\n    ",
      body: "\n        vDefined = aDefined;\n        float isExtremeY = sign(abs(aCorner.y) - 2.0) + 1.0;\n        float isNotExtremeY = 1.0 - isExtremeY;\n\n        float isNonZeroY = abs(sign(aCorner.y));\n        float isZeroY = 1.0 - isNonZeroY;\n\n        float isQuartileY = isNotExtremeY * isNonZeroY;\n\n        float isPositiveY = (sign(aCorner.y + 0.5) + 1.0) / 2.0;\n        float isNegativeY = 1.0 - isPositiveY;\n\n        float yValue =\n          (isExtremeY * isNegativeY) * aHighValue +\n          (isQuartileY * isNegativeY) * aUpperQuartileValue +\n          isZeroY * aMedianValue +\n          (isQuartileY * isPositiveY) * aLowerQuartileValue +\n          (isExtremeY * isPositiveY) * aLowValue;\n\n        gl_Position = vec4(aCrossValue, yValue, 0, 1);\n\n        float isHorizontal = aCorner.w;\n        float isVertical = 1.0 - isHorizontal;\n\n        float xDisplacement = aCorner.x * (isExtremeY * aCapWidth + isNotExtremeY * aBandwidth) / 2.0;\n\n        float xModifier = (isVertical * uStrokeWidth * aCorner.z / 2.0) + xDisplacement;\n        float yModifier = isHorizontal * uStrokeWidth * aCorner.z / 2.0;"
    };

    var circle$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float distance = length(2.0 * gl_PointCoord - 1.0);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"
    }; // See https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm.

    var star$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;\n\n        // anterior, exterior angles\n        float an = 0.628319;\n        vec2 acs = vec2(0.809017, 0.587786); // (cos, sin)\n        float en = 0.952000;\n        vec2 ecs = vec2(0.580055, 0.814577);\n    ",
      body: "\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        p -= acs;\n        p += ecs * clamp(-dot(p, ecs), 0.0, acs.y / ecs.y);\n        float d = length(p) * sign(p.x);\n\n        float distance = 1.0 + d;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"
    };
    var wye$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;\n    ",
      body: "\n        float canFill = 1.0;\n\n        vec2 p = 2.0 * gl_PointCoord - 1.0;\n        p.y *= -1.0;\n\n        // sector\n        float an = 3.141593 / 3.0;\n        float bn = mod(atan(p.x, p.y), 2.0 * an) - an;\n        p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n        // box\n        vec2 d = abs(p) - vec2(0.9, 0.35);\n        float sdf = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n\n        float distance = 1.0 + sdf;\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n            return;\n        }"
    };
    var square$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float distance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);"
    }; // Diamond is symmetrical about the x, and y axes, so only consider x, y > 0.
    // (x, y) are the coordinates of the fragment within the gl point (after
    // transformed to be [-1, 1]).
    // a, b control the width, height of the triangle, so diamond is 2a, 2b.
    // Line L is a ray from the origin through (x, y), the distance function is then
    // the distance to (x, y) divided by the distance to where L intersects with the
    // diamond, this makes the distance function < 1 inside, 1 on the boundary, and
    // > 1 outside the diamond.
    //    |
    // b ---
    //    |\             L
    //    | -\          /
    //    |   \        /
    //    |    \      /
    //    |     -\   /
    //    |       \ /
    // Y ---       X
    //    |       / -\
    //    |      /    \
    //    |     /      \
    // y ---   X        -\
    //    |   /           \
    //    |  /             \
    //    | /               -\
    //    |/                  \
    //    +----|---|-----------|---
    //         x   X           a

    var diamond$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;\n        float a = 0.6;\n        float b = 1.0;\n    ",
      body: "\n        if (vDefined < 0.5) {\n            discard;\n        }\n\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n\n        float x = abs(pointCoordTransform.x);\n        float y = abs(pointCoordTransform.y);\n\n        float X = (a * b * x) / (a * y + b * x);\n        float Y = (a * b * y) / (a * y + b * x);\n\n        float distance = length(vec2(x, y)) / length(vec2(X, Y));\n\n        if (distance > 1.0) {\n            discard;\n        }\n    "
    };
    var triangle$1 = {
      header: "\n        varying float vSize;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float topEdgesDistance = abs(pointCoordTransform.x) - ((pointCoordTransform.y - 0.6) / sqrt(3.0));\n        float bottomEdgeDistance = pointCoordTransform.y + 0.5;\n        float distance = max(topEdgesDistance, bottomEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }"
    };
    var cross$1 = {
      header: "\n        varying float vSize;\n        varying float vStrokeWidthRatio;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;\n        float innerCornerDistance = min(abs(pointCoordTransform.x), abs(pointCoordTransform.y)) + 0.66 - vStrokeWidthRatio;\n        float outerEdgeDistance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));\n        float distance = max(innerCornerDistance, outerEdgeDistance);\n        float canStroke = smoothstep(vSize - 2.0, vSize, distance * vSize);\n        if (distance > 1.0 || vDefined < 0.5) {\n            discard;\n        }"
    };
    var candlestick$1 = {
      header: "\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }"
    };
    var ohlc$1 = {
      header: "\n        varying float vColorIndicator;\n        varying float vDefined;",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.4, 0.8, 0, 1);\n        if (vColorIndicator < 0.0) {\n            gl_FragColor = vec4(0.8, 0.4, 0, 1);\n        }"
    };
    var area$1 = {
      header: "\n        varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float canStroke = 0.0;\n        if (vDefined < 0.5) {\n            discard;\n        }\n        gl_FragColor = vec4(0.86, 0.86, 0.86, 1);"
    };
    var boxPlot$1 = {
      header: "\n        varying float vDefined;\n    ",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };
    var errorBar$1 = {
      header: "varying float vDefined;",
      body: "\n        float canFill = 0.0;\n        float canStroke = 1.0;\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };
    var bar$1 = {
      header: "varying float vDefined;",
      body: "\n        float canFill = 1.0;\n        float canStroke = 0.0;\n\n        gl_FragColor = vec4(0.60, 0.60, 0.60, 1.0);\n\n        if (vDefined < 0.5) {\n            discard;\n        }"
    };
    var fillColor$1 = {
      header: "varying vec4 vFillColor;",
      body: "gl_FragColor = (canFill * vFillColor) + ((1.0 - canFill) * gl_FragColor);"
    };
    var strokeColor$1 = {
      header: "varying vec4 vStrokeColor;",
      body: "gl_FragColor = (canStroke * vStrokeColor) + ((1.0 - canStroke) * gl_FragColor);"
    };

    var areaShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(area.header).appendBody(area.body);
      fragmentShader.appendHeader(area$1.header).appendBody(area$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var types = {
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      FLOAT: 5126
    };
    function length(type) {
      switch (type) {
        case types.BYTE:
        case types.UNSIGNED_BYTE:
          return 1;

        case types.SHORT:
        case types.UNSIGNED_SHORT:
          return 2;

        case types.FLOAT:
          return 4;

        default:
          throw new Error("Unknown type ".concat(type));
      }
    }
    function getArrayViewConstructor(type) {
      switch (type) {
        case types.BYTE:
          return Int8Array;

        case types.UNSIGNED_BYTE:
          return Uint8Array;

        case types.SHORT:
          return Int16Array;

        case types.UNSIGNED_SHORT:
          return Uint16Array;

        case types.FLOAT:
          return Float32Array;

        default:
          throw new Error("Unknown type ".concat(type));
      }
    }

    var baseAttributeBuilder = (function () {
      var location = -1;
      var buffer = null;
      var size = 1; // per vertex

      var type = types.FLOAT;
      var normalized = false;
      var stride = 0;
      var offset = 0;
      var divisor = null;

      var baseAttribute = function baseAttribute(programBuilder) {
        var gl = programBuilder.context();

        if (buffer == null) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        gl.enableVertexAttribArray(location);
        var extInstancedArrays = programBuilder.extInstancedArrays();
        extInstancedArrays.vertexAttribDivisorANGLE(location, divisor != null ? divisor : programBuilder.subInstanceCount() > 0 ? 1 : 0);
      };

      baseAttribute.location = function () {
        if (!arguments.length) {
          return location;
        }

        location = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.buffer = function () {
        if (!arguments.length) {
          return buffer;
        }

        buffer = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.normalized = function () {
        if (!arguments.length) {
          return normalized;
        }

        normalized = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.stride = function () {
        if (!arguments.length) {
          return stride;
        }

        stride = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.offset = function () {
        if (!arguments.length) {
          return offset;
        }

        offset = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      baseAttribute.divisor = function () {
        if (!arguments.length) {
          return divisor;
        }

        divisor = arguments.length <= 0 ? undefined : arguments[0];
        return baseAttribute;
      };

      return baseAttribute;
    });

    var defaultArrayViewFactory = (function () {
      var type = types.FLOAT;
      var cachedArray = new Float32Array(0);

      var factory = function factory(requiredLength) {
        var ArrayType = getArrayViewConstructor(type);

        if (cachedArray.length > requiredLength) {
          cachedArray = new ArrayType(cachedArray.buffer, 0, requiredLength);
        } else if (cachedArray.length !== requiredLength) {
          cachedArray = new ArrayType(requiredLength);
        }

        return cachedArray;
      };

      factory.type = function () {
        if (!arguments.length) {
          return type;
        }

        if (type !== (arguments.length <= 0 ? undefined : arguments[0])) {
          type = arguments.length <= 0 ? undefined : arguments[0];
          var ArrayType = getArrayViewConstructor(type);
          cachedArray = new ArrayType(0);
        }

        return factory;
      };

      return factory;
    });

    var attributeProjector = (function () {
      var dirty = true;
      var size = 1; // per vertex

      var type = types.FLOAT;
      var arrayViewFactory = defaultArrayViewFactory();

      var value = function value(d, i) {
        return d;
      };

      var data = null;

      var projector = function projector() {
        var length = data.length;
        var projectedData = arrayViewFactory.type(type)(length * size);

        if (size > 1) {
          for (var i = 0; i < length; i++) {
            var componentValues = value(data[i], i);

            if (componentValues.length !== size) {
              throw new Error("Expected components array of size ".concat(size, ", recieved array with length ").concat(componentValues.length, "."));
            }

            for (var component = 0; component < size; component++) {
              projectedData[i * size + component] = componentValues[component];
            }
          }
        } else {
          for (var _i = 0; _i < length; _i++) {
            var componentValue = value(data[_i], _i);

            if (Array.isArray(componentValue)) {
              throw new Error("Expected a single component value, recieved array with length ".concat(componentValue.length, "."));
            }

            projectedData[_i] = componentValue;
          }
        }

        dirty = false;
        return projectedData;
      };

      projector.dirty = function () {
        return dirty;
      };

      projector.clear = function () {
        dirty = true;
      };

      projector.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.arrayViewFactory = function () {
        if (!arguments.length) {
          return arrayViewFactory;
        }

        arrayViewFactory = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      projector.data = function () {
        if (!arguments.length) {
          return data;
        }

        data = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return projector;
      };

      return projector;
    });

    var attribute = (function () {
      var base = baseAttributeBuilder();
      var projector = attributeProjector();

      var attribute = function attribute(programBuilder) {
        base.size(attribute.size()).type(attribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        var projectedData = projector();
        var gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, projectedData, gl.DYNAMIC_DRAW);
      };

      attribute.clear = function () {
        base.buffer(null);
        projector.clear();
      };

      d3fcRebind.rebind(attribute, base, 'normalized', 'location', 'divisor');
      d3fcRebind.rebind(attribute, projector, 'data', 'value', 'size', 'type');
      return attribute;
    });

    var rebindCurry = (function (target, targetName, source, sourceName) {
      for (var _len = arguments.length, curriedArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        curriedArgs[_key - 4] = arguments[_key];
      }

      target[targetName] = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var result = source[sourceName].apply(source, curriedArgs.concat(args));

        if (result === source) {
          return target;
        }

        return result;
      };
    });

    var area$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(6);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var cornerAttribute = attribute().divisor(0).size(3).type(types.UNSIGNED_BYTE).data([[0, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 0]]);
      program.buffers().attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = areaShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        decorate(program);
        program(numElements - 1);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'crossNextValueAttribute', program.buffers(), 'attribute', 'aCrossNextValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'mainNextValueAttribute', program.buffers(), 'attribute', 'aMainNextValue');
      rebindCurry(draw, 'baseValueAttribute', program.buffers(), 'attribute', 'aBaseValue');
      rebindCurry(draw, 'baseNextValueAttribute', program.buffers(), 'attribute', 'aBaseNextValue');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      rebindCurry(draw, 'definedNextAttribute', program.buffers(), 'attribute', 'aDefinedNext');
      return draw;
    });

    var circlePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(circle.header).appendBody(circle.body);
      fragmentShader.appendHeader(circle$1.header).appendBody(circle$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var point = (function () {
      var program = programBuilder().mode(drawModes.POINTS);
      var xScale = baseScale();
      var yScale = baseScale();
      var type = circlePointShader();

      var decorate = function decorate() {};

      var draw = function draw(numElements) {
        program.vertexShader(type.vertex()).fragmentShader(type.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        decorate(program);
        program(numElements);
      };

      draw.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'sizeAttribute', program.buffers(), 'attribute', 'aSize');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var lineWidthShader = (function () {
      var width = 1;

      var lineWidth = function lineWidth(program) {
        program.buffers().uniform('uStrokeWidth', uniform(width));
      };

      lineWidth.lineWidth = function () {
        if (!arguments.length) {
          return width;
        }

        width = arguments.length <= 0 ? undefined : arguments[0];
        return lineWidth;
      };

      return lineWidth;
    });

    var elementIndices = (function (initialData) {
      var buffer = null;
      var data = initialData;
      var dirty = true;

      var base = function base(programBuilder) {
        var gl = programBuilder.context();

        if (buffer == null) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);

        if (!dirty) {
          return;
        }

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW);
        dirty = false;
      };

      base.clear = function () {
        buffer = null;
        dirty = true;
      };

      base.data = function () {
        if (!arguments.length) {
          return data;
        }

        dirty = true;
        data = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var line = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(6);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var lineWidth = lineWidthShader();
      /*
          Line segment from a to b has vertices A, B, C, D -
             A |-------| B
              | \     |
              |a  \  b|
              |     \ |
            D |-------| C
           |AD| = uStrokeWidth
          |AB| = |ab| + uStrokeWidth
           Fragment shader implemented using line segment SDF 
          simplified for starting at the origin (a) -
          https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      */

      var cornerAttribute = attribute().divisor(0).size(4).type(types.BYTE).data([[-1, +1, 1, 0], [+1, +1, 0, 1], [+1, -1, 0, 1], [-1, -1, 1, 0]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 2, 3, 0])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var vertexShader = shaderBuilder(vertexShaderBase);
        var fragmentShader = shaderBuilder(fragmentShaderBase);
        program.vertexShader(vertexShader).fragmentShader(fragmentShader);
        vertexShader.appendHeader("\n            attribute vec4 aCorner;\n            attribute float aCrossValue;\n            attribute float aCrossNextValue;\n            attribute float aMainValue;\n            attribute float aMainNextValue;\n            attribute float aDefined;\n            attribute float aDefinedNext;\n\n            uniform float uStrokeWidth;\n            uniform vec2 uScreen;\n\n            varying float vLength;\n            varying vec2 vPosition;\n        ");
        vertexShader.appendBody("\n            vec4 value = vec4(aCrossValue, aMainValue, 0.0, 1.0);\n            vec4 nextValue = vec4(aCrossNextValue, aMainNextValue, 0.0, 1.0);\n        ");
        xScale(program, 'value', 0);
        xScale(program, 'nextValue', 0);
        yScale(program, 'value', 1);
        yScale(program, 'nextValue', 1);
        vertexShader.appendBody("\n            vec2 position = aCorner[2] * value.xy + aCorner[3] * nextValue.xy;\n\n            vec2 direction = normalize((nextValue.xy - value.xy) * uScreen);\n            vec2 normal = vec2(direction.y, -direction.x);\n            vec2 padding = ((uStrokeWidth / 2.0) / (uScreen / 2.0));\n            \n            padding *= aDefined * aDefinedNext;\n            position += (aCorner[0] * direction + aCorner[1] * normal) * padding;\n\n            gl_Position = vec4(position.x, position.y, 0.0, 1.0);\n\n            vLength = length((nextValue.xy - value.xy) * (uScreen / 2.0));\n            vPosition = aCorner.xy * (uStrokeWidth / 2.0);\n            vPosition.x += aCorner[3] * vLength;\n        "); // all fragment shader inputs are pixel denominated

        fragmentShader.appendHeader("\n            uniform float uStrokeWidth;\n            varying float vLength;\n            varying vec2 vPosition;\n\n            float canFill = 0.0;\n            float canStroke = 1.0;\n        ");
        fragmentShader.appendBody("\n            vec2 position = vPosition;\n            position.x -= clamp(position.x, 0.0, vLength);\n            float sdf = length(position) - uStrokeWidth / 2.0;\n            if (sdf > 0.5) {\n                discard;\n            }\n        ");
        lineWidth(program);
        decorate(program);
        program(numElements - 1);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'crossNextValueAttribute', program.buffers(), 'attribute', 'aCrossNextValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'mainNextValueAttribute', program.buffers(), 'attribute', 'aMainNextValue');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      rebindCurry(draw, 'definedNextAttribute', program.buffers(), 'attribute', 'aDefinedNext');
      return draw;
    });

    var ohlcShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(ohlc.header).appendBody(ohlc.body);
      fragmentShader.appendHeader(ohlc$1.header).appendBody(ohlc$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var ohlc$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(18);
      var xScale = baseScale();
      var yScale = baseScale();
      var lineWidth = lineWidthShader();

      var decorate = function decorate() {};
      /*
       * x-y coordinate to locate the "corners" of the element.
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: OPEN, 1: CLOSE, 2: LOW
       * Z - Follows convention for X/Y (appropriate direction will be selected by the shader): -1: LEFT/TOP, 1: RIGHT/BOTTOM
       */


      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([// Main stem
      [0, -2, -1], [0, -2, 1], [0, 2, 1], [0, 2, -1], // Open bar
      [-1, -1, -1], [-1, -1, 1], [0, -1, 1], [0, -1, -1], // Close bar
      [1, 1, 1], [0, 1, 1], [0, 1, -1], [1, 1, -1]]);
      program.buffers().elementIndices(elementIndices([// Main stem
      0, 1, 2, 0, 3, 2, // Open bar
      4, 5, 6, 4, 7, 6, // Close bar
      8, 9, 10, 10, 11, 8])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = ohlcShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x * 2.0;\n          gl_Position.y += yModifier / uScreen.y * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'openValueAttribute', program.buffers(), 'attribute', 'aOpenValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'closeValueAttribute', program.buffers(), 'attribute', 'aCloseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var barShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(bar.header).appendBody(bar.body);
      fragmentShader.appendHeader(bar$1.header).appendBody(bar$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    //     .-------------.------------.
    // (x-w/2, y1)    (x, y1)   (x+w/2, y1)
    //     |     \                    |
    //     |        \                 |
    //     |           \              |
    //     |              \           |
    //     |                 \        |
    //     |                    \     |
    //     |                       \  |
    //     αL            α            αR
    //     .-------------.------------.
    // (x-w/2, y0)     (x, y0)   (x+w/2, y0)
    // Drawing order
    // Triangle βL, αL, αR. (bottom)
    // β -> βL.
    // α -> αL.
    // α -> αR.
    // Triangle βL, αR, βR. (top)
    // β -> βL.
    // α -> αR.
    // β -> βR.

    var bar$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(6);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var cornerAttribute = attribute().divisor(0).size(2).type(types.BYTE).data([[-1, -1], [1, 1], [-1, 1], [1, -1]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 0, 1, 3])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = barShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        program.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'baseValueAttribute', program.buffers(), 'attribute', 'aBaseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var errorBarShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(errorBar.header).appendBody(errorBar.body);
      fragmentShader.appendHeader(errorBar$1.header).appendBody(errorBar$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var errorBar$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(18);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var lineWidth = lineWidthShader();
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -1: HIGH, 1: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       */

      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([// Main stem
      [0, 1, 1], [0, 1, -1], [0, -1, -1], [0, -1, 1], // Top cap
      [1, -1, 1], [1, -1, -1], [-1, -1, -1], [-1, -1, 1], // Bottom cap
      [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]]);
      program.buffers().elementIndices(elementIndices([// Main stem
      0, 1, 2, 0, 3, 2, // Top cap
      4, 5, 6, 4, 7, 6, // Bottom cap
      8, 9, 10, 8, 11, 10])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = errorBarShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n                gl_Position.x += xModifier / uScreen.x * 2.0;\n                gl_Position.y += yModifier / uScreen.y * 2.0;\n            ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var candlestickShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(candlestick.header).appendBody(candlestick.body);
      fragmentShader.appendHeader(candlestick$1.header).appendBody(candlestick$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var candlestick$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(12);
      var xScale = baseScale();
      var yScale = baseScale();
      var lineWidth = lineWidthShader();

      var decorate = function decorate() {};
      /*
       * x-y coordinate to locate the "corners" of the element.
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: OPEN, 1: CLOSE, 2: LOW
       * Z: -1: LEFT, 1: RIGHT (only valid for HIGH/LOW corners)
       */


      var cornerAttribute = attribute().divisor(0).size(3).type(types.BYTE).data([// Vertical line
      [0, 2, 1], [0, 2, -1], [0, -2, -1], [0, -2, 1], // Central box
      [1, -1, 0], [-1, -1, 0], [-1, 1, 0], [1, 1, 0]]);
      program.buffers().elementIndices(elementIndices([// Vertical line
      0, 1, 2, 0, 3, 2, // Central box
      4, 5, 6, 4, 7, 6])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = candlestickShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n          gl_Position.x += xModifier / uScreen.x * 2.0;\n          gl_Position.y += yModifier / uScreen.y * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'openValueAttribute', program.buffers(), 'attribute', 'aOpenValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'closeValueAttribute', program.buffers(), 'attribute', 'aCloseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var boxPlotShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(boxPlot.header).appendBody(boxPlot.body);
      fragmentShader.appendHeader(boxPlot$1.header).appendBody(boxPlot$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    //            .------.------.
    //                   |
    //                   |
    //                   |
    //    βL2            β           βR2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //     γL2            γ           γR2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //    δL2            δ           δR2
    //     .-------------.------------.
    //                   |
    //                   |
    //                   |
    //           εL1     ε     εR1
    //            .------.------.
    // Line drawing order
    // αL1 -> αR1
    // α -> β
    // βL2 -> βR2
    // γL2 -> γR2
    // δL2 -> δR2
    // βL2 -> δL2
    // βR2 -> δR2
    // δ -> ε
    // εL1 -> εR1

    var boxPlot$2 = (function () {
      var program = programBuilder().mode(drawModes.TRIANGLES).subInstanceCount(54);
      var xScale = baseScale();
      var yScale = baseScale();

      var decorate = function decorate() {};

      var lineWidth = lineWidthShader();
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: UPPER QUARTILE, 0: MEDIAN, 1: LOWER QUARTILE, 2: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       * W: Indicator to determine line orientation (needed because some corners are part of two lines). - 0: VERTICAL, 1: HORIZONTAL
       */

      var cornerAttribute = attribute().divisor(0).size(4).type(types.BYTE).data([// Top cap line
      [-1, -2, -1, 1], [1, -2, -1, 1], [1, -2, 1, 1], [-1, -2, 1, 1], // Top whisker line
      [0, -2, -1, 0], [0, -2, 1, 0], [0, -1, 1, 0], [0, -1, -1, 0], // Upper quartile line
      [-1, -1, -1, 1], [1, -1, -1, 1], [1, -1, 1, 1], [-1, -1, 1, 1], // Median line
      [-1, 0, -1, 1], [1, 0, -1, 1], [1, 0, 1, 1], [-1, 0, 1, 1], // Lower quartile line
      [-1, 1, -1, 1], [1, 1, -1, 1], [1, 1, 1, 1], [-1, 1, 1, 1], // Left box vertical line
      [-1, -1, -1, 0], [-1, -1, 1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], // Right box vertical line
      [1, -1, -1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [1, 1, -1, 0], // Bottom whisker line
      [0, 2, -1, 0], [0, 2, 1, 0], [0, 1, 1, 0], [0, 1, -1, 0], // Bottom cap line
      [-1, 2, -1, 1], [1, 2, -1, 1], [1, 2, 1, 1], [-1, 2, 1, 1]]);
      program.buffers().elementIndices(elementIndices([// Top cap line
      0, 1, 2, 0, 2, 3, // Top whisker line
      4, 5, 6, 4, 6, 7, // Upper quartile line
      8, 9, 10, 8, 10, 11, // Median line
      12, 13, 14, 12, 14, 15, // Lower quartile line
      16, 17, 18, 16, 18, 19, // Left box vertical line
      20, 21, 22, 20, 22, 23, // Right box vertical line
      24, 25, 26, 24, 26, 27, // Bottom whisker line
      28, 29, 30, 28, 30, 31, // Bottom cap line
      32, 33, 34, 32, 34, 35])).attribute('aCorner', cornerAttribute);

      var draw = function draw(numElements) {
        var shaderBuilder = boxPlotShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody("\n            gl_Position.x += xModifier / uScreen.x * 2.0;\n            gl_Position.y += yModifier / uScreen.y * 2.0;\n        ");
        decorate(program);
        program(numElements);
      };

      draw.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      draw.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return draw;
      };

      d3fcRebind.rebind(draw, program, 'context', 'pixelRatio');
      d3fcRebind.rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'upperQuartileValueAttribute', program.buffers(), 'attribute', 'aUpperQuartileValue');
      rebindCurry(draw, 'medianValueAttribute', program.buffers(), 'attribute', 'aMedianValue');
      rebindCurry(draw, 'lowerQuartileValueAttribute', program.buffers(), 'attribute', 'aLowerQuartileValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'capAttribute', program.buffers(), 'attribute', 'aCapWidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var adjacentAttribute = (function () {
      var minOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var maxOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (minOffset > 0 || maxOffset < 0) {
        throw new Error("Offset values (".concat(minOffset, " & ").concat(maxOffset, ") must straddle 0 "));
      }

      var base = baseAttributeBuilder();
      var projector = attributeProjector();

      var adjacentAttribute = function adjacentAttribute(programBuilder) {
        var elementSize = adjacentAttribute.size() * length(adjacentAttribute.type());
        var bufferOffset = Math.abs(minOffset) * elementSize;
        base.offset(bufferOffset).size(adjacentAttribute.size()).type(adjacentAttribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        var projectedData = projector();
        var bufferPadding = maxOffset * elementSize;
        var bufferLength = bufferOffset + projectedData.length * length(adjacentAttribute.type()) + bufferPadding;
        var gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, bufferLength, gl.DYNAMIC_DRAW);
        gl.bufferSubData(gl.ARRAY_BUFFER, bufferOffset, projectedData);
      };

      adjacentAttribute.offset = function (offset) {
        if (minOffset > offset || offset > maxOffset) {
          throw new Error("Requested offset ".concat(offset, " exceeds bounds (").concat(minOffset, " & ").concat(maxOffset, ") "));
        }

        var offsetAttribute = function offsetAttribute(programBuilder) {
          base.offset((offset - minOffset) * adjacentAttribute.size() * length(adjacentAttribute.type()));
          base(programBuilder);
        };

        d3fcRebind.rebind(offsetAttribute, adjacentAttribute, 'clear', 'location');
        return offsetAttribute;
      };

      adjacentAttribute.clear = function () {
        base.buffer(null);
        projector.clear();
      };

      d3fcRebind.rebind(adjacentAttribute, base, 'normalized', 'location', 'divisor');
      d3fcRebind.rebind(adjacentAttribute, projector, 'data', 'value', 'size', 'type');
      return adjacentAttribute;
    });

    var linear = (function () {
      var base = baseScale();

      var prefix = function prefix(component) {
        return "linear".concat(component);
      };

      var scale = function scale(programBuilder, identifier, component) {
        programBuilder.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Scale;")).appendBody("".concat(identifier, " = ").concat(identifier, " + ").concat(prefix(component), "Offset;")).appendBody("".concat(identifier, " = ").concat(identifier, " * ").concat(prefix(component), "Scale;"));
        var domainSize = base.domain()[1] - base.domain()[0];
        var rangeSize = base.range()[1] - base.range()[0];
        var translate = base.range()[0] * (domainSize / rangeSize) - base.domain()[0];
        var scaleFactor = rangeSize / domainSize;
        var offset = [0, 0, 0, 0];
        var scale = [1, 1, 1, 1];
        offset[component] = translate;
        scale[component] = scaleFactor;
        programBuilder.buffers().uniform("".concat(prefix(component), "Offset"), uniform(offset)).uniform("".concat(prefix(component), "Scale"), uniform(scale));
      };

      d3fcRebind.rebindAll(scale, base);
      return scale;
    });

    var log = (function () {
      var glBase = baseScale();
      var base = 10;

      function log(v, base) {
        return Math.log10(v) / Math.log10(base);
      }

      var prefix = function prefix(component) {
        return "log".concat(component);
      };

      var scale = function scale(programBuilder, identifier, component) {
        var logPart = "".concat(prefix(component), "Offset + (").concat(prefix(component), "Scale * clamp(log(").concat(identifier, ") / log(").concat(prefix(component), "Base), -inf, inf))");
        programBuilder.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Include;")).appendHeaderIfNotExists("uniform float ".concat(prefix(component), "Base;")).appendBody("".concat(identifier, " = (").concat(prefix(component), "Include * (").concat(logPart, ")) + ((1.0 - ").concat(prefix(component), "Include) * ").concat(identifier, ");"));
        var domainSize = log(glBase.domain()[1], base) - log(glBase.domain()[0], base);
        var rangeSize = glBase.range()[1] - glBase.range()[0];
        var scaleFactor = rangeSize / domainSize;
        var translate = glBase.range()[0] - scaleFactor * log(glBase.domain()[0], base);
        var offset = [0, 0, 0, 0];
        var scale = [0, 0, 0, 0];
        var include = [0, 0, 0, 0];
        offset[component] = translate;
        scale[component] = scaleFactor;
        include[component] = 1;
        programBuilder.buffers().uniform("".concat(prefix(component), "Offset"), uniform(offset)).uniform("".concat(prefix(component), "Scale"), uniform(scale)).uniform("".concat(prefix(component), "Include"), uniform(include)).uniform("".concat(prefix(component), "Base"), uniform(base));
      };

      scale.base = function () {
        if (!arguments.length) {
          return base;
        }

        base = arguments.length <= 0 ? undefined : arguments[0];
        return scale;
      };

      d3fcRebind.rebindAll(scale, glBase);
      return scale;
    });

    var pow = (function () {
      var base = baseScale();
      var exponent = 1;

      function pow(b, e) {
        return Math.sign(b) * Math.pow(Math.abs(b), e);
      }

      var prefix = function prefix(component) {
        return "pow".concat(component);
      };

      var scale = function scale(programBuilder, identifier, component) {
        var powPart = "".concat(prefix(component), "Offset + (").concat(prefix(component), "Scale * sign(").concat(identifier, ") * pow(abs(").concat(identifier, "), vec4(").concat(prefix(component), "Exp)))");
        programBuilder.vertexShader().appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Offset;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Scale;")).appendHeaderIfNotExists("uniform vec4 ".concat(prefix(component), "Include;")).appendHeaderIfNotExists("uniform float ".concat(prefix(component), "Exp;")).appendBody("".concat(identifier, " = (").concat(prefix(component), "Include * (").concat(powPart, ")) + ((1.0 - ").concat(prefix(component), "Include) * ").concat(identifier, ");"));
        var domainSize = pow(base.domain()[1], exponent) - pow(base.domain()[0], exponent);
        var rangeSize = base.range()[1] - base.range()[0];
        var scaleFactor = rangeSize / domainSize;
        var translate = base.range()[0] - scaleFactor * pow(base.domain()[0], exponent);
        var offset = [0, 0, 0, 0];
        var scale = [0, 0, 0, 0];
        var include = [0, 0, 0, 0];
        offset[component] = translate;
        scale[component] = scaleFactor;
        include[component] = 1;
        programBuilder.buffers().uniform("".concat(prefix(component), "Offset"), uniform(offset)).uniform("".concat(prefix(component), "Scale"), uniform(scale)).uniform("".concat(prefix(component), "Include"), uniform(include)).uniform("".concat(prefix(component), "Exp"), uniform(exponent));
      };

      scale.exponent = function () {
        if (!arguments.length) {
          return exponent;
        }

        exponent = arguments.length <= 0 ? undefined : arguments[0];
        return scale;
      };

      d3fcRebind.rebindAll(scale, base);
      return scale;
    });

    // determine the scale type.

    var scaleLinearCopy = d3Scale.scaleLinear().copy.toString();
    var scaleLogCopy = d3Scale.scaleLog().copy.toString();
    var scalePowCopy = d3Scale.scalePow().copy.toString();
    var scaleTimeCopy = d3Scale.scaleTime().copy.toString(); // always return the same reference to hint to consumers that
    // it is a pure function

    var identity = d3Scale.scaleIdentity(); // offset date values to make the most of the float32 precision

    var epoch = Date.now();

    var reepoch = function reepoch(d) {
      return d - epoch;
    };

    var scaleMapper = (function (scale) {
      switch (scale.copy.toString()) {
        case scaleLinearCopy:
          {
            return {
              scale: identity,
              webglScale: linear().domain(scale.domain())
            };
          }

        case scaleTimeCopy:
          {
            return {
              scale: reepoch,
              webglScale: linear().domain(scale.domain().map(reepoch))
            };
          }

        case scaleLogCopy:
          {
            return {
              scale: identity,
              webglScale: log().domain(scale.domain()).base(scale.base())
            };
          }

        case scalePowCopy:
          {
            return {
              scale: identity,
              webglScale: pow().domain(scale.domain()).exponent(scale.exponent())
            };
          }

        default:
          {
            // always return a copy of the scale to hint to consumers
            // that it may be an impure function
            return {
              scale: scale.copy(),
              webglScale: linear().domain(scale.range())
            };
          }
      }
    });

    var squarePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(square.header).appendBody(square.body);
      fragmentShader.appendHeader(square$1.header).appendBody(square$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var trianglePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(triangle.header).appendBody(triangle.body);
      fragmentShader.appendHeader(triangle$1.header).appendBody(triangle$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var crossPointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(cross.header).appendBody(cross.body);
      fragmentShader.appendHeader(cross$1.header).appendBody(cross$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var diamondPointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(diamond.header).appendBody(diamond.body);
      fragmentShader.appendHeader(diamond$1.header).appendBody(diamond$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var starPointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(star.header).appendBody(star.body);
      fragmentShader.appendHeader(star$1.header).appendBody(star$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var wyePointShader = (function () {
      var vertexShader = shaderBuilder(vertexShaderBase);
      var fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(wye.header).appendBody(wye.body);
      fragmentShader.appendHeader(wye$1.header).appendBody(wye$1.body);
      return {
        vertex: function vertex() {
          return vertexShader;
        },
        fragment: function fragment() {
          return fragmentShader;
        }
      };
    });

    var symbolMapper = (function (symbol) {
      switch (symbol) {
        case d3Shape.symbolCircle:
          return circlePointShader();

        case d3Shape.symbolSquare:
          return squarePointShader();

        case d3Shape.symbolTriangle:
          return trianglePointShader();

        case d3Shape.symbolCross:
          return crossPointShader();

        case d3Shape.symbolDiamond:
          return diamondPointShader();

        case d3Shape.symbolStar:
          return starPointShader();

        case d3Shape.symbolWye:
          return wyePointShader();

        default:
          throw new Error("Unrecognised symbol: ".concat(symbol));
      }
    });

    var constantAttribute = (function (initialValue) {
      var base = baseAttributeBuilder().divisor(1);
      var value = initialValue;
      var dirty = true;

      var constantAttribute = function constantAttribute(programBuilder) {
        base(programBuilder);

        if (!dirty) {
          return;
        }

        if (!Array.isArray(value)) {
          throw new Error("Expected an array, received: ".concat(value));
        }

        if (value.length !== base.size()) {
          throw new Error("Expected array of length: ".concat(base.size(), ", recieved array of length: ").concat(value.length));
        }

        var gl = programBuilder.context();
        gl["vertexAttrib".concat(value.length, "fv")](base.location(), value);
        gl.disableVertexAttribArray(base.location());
        dirty = false;
      };

      constantAttribute.clear = function () {
        dirty = true;
      };

      constantAttribute.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = arguments.length <= 0 ? undefined : arguments[0];
        dirty = true;
        return constantAttribute;
      };

      d3fcRebind.rebind(constantAttribute, base, 'normalized', 'size', 'location');
      return constantAttribute;
    });

    var fillColor$2 = (function () {
      var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var projectedAttribute = attribute().size(4);
      var value = initialValue;
      var dirty = true;

      var fillColor$2 = function fillColor$2(programBuilder) {
        programBuilder.vertexShader().appendHeaderIfNotExists(fillColor.header).appendBodyIfNotExists(fillColor.body);
        programBuilder.fragmentShader().appendHeaderIfNotExists(fillColor$1.header).appendBodyIfNotExists(fillColor$1.body);

        if (Array.isArray(value)) {
          programBuilder.buffers().attribute('aFillColor', constantAttribute(value).size(4));
        } else if (typeof value === 'function') {
          if (!dirty) {
            return;
          } // The following line is expensive and is the one we want to skip,
          // the rest aren't.


          projectedAttribute.value(value);
          programBuilder.buffers().attribute('aFillColor', projectedAttribute);
        } else {
          throw new Error("Expected value to be an array or function, received ".concat(value));
        }

        dirty = false;
      };

      fillColor$2.value = function () {
        if (!arguments.length) {
          return value;
        }

        if (value !== (arguments.length <= 0 ? undefined : arguments[0])) {
          value = arguments.length <= 0 ? undefined : arguments[0];
          dirty = true;
        }

        return fillColor$2;
      };

      d3fcRebind.rebind(fillColor$2, projectedAttribute, 'data');
      return fillColor$2;
    });

    var strokeColor$2 = (function () {
      var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var projectedAttribute = attribute().size(4);
      var value = initialValue;
      var dirty = true;

      var strokeColor$2 = function strokeColor$2(programBuilder) {
        programBuilder.vertexShader().appendHeaderIfNotExists(strokeColor.header).appendBodyIfNotExists(strokeColor.body);
        programBuilder.fragmentShader().appendHeaderIfNotExists(strokeColor$1.header).appendBodyIfNotExists(strokeColor$1.body);

        if (Array.isArray(value)) {
          programBuilder.buffers().attribute('aStrokeColor', constantAttribute(value).size(4));
        } else if (typeof value === 'function') {
          if (!dirty) {
            return;
          } // The following line is expensive and is the one we want to skip,
          // the rest aren't.


          projectedAttribute.value(value);
          programBuilder.buffers().attribute('aStrokeColor', projectedAttribute);
        } else {
          throw new Error("Expected value to be an array or function, received ".concat(value));
        }

        dirty = false;
      };

      strokeColor$2.value = function () {
        if (!arguments.length) {
          return value;
        }

        if (value !== (arguments.length <= 0 ? undefined : arguments[0])) {
          value = arguments.length <= 0 ? undefined : arguments[0];
          dirty = true;
        }

        return strokeColor$2;
      };

      d3fcRebind.rebind(strokeColor$2, projectedAttribute, 'data');
      return strokeColor$2;
    });

    exports.webglAdjacentAttribute = adjacentAttribute;
    exports.webglAttribute = attribute;
    exports.webglBaseAttribute = baseAttributeBuilder;
    exports.webglBufferBuilder = bufferBuilder;
    exports.webglElementIndices = elementIndices;
    exports.webglFillColor = fillColor$2;
    exports.webglProgramBuilder = programBuilder;
    exports.webglScaleLinear = linear;
    exports.webglScaleLog = log;
    exports.webglScaleMapper = scaleMapper;
    exports.webglScalePow = pow;
    exports.webglSeriesArea = area$2;
    exports.webglSeriesBar = bar$2;
    exports.webglSeriesBoxPlot = boxPlot$2;
    exports.webglSeriesCandlestick = candlestick$2;
    exports.webglSeriesErrorBar = errorBar$2;
    exports.webglSeriesLine = line;
    exports.webglSeriesOhlc = ohlc$2;
    exports.webglSeriesPoint = point;
    exports.webglShaderBuilder = shaderBuilder;
    exports.webglStrokeColor = strokeColor$2;
    exports.webglSymbolMapper = symbolMapper;
    exports.webglTypes = types;
    exports.webglUniform = uniform;

    Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLW5vZGVfbW9kdWxlc19kM2ZjX2QzZmMtd2ViZ2xfYnVpbGRfZDNmYy13ZWJnbF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsSUFBSSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBbUIsR0FBRyxtQkFBTyxDQUFDLHNEQUFVLEdBQUcsbUJBQU8sQ0FBQyxzREFBVTtBQUN6SixJQUFJLENBQ2lKO0FBQ3JKLENBQUMsMkRBQTJEOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBLHdDQUF3Qyx3QkFBd0IsbUNBQW1DLDBCQUEwQjtBQUM3SDtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQyw4Q0FBOEMsMEJBQTBCO0FBQ25KOztBQUVBO0FBQ0EseUNBQXlDLHVDQUF1QztBQUNoRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyx5Q0FBeUM7QUFDcEYseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhDQUE4QyxvREFBb0QsNERBQTREO0FBQ3pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhDQUE4QyxvREFBb0QsNERBQTREO0FBQ3pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhDQUE4QyxvREFBb0QsNERBQTREO0FBQ3pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhCQUE4QixvREFBb0QsNERBQTREO0FBQ3pMO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDhCQUE4Qiw0REFBNEQsNERBQTREO0FBQ2pNO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQyxpQ0FBaUM7QUFDclEsMkNBQTJDLDJEQUEyRCxvREFBb0QsNERBQTREO0FBQ3ROO0FBQ0E7QUFDQSxxREFBcUQscUNBQXFDLGdDQUFnQyxtQ0FBbUMsdUNBQXVDLGdDQUFnQywwQ0FBMEMsaUNBQWlDO0FBQy9TLDJDQUEyQywwQ0FBMEMsMEVBQTBFLG9EQUFvRCw0REFBNEQ7QUFDL1E7QUFDQTtBQUNBLHFEQUFxRCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxzQ0FBc0Msb0NBQW9DLGlDQUFpQyxtQ0FBbUMsaUNBQWlDLHFDQUFxQywwQ0FBMEMsaUNBQWlDO0FBQ25jLDJDQUEyQywyREFBMkQsOERBQThELG1EQUFtRCxrREFBa0QsaURBQWlELG1QQUFtUCwrRkFBK0YsaUdBQWlHLG1FQUFtRSw2RkFBNkYscUVBQXFFLDBEQUEwRDtBQUM1Z0M7QUFDQTtBQUNBLHFEQUFxRCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxzQ0FBc0Msb0NBQW9DLGlDQUFpQyxtQ0FBbUMsaUNBQWlDLHFDQUFxQywwQ0FBMEMsaUNBQWlDO0FBQ25jLDJDQUEyQywyREFBMkQsOERBQThELG1EQUFtRCxrREFBa0QsaURBQWlELCtQQUErUCwrREFBK0QsZ0VBQWdFLG1GQUFtRiw2RkFBNkYscUVBQXFFLDBEQUEwRDtBQUN2K0I7QUFDQTtBQUNBLHFEQUFxRCxxQ0FBcUMscUNBQXFDLHFDQUFxQyxpQ0FBaUMsbUNBQW1DLGlDQUFpQyxxQ0FBcUMsbUNBQW1DO0FBQ2pWLDJDQUEyQyxxREFBcUQsdUZBQXVGLDZEQUE2RCwwREFBMEQ7QUFDOVM7QUFDQTtBQUNBLGdEQUFnRCxzQ0FBc0MscUNBQXFDLHFDQUFxQyxvQ0FBb0MsbUNBQW1DLGlDQUFpQyxxQ0FBcUMsbUNBQW1DO0FBQ2hWLDJDQUEyQyxnREFBZ0Qsd0VBQXdFLGdEQUFnRCx1RUFBdUUsK0RBQStELDBEQUEwRCxvR0FBb0csaUVBQWlFO0FBQ3hqQjtBQUNBO0FBQ0EsZ0RBQWdELHNDQUFzQyxxQ0FBcUMsMENBQTBDLHlDQUF5QyxxQ0FBcUMseUNBQXlDLG1DQUFtQyx1Q0FBdUMsbUNBQW1DLDZDQUE2QywyQ0FBMkMsV0FBVyx5Q0FBeUMsMkJBQTJCLFdBQVc7QUFDM2pCLDBEQUEwRCx5Q0FBeUMsK0dBQStHLDhEQUE4RCw4RkFBOEYsMkVBQTJFLCtGQUErRiw2RUFBNkUsa0dBQWtHLHlFQUF5RSw0RUFBNEUscUdBQXFHLHdIQUF3SCx3SUFBd0ksZ0lBQWdJO0FBQ2owQztBQUNBO0FBQ0EsZ0RBQWdELHNDQUFzQyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyw4Q0FBOEMsdUNBQXVDLDhDQUE4QyxvQ0FBb0MsbUNBQW1DLGlDQUFpQyxxQ0FBcUMsbUNBQW1DO0FBQ3ZmLDJDQUEyQyw4REFBOEQsaURBQWlELG9EQUFvRCwyQ0FBMkMsMkRBQTJELG9FQUFvRSxnREFBZ0Qsb1NBQW9TLDBEQUEwRCwyQ0FBMkMsZ0RBQWdELDBHQUEwRyw0RkFBNEYsMEVBQTBFO0FBQ2puQzs7QUFFQTtBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUUsMkNBQTJDLDZEQUE2RCw2RUFBNkUsaURBQWlELHNCQUFzQixxQkFBcUIsV0FBVztBQUM1UixPQUFPOztBQUVQO0FBQ0EsNkNBQTZDLGlDQUFpQyxzRUFBc0UsK0NBQStDLDJDQUEyQyw4Q0FBOEM7QUFDNVIsMkNBQTJDLCtDQUErQyxzQkFBc0IsNkVBQTZFLHNEQUFzRCxxQkFBcUIsNkRBQTZELDBDQUEwQyxxQ0FBcUMsNkVBQTZFLGlEQUFpRCxzQkFBc0IscUJBQXFCLFdBQVc7QUFDeGtCO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQWlDO0FBQzlFLDJDQUEyQywrQ0FBK0Msc0JBQXNCLHlEQUF5RCx3REFBd0Qsc0RBQXNELDhEQUE4RCxvRUFBb0UsdUNBQXVDLDZFQUE2RSxpREFBaUQsc0JBQXNCLHFCQUFxQixXQUFXO0FBQ3BuQjtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFpQztBQUM5RSwyQ0FBMkMsK0JBQStCLHNCQUFzQixXQUFXLCtEQUErRCx1RkFBdUYsNkVBQTZFO0FBQzlVLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLGlDQUFpQyx3QkFBd0Isd0JBQXdCO0FBQzlILDRDQUE0QyxzQkFBc0IsV0FBVyxpRUFBaUUsaURBQWlELCtDQUErQyxvREFBb0Qsa0RBQWtELHFFQUFxRSxpQ0FBaUMsc0JBQXNCLFdBQVc7QUFDM2Q7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUUsMkNBQTJDLCtEQUErRCw0R0FBNEcsaUVBQWlFLHFFQUFxRSw2RUFBNkUsaURBQWlELHNCQUFzQixXQUFXO0FBQzNmO0FBQ0E7QUFDQSw2Q0FBNkMsMENBQTBDLGlDQUFpQztBQUN4SCwyQ0FBMkMsK0RBQStELDZIQUE2SCxnR0FBZ0csdUVBQXVFLDZFQUE2RSxpREFBaUQsc0JBQXNCLFdBQVc7QUFDN2lCO0FBQ0E7QUFDQSx1REFBdUQsaUNBQWlDO0FBQ3hGLDJDQUEyQyxnQ0FBZ0MsK0JBQStCLHNCQUFzQixXQUFXLDhDQUE4QyxzQ0FBc0Msa0RBQWtELFdBQVc7QUFDNVI7QUFDQTtBQUNBLHVEQUF1RCxpQ0FBaUM7QUFDeEYsMkNBQTJDLGdDQUFnQywrQkFBK0Isc0JBQXNCLFdBQVcsOENBQThDLHNDQUFzQyxrREFBa0QsV0FBVztBQUM1UjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDJDQUEyQyxnQ0FBZ0MsK0JBQStCLHNCQUFzQixXQUFXLG1EQUFtRDtBQUM5TDtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDJDQUEyQyxnQ0FBZ0MsaUNBQWlDLHNCQUFzQixXQUFXO0FBQzdJO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDLGdDQUFnQywrQkFBK0Isc0JBQXNCLFdBQVc7QUFDM0k7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywyQ0FBMkMsZ0NBQWdDLHVEQUF1RCxpQ0FBaUMsc0JBQXNCLFdBQVc7QUFDcE07QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0RkFBNEY7QUFDNUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQixhQUFhO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG9HQUFvRyxhQUFhO0FBQ2pIO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsMENBQTBDLDhDQUE4Qyx5Q0FBeUMsNkNBQTZDLHVDQUF1QywyQ0FBMkMsMkNBQTJDLG1DQUFtQyxzQ0FBc0MscUNBQXFDO0FBQ2plLG9HQUFvRywrRUFBK0U7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsZ0ZBQWdGLDREQUE0RCxzRUFBc0UsK0RBQStELG1GQUFtRixxRUFBcUUsOEVBQThFLDREQUE0RCxrREFBa0QsY0FBYzs7QUFFcHVCLDhFQUE4RSxvQ0FBb0MscUNBQXFDLG9DQUFvQyxvQ0FBb0M7QUFDL04sMkVBQTJFLDREQUE0RCxnRUFBZ0UsOEJBQThCLDBCQUEwQixlQUFlO0FBQzlRO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0cseURBQXlEO0FBQzdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLCtEQUErRDtBQUN6SztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyx5REFBeUQ7QUFDN0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLDJEQUEyRDtBQUNqSztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdIQUFnSCw2RUFBNkUsd0dBQXdHLHVHQUF1RztBQUM1WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0hBQWdILDZFQUE2RSwrRUFBK0UsNkVBQTZFLHNMQUFzTDtBQUMvZ0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0hBQWdILDZFQUE2RSwrRUFBK0UsNEVBQTRFLHNMQUFzTDtBQUM5Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUEsNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELGFBQWE7O0FBRWhFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYWluYXBwLy4vbm9kZV9tb2R1bGVzL0BkM2ZjL2QzZmMtd2ViZ2wvYnVpbGQvZDNmYy13ZWJnbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGQzZmMvZDNmYy1yZWJpbmQnKSwgcmVxdWlyZSgnZDMtc2NhbGUnKSwgcmVxdWlyZSgnZDMtc2hhcGUnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGQzZmMvZDNmYy1yZWJpbmQnLCAnZDMtc2NhbGUnLCAnZDMtc2hhcGUnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmZjID0gZ2xvYmFsLmZjIHx8IHt9LCBnbG9iYWwuZmMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgZDNmY1JlYmluZCwgZDNTY2FsZSwgZDNTaGFwZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgYmFzZVNjYWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkb21haW4gPSBbMCwgMV07XG4gICAgICB2YXIgcmFuZ2UgPSBbLTEsIDFdO1xuXG4gICAgICB2YXIgYmFzZSA9IGZ1bmN0aW9uIGJhc2UoKSB7fTtcblxuICAgICAgYmFzZS5kb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkb21haW47XG4gICAgICAgIH1cblxuICAgICAgICBkb21haW4gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfTtcblxuICAgICAgYmFzZS5yYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSk7XG5cbiAgICB2YXIgYnVmZmVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgICB2YXIgZWxlbWVudEluZGljZXMgPSBudWxsO1xuXG4gICAgICB2YXIgYnVmZmVyQnVpbGRlciA9IGZ1bmN0aW9uIGJ1ZmZlckJ1aWxkZXIocHJvZ3JhbUJ1aWxkZXIsIHByb2dyYW0pIHtcbiAgICAgICAgdmFyIGdsID0gcHJvZ3JhbUJ1aWxkZXIuY29udGV4dCgpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYW4gYXR0cmlidXRlIGZvciBcIi5jb25jYXQobmFtZSwgXCIsIGZvdW5kIFwiKS5jb25jYXQoYXR0cmlidXRlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgYXR0cmlidXRlLmxvY2F0aW9uKGxvY2F0aW9uKShwcm9ncmFtQnVpbGRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgdW5pZm9ybSBmb3IgXCIuY29uY2F0KG5hbWUsIFwiLCBmb3VuZCBcIikuY29uY2F0KHVuaWZvcm0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgdW5pZm9ybS5sb2NhdGlvbihsb2NhdGlvbikocHJvZ3JhbUJ1aWxkZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudEluZGljZXMgIT09IG51bGwpIHtcbiAgICAgICAgICBlbGVtZW50SW5kaWNlcyhwcm9ncmFtQnVpbGRlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJ1ZmZlckJ1aWxkZXIuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5jbGVhcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh1bmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybSkge1xuICAgICAgICAgIHJldHVybiB1bmlmb3JtLmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxlbWVudEluZGljZXMgIT09IG51bGwpIGVsZW1lbnRJbmRpY2VzLmNsZWFyKCk7XG4gICAgICB9O1xuXG4gICAgICBidWZmZXJCdWlsZGVyLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2FyZ3NbMF1dO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlc1thcmdzWzBdXSA9IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBidWZmZXJCdWlsZGVyO1xuICAgICAgfTtcblxuICAgICAgYnVmZmVyQnVpbGRlci51bmlmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdW5pZm9ybXNbYXJnc1swXV07XG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtc1thcmdzWzBdXSA9IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBidWZmZXJCdWlsZGVyO1xuICAgICAgfTtcblxuICAgICAgYnVmZmVyQnVpbGRlci5lbGVtZW50SW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRJbmRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudEluZGljZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBidWZmZXJCdWlsZGVyO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1ZmZlckJ1aWxkZXI7XG4gICAgfSk7XG5cbiAgICB2YXIgdW5pZm9ybSA9IChmdW5jdGlvbiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IC0xO1xuICAgICAgdmFyIGRhdGEgPSBpbml0aWFsRGF0YTtcbiAgICAgIHZhciBkaXJ0eSA9IHRydWU7XG5cbiAgICAgIHZhciBidWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIGlmICghZGlydHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtQnVpbGRlci5jb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIGRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIGRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pZm9ybSBzdXBwb3J0cyB1cCB0byA0IGVsZW1lbnRzLiBcIi5jb25jYXQoZGF0YS5sZW5ndGgsIFwiIHByb3ZpZGVkLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLmxvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYXRpb24gIT09IChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBidWlsZDtcbiAgICB9KTtcblxuICAgIHZhciBkcmF3TW9kZXMgPSB7XG4gICAgICBQT0lOVFM6IDAsXG4gICAgICBMSU5FUzogMSxcbiAgICAgIExJTkVfTE9PUDogMixcbiAgICAgIExJTkVfU1RSSVA6IDMsXG4gICAgICBUUklBTkdMRVM6IDQsXG4gICAgICBUUklBTkdMRV9TVFJJUDogNSxcbiAgICAgIFRSSUFOR0xFX0ZBTjogNlxuICAgIH07XG5cbiAgICB2YXIgcHJvZ3JhbUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBudWxsO1xuICAgICAgdmFyIHByb2dyYW0gPSBudWxsO1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xuICAgICAgdmFyIHByb2dyYW1WZXJ0ZXhTaGFkZXIgPSBudWxsO1xuICAgICAgdmFyIHByb2dyYW1GcmFnbWVudFNoYWRlciA9IG51bGw7XG4gICAgICB2YXIgbW9kZSA9IGRyYXdNb2Rlcy5UUklBTkdMRVM7XG4gICAgICB2YXIgc3ViSW5zdGFuY2VDb3VudCA9IDA7XG4gICAgICB2YXIgYnVmZmVycyA9IGJ1ZmZlckJ1aWxkZXIoKTtcbiAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgdmFyIGV4dEluc3RhbmNlZEFycmF5cyA9IG51bGw7XG4gICAgICB2YXIgZGlydHkgPSB0cnVlO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuXG4gICAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiBidWlsZChjb3VudCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRleFNoYWRlclNvdXJjZSA9IHZlcnRleFNoYWRlcigpO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlcigpO1xuXG4gICAgICAgIGlmIChuZXdQcm9ncmFtKHByb2dyYW0sIHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpKSB7XG4gICAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgICAgcHJvZ3JhbVZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlclNvdXJjZTtcbiAgICAgICAgICBwcm9ncmFtRnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlclNvdXJjZTtcbiAgICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBidWZmZXJzLnVuaWZvcm0oJ3VTY3JlZW4nLCB1bmlmb3JtKFtjb250ZXh0LmNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8sIGNvbnRleHQuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW9dKSk7XG4gICAgICAgIGJ1ZmZlcnMoYnVpbGQsIHByb2dyYW0pO1xuXG4gICAgICAgIGlmIChzdWJJbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlcnMuZWxlbWVudEluZGljZXMoKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdBcnJheXMobW9kZSwgMCwgY291bnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgY29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChidWZmZXJzLmVsZW1lbnRJbmRpY2VzKCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0SW5zdGFuY2VkQXJyYXlzLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShtb2RlLCAwLCBzdWJJbnN0YW5jZUNvdW50LCBjb3VudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5kaWNlc0xlbmd0aCA9IGJ1ZmZlcnMuZWxlbWVudEluZGljZXMoKS5kYXRhKCkubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoc3ViSW5zdGFuY2VDb3VudCAhPT0gZWxlbWVudEluZGljZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudEluZGljZXMgbGVuZ3RoIFwiLmNvbmNhdChlbGVtZW50SW5kaWNlc0xlbmd0aCkgKyBcIiB0byBtYXRjaCBzdWJJbnN0YW5jZUNvdW50IFwiLmNvbmNhdChzdWJJbnN0YW5jZUNvdW50LCBcIi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRJbnN0YW5jZWRBcnJheXMuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUobW9kZSwgc3ViSW5zdGFuY2VDb3VudCwgY29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCwgY291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYnVpbGQuZXh0SW5zdGFuY2VkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXh0SW5zdGFuY2VkQXJyYXlzO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuY29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzWzBdID09IG51bGwgfHwgYXJnc1swXSAhPT0gY29udGV4dCkge1xuICAgICAgICAgIGJ1ZmZlcnMuZmx1c2goKTtcbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJnc1swXSAhPSBudWxsICYmIGFyZ3NbMF0gIT09IGNvbnRleHQpIHtcbiAgICAgICAgICBleHRJbnN0YW5jZWRBcnJheXMgPSBhcmdzWzBdLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dCA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLmJ1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBidWZmZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVycyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQudmVydGV4U2hhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVydGV4U2hhZGVyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYnVpbGQ7XG4gICAgICB9O1xuXG4gICAgICBidWlsZC5mcmFnbWVudFNoYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLm1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuc3ViSW5zdGFuY2VDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHN1Ykluc3RhbmNlQ291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJJbnN0YW5jZUNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYnVpbGQ7XG4gICAgICB9O1xuXG4gICAgICBidWlsZC5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLnBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1aWxkO1xuXG4gICAgICBmdW5jdGlvbiBuZXdQcm9ncmFtKHByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgaWYgKCFwcm9ncmFtIHx8IGRpcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyICE9PSBwcm9ncmFtVmVydGV4U2hhZGVyIHx8IGZyYWdtZW50U2hhZGVyICE9PSBwcm9ncmFtRnJhZ21lbnRTaGFkZXI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gbG9hZFNoYWRlcih2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGNvbnRleHQuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGxvYWRTaGFkZXIoZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGNvbnRleHQuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgY29udGV4dC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgY29udGV4dC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICBjb250ZXh0LmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAgIGlmIChkZWJ1ZyAmJiAhY29udGV4dC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGNvbnRleHQuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb250ZXh0LmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgICAgIGNvbnRleHQuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGluayBwcm9ncmFtIDogXCIuY29uY2F0KG1lc3NhZ2UsIFwiXFxuICAgICAgICAgICAgVmVydGV4IFNoYWRlciA6IFwiKS5jb25jYXQodmVydGV4U2hhZGVyU291cmNlLCBcIlxcbiAgICAgICAgICAgIEZyYWdtZW50IFNoYWRlciA6IFwiKS5jb25jYXQoZnJhZ21lbnRTaGFkZXJTb3VyY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb2FkU2hhZGVyKHNvdXJjZSwgdHlwZSkge1xuICAgICAgICB2YXIgc2hhZGVyID0gY29udGV4dC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGNvbnRleHQuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICAgICAgY29udGV4dC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgaWYgKGRlYnVnICYmICFjb250ZXh0LmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGNvbnRleHQuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb250ZXh0LmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgICBjb250ZXh0LmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHNoYWRlciA6IFwiLmNvbmNhdChtZXNzYWdlLCBcIlxcbiAgICAgICAgICAgIFNoYWRlciA6IFwiKS5jb25jYXQoc291cmNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHNoYWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgIHZhciBzaGFkZXJIZWFkZXJzID0gW107XG4gICAgICB2YXIgc2hhZGVyQm9kaWVzID0gW107XG5cbiAgICAgIHZhciBidWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4gYmFzZShzaGFkZXJIZWFkZXJzLmpvaW4oJ1xcbicpLCBzaGFkZXJCb2RpZXMuam9pbignXFxuJykpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYXBwZW5kKGFycmF5LCBlbGVtZW50KSB7XG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluc2VydChhcnJheSwgZWxlbWVudCwgYmVmb3JlKSB7XG4gICAgICAgIHZhciBiZWZvcmVJbmRleCA9IGFycmF5LmluZGV4T2YoYmVmb3JlKTtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGJlZm9yZUluZGV4ID49IDAgPyBiZWZvcmVJbmRleCA6IGFycmF5Lmxlbmd0aCwgMCwgZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGVuZElmTm90RXhpc3RzKGFycmF5LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBlbGVtZW50SW5kZXggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChlbGVtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWlsZC5hcHBlbmRIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIGFwcGVuZChzaGFkZXJIZWFkZXJzLCBoZWFkZXIpO1xuICAgICAgICByZXR1cm4gYnVpbGQ7XG4gICAgICB9O1xuXG4gICAgICBidWlsZC5pbnNlcnRIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyLCBiZWZvcmUpIHtcbiAgICAgICAgaW5zZXJ0KHNoYWRlckhlYWRlcnMsIGhlYWRlciwgYmVmb3JlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIGFwcGVuZElmTm90RXhpc3RzKHNoYWRlckhlYWRlcnMsIGhlYWRlcik7XG4gICAgICAgIHJldHVybiBidWlsZDtcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkLmFwcGVuZEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBhcHBlbmQoc2hhZGVyQm9kaWVzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuaW5zZXJ0Qm9keSA9IGZ1bmN0aW9uIChib2R5LCBiZWZvcmUpIHtcbiAgICAgICAgaW5zZXJ0KHNoYWRlckJvZGllcywgYm9keSwgYmVmb3JlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgYnVpbGQuYXBwZW5kQm9keUlmTm90RXhpc3RzID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgYXBwZW5kSWZOb3RFeGlzdHMoc2hhZGVyQm9kaWVzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1aWxkO1xuICAgIH0pOyAvLyBpbmYgaXMgcHJlY2FsY3VsYXRlZCBoZXJlIGZvciB1c2UgaW4gc29tZSBmdW5jdGlvbnMgKGUuZy4gbG9nIHNjYWxlIGNhbGN1bGF0aW9ucylcblxuICAgIHZhciB2ZXJ0ZXhTaGFkZXJCYXNlID0gZnVuY3Rpb24gdmVydGV4U2hhZGVyQmFzZShoZWFkZXIsIGJvZHkpIHtcbiAgICAgIHJldHVybiBcIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmZsb2F0IGluZiA9IDEuMCAvIDAuMDtcXG5cIi5jb25jYXQoaGVhZGVyLCBcIlxcbnZvaWQgbWFpbigpIHtcXG4gICAgXCIpLmNvbmNhdChib2R5LCBcIlxcbn1cIik7XG4gICAgfTtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXJCYXNlID0gZnVuY3Rpb24gZnJhZ21lbnRTaGFkZXJCYXNlKGhlYWRlciwgYm9keSkge1xuICAgICAgcmV0dXJuIFwiXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXCIuY29uY2F0KGhlYWRlciwgXCJcXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG4gICAgXCIpLmNvbmNhdChib2R5LCBcIlxcbn1cIik7XG4gICAgfTtcblxuICAgIHZhciBmaWxsQ29sb3IgPSB7XG4gICAgICBoZWFkZXI6IFwiYXR0cmlidXRlIHZlYzQgYUZpbGxDb2xvcjtcXG4gICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZGaWxsQ29sb3I7XCIsXG4gICAgICBib2R5OiBcInZGaWxsQ29sb3IgPSBhRmlsbENvbG9yO1wiXG4gICAgfTtcbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSB7XG4gICAgICBoZWFkZXI6IFwiYXR0cmlidXRlIHZlYzQgYVN0cm9rZUNvbG9yO1xcbiAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdlN0cm9rZUNvbG9yO1wiLFxuICAgICAgYm9keTogXCJ2U3Ryb2tlQ29sb3IgPSBhU3Ryb2tlQ29sb3I7XCJcbiAgICB9O1xuICAgIHZhciBjaXJjbGUgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhU2l6ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIHZTaXplID0gMi4wICogc3FydChhU2l6ZSAvIDMuMTQxNTkpO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gdlNpemUgKyB1U3Ryb2tlV2lkdGggKyAxLjA7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgc3RhciA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFTaXplO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcblxcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1U3Ryb2tlV2lkdGg7XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgdlNpemUgPSA0LjAgKiBzcXJ0KGFTaXplIC8gMy4xNDE1OSk7XFxuICAgICAgICBnbF9Qb2ludFNpemUgPSB2U2l6ZSArIHVTdHJva2VXaWR0aCArIDEuMDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgYU1haW5WYWx1ZSwgMCwgMSk7XCJcbiAgICB9O1xuICAgIHZhciB3eWUgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhU2l6ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIHZTaXplID0gMy4wICogc3FydChhU2l6ZSAvIDMuMTQxNTkpO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gdlNpemUgKyB1U3Ryb2tlV2lkdGggKyAxLjA7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgc3F1YXJlID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYVNpemU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVTdHJva2VXaWR0aDtcXG5cXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQ7XFxuICAgICAgICB2U2l6ZSA9IHNxcnQoYVNpemUpO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gdlNpemUgKyB1U3Ryb2tlV2lkdGggKyAxLjA7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgZGlhbW9uZCA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWFpblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFTaXplO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcblxcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1U3Ryb2tlV2lkdGg7XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgdlNpemUgPSBzcXJ0KGFTaXplKTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IDIuMCAqICh2U2l6ZSArIHVTdHJva2VXaWR0aCArIDEuMCk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAsIDEpO1wiXG4gICAgfTtcbiAgICB2YXIgdHJpYW5nbGUgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhU2l6ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG5cXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U2l6ZTtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIHZTaXplID0gc3FydCgoMTYuMCAqIGFTaXplKSAvICgzLjAgKiBzcXJ0KDMuMCkpKTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IHZTaXplICsgdVN0cm9rZVdpZHRoICsgMS4wO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDcm9zc1ZhbHVlLCBhTWFpblZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGNyb3NzID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYVNpemU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVTdHJva2VXaWR0aDtcXG5cXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTdHJva2VXaWR0aFJhdGlvO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgdlNpemUgPSAzLjAgKiBzcXJ0KGFTaXplIC8gNS4wKTtcXG4gICAgICAgIHZTdHJva2VXaWR0aFJhdGlvID0gdVN0cm9rZVdpZHRoIC8gKHZTaXplICsgdVN0cm9rZVdpZHRoICsgMS4wKTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IHZTaXplICsgdVN0cm9rZVdpZHRoICsgMS4wO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDcm9zc1ZhbHVlLCBhTWFpblZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGNhbmRsZXN0aWNrID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYW5kd2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUhpZ2hWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhT3BlblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDbG9zZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFMb3dWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2Q29sb3JJbmRpY2F0b3I7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQ7XFxuICAgICAgICB2Q29sb3JJbmRpY2F0b3IgPSBzaWduKGFDbG9zZVZhbHVlIC0gYU9wZW5WYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBpc1Bvc2l0aXZlWSA9IChzaWduKGFDb3JuZXIueSkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgaXNOb3RQb3NpdGl2ZVkgPSAxLjAgLSBpc1Bvc2l0aXZlWTtcXG4gICAgICAgIGZsb2F0IGlzRXh0cmVtZVkgPSBhYnMoYUNvcm5lci55KSAtIDEuMDtcXG4gICAgICAgIGZsb2F0IGlzTm90RXh0cmVtZVkgPSAxLjAgLSBpc0V4dHJlbWVZO1xcbiAgICAgICAgZmxvYXQgeVZhbHVlID1cXG4gICAgICAgICAoaXNQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUxvd1ZhbHVlKSArXFxuICAgICAgICAgKGlzUG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFDbG9zZVZhbHVlKSArXFxuICAgICAgICAgKGlzTm90UG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFPcGVuVmFsdWUpICtcXG4gICAgICAgICAoaXNOb3RQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUhpZ2hWYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBsaW5lV2lkdGhYRGlyZWN0aW9uID0gKGlzTm90RXh0cmVtZVkgKiBhQ29ybmVyLngpICsgKGlzRXh0cmVtZVkgKiBhQ29ybmVyLnopO1xcbiAgICAgICAgZmxvYXQgbGluZVdpZHRoWURpcmVjdGlvbiA9IGlzTm90RXh0cmVtZVkgKiBzaWduKGFDbG9zZVZhbHVlIC0gYU9wZW5WYWx1ZSkgKiBhQ29ybmVyLnk7XFxuXFxuICAgICAgICBmbG9hdCBiYW5kd2lkdGhNb2RpZmllciA9IGFCYW5kd2lkdGggKiBhQ29ybmVyLnggLyAyLjA7XFxuXFxuICAgICAgICBmbG9hdCB4TW9kaWZpZXIgPSAodVN0cm9rZVdpZHRoICogbGluZVdpZHRoWERpcmVjdGlvbiAvIDIuMCkgKyBiYW5kd2lkdGhNb2RpZmllcjtcXG4gICAgICAgIGZsb2F0IHlNb2RpZmllciA9IHVTdHJva2VXaWR0aCAqIGxpbmVXaWR0aFlEaXJlY3Rpb24gLyAyLjA7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYUNyb3NzVmFsdWUsIHlWYWx1ZSwgMCwgMSk7XCJcbiAgICB9O1xuICAgIHZhciBvaGxjID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYW5kd2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUhpZ2hWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhT3BlblZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDbG9zZVZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFMb3dWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2Q29sb3JJbmRpY2F0b3I7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQ7XFxuICAgICAgICB2Q29sb3JJbmRpY2F0b3IgPSBzaWduKGFDbG9zZVZhbHVlIC0gYU9wZW5WYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBpc1Bvc2l0aXZlWSA9IChzaWduKGFDb3JuZXIueSkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgaXNOb3RQb3NpdGl2ZVkgPSAxLjAgLSBpc1Bvc2l0aXZlWTtcXG4gICAgICAgIGZsb2F0IGlzRXh0cmVtZVkgPSBhYnMoYUNvcm5lci55KSAtIDEuMDtcXG4gICAgICAgIGZsb2F0IGlzTm90RXh0cmVtZVkgPSAxLjAgLSBpc0V4dHJlbWVZO1xcbiAgICAgICAgZmxvYXQgeVZhbHVlID1cXG4gICAgICAgICAgICAoaXNQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUxvd1ZhbHVlKSArXFxuICAgICAgICAgICAgKGlzUG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFDbG9zZVZhbHVlKSArXFxuICAgICAgICAgICAgKGlzTm90UG9zaXRpdmVZICogaXNOb3RFeHRyZW1lWSAqIGFPcGVuVmFsdWUpICtcXG4gICAgICAgICAgICAoaXNOb3RQb3NpdGl2ZVkgKiBpc0V4dHJlbWVZICogYUhpZ2hWYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCBsaW5lV2lkdGhYRGlyZWN0aW9uID0gaXNFeHRyZW1lWSAqIGFDb3JuZXIuejtcXG4gICAgICAgIGZsb2F0IGxpbmVXaWR0aFlEaXJlY3Rpb24gPSBpc05vdEV4dHJlbWVZICogYUNvcm5lci56O1xcblxcbiAgICAgICAgZmxvYXQgYmFuZHdpZHRoTW9kaWZpZXIgPSBpc05vdEV4dHJlbWVZICogYUNvcm5lci54ICogYUJhbmR3aWR0aCAvIDIuMDtcXG5cXG4gICAgICAgIGZsb2F0IHhNb2RpZmllciA9ICh1U3Ryb2tlV2lkdGggKiBsaW5lV2lkdGhYRGlyZWN0aW9uIC8gMi4wKSArIGJhbmR3aWR0aE1vZGlmaWVyO1xcbiAgICAgICAgZmxvYXQgeU1vZGlmaWVyID0gdVN0cm9rZVdpZHRoICogbGluZVdpZHRoWURpcmVjdGlvbiAvIDIuMDtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgeVZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGJhciA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQmFuZHdpZHRoO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFNYWluVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUJhc2VWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICB2RGVmaW5lZCA9IGFEZWZpbmVkO1xcbiAgICAgICAgZmxvYXQgaXNCYXNlbGluZSA9ICgxLjAgLSBhQ29ybmVyLnkpIC8gMi4wO1xcbiAgICAgICAgZmxvYXQgeVZhbHVlID0gKGlzQmFzZWxpbmUgKiBhQmFzZVZhbHVlKSArICgoMS4wIC0gaXNCYXNlbGluZSkgKiBhTWFpblZhbHVlKTtcXG5cXG4gICAgICAgIGZsb2F0IHhNb2RpZmllciA9IGFDb3JuZXIueCAqIChhQmFuZHdpZHRoKSAvIDIuMDtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgeVZhbHVlLCAwLCAxKTtcIlxuICAgIH07XG4gICAgdmFyIGVycm9yQmFyID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYUNvcm5lcjtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQmFuZHdpZHRoO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFIaWdoVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUxvd1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcblxcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHVTY3JlZW47XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVTdHJva2VXaWR0aDtcXG5cXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIGZsb2F0IGlzTG93ID0gKGFDb3JuZXIueSArIDEuMCkgLyAyLjA7XFxuICAgICAgICBmbG9hdCB5VmFsdWUgPSBpc0xvdyAqIGFMb3dWYWx1ZSArICgxLjAgLSBpc0xvdykgKiBhSGlnaFZhbHVlO1xcblxcbiAgICAgICAgZmxvYXQgaXNFZGdlQ29ybmVyID0gYWJzKGFDb3JuZXIueCk7XFxuICAgICAgICBmbG9hdCBsaW5lV2lkdGhYRGlyZWN0aW9uID0gKDEuMCAtIGlzRWRnZUNvcm5lcikgKiBhQ29ybmVyLno7XFxuICAgICAgICBmbG9hdCBsaW5lV2lkdGhZRGlyZWN0aW9uID0gaXNFZGdlQ29ybmVyICogYUNvcm5lci56O1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFDcm9zc1ZhbHVlLCB5VmFsdWUsIDAsIDEpO1xcblxcbiAgICAgICAgZmxvYXQgeE1vZGlmaWVyID0gKHVTdHJva2VXaWR0aCAqIGxpbmVXaWR0aFhEaXJlY3Rpb24pICsgKGFCYW5kd2lkdGggKiBhQ29ybmVyLnggLyAyLjApO1xcbiAgICAgICAgZmxvYXQgeU1vZGlmaWVyID0gKHVTdHJva2VXaWR0aCAqIGxpbmVXaWR0aFlEaXJlY3Rpb24pO1wiXG4gICAgfTtcbiAgICB2YXIgYXJlYSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb3JuZXI7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQ3Jvc3NOZXh0VmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5OZXh0VmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUJhc2VWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhQmFzZU5leHRWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZDtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZE5leHQ7XFxuXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1xcblxcbiAgICAgICAgZmxvYXQgd2hlbl9sdChmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG1heChzaWduKGIgLSBhKSwgMC4wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IGFuZChmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGEgKiBiO1xcbiAgICAgICAgfVwiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIHZEZWZpbmVkID0gYURlZmluZWQgKiBhRGVmaW5lZE5leHQ7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuXFxuICAgICAgICBmbG9hdCBoYXNJbnRlcmNlcHRlZCA9IHdoZW5fbHQoKGFNYWluTmV4dFZhbHVlIC0gYUJhc2VOZXh0VmFsdWUpICogKGFNYWluVmFsdWUgLSBhQmFzZVZhbHVlKSwgMC4wKTtcXG4gICAgICAgIGZsb2F0IHVzZUludGVyY2VwdCA9IGFuZChhQ29ybmVyLnosIGhhc0ludGVyY2VwdGVkKTtcXG5cXG4gICAgICAgIGZsb2F0IHlHcmFkaWVudCA9IChhTWFpbk5leHRWYWx1ZSAtIGFNYWluVmFsdWUpIC8gKGFDcm9zc05leHRWYWx1ZSAtIGFDcm9zc1ZhbHVlKTtcXG4gICAgICAgIGZsb2F0IHlDb25zdGFudCA9IGFNYWluTmV4dFZhbHVlIC0gKHlHcmFkaWVudCAqIGFDcm9zc05leHRWYWx1ZSk7XFxuXFxuICAgICAgICBmbG9hdCB5MEdyYWRpZW50ID0gKGFCYXNlTmV4dFZhbHVlIC0gYUJhc2VWYWx1ZSkgLyAoYUNyb3NzTmV4dFZhbHVlIC0gYUNyb3NzVmFsdWUpO1xcbiAgICAgICAgZmxvYXQgeTBDb25zdGFudCA9IGFCYXNlTmV4dFZhbHVlIC0gKHkwR3JhZGllbnQgKiBhQ3Jvc3NOZXh0VmFsdWUpO1xcblxcbiAgICAgICAgZmxvYXQgZGVub21pbmF0b3IgPSAoeUdyYWRpZW50IC0geTBHcmFkaWVudCkgKyBzdGVwKGFicyh5R3JhZGllbnQgLSB5MEdyYWRpZW50KSwgMC4wKTtcXG4gICAgICAgIGZsb2F0IGludGVyY2VwdFhWYWx1ZSA9ICh5MENvbnN0YW50IC0geUNvbnN0YW50KSAvIGRlbm9taW5hdG9yO1xcbiAgICAgICAgZmxvYXQgaW50ZXJjZXB0WVZhbHVlID0gKHlHcmFkaWVudCAqIGludGVyY2VwdFhWYWx1ZSkgKyB5Q29uc3RhbnQ7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoaW50ZXJjZXB0WFZhbHVlICogdXNlSW50ZXJjZXB0LCBpbnRlcmNlcHRZVmFsdWUgKiB1c2VJbnRlcmNlcHQsIDAsIDEpO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24ueCArPSAoMS4wIC0gdXNlSW50ZXJjZXB0KSAqICgoYUNvcm5lci54ICogYUNyb3NzTmV4dFZhbHVlKSArICgoMS4wIC0gYUNvcm5lci54KSAqIGFDcm9zc1ZhbHVlKSk7XFxuICAgICAgICBnbF9Qb3NpdGlvbi55ICs9ICgxLjAgLSB1c2VJbnRlcmNlcHQpICogKDEuMCAtIGFDb3JuZXIueSkgKiAoKGFDb3JuZXIueCAqIGFNYWluTmV4dFZhbHVlKSArICgoMS4wIC0gYUNvcm5lci54KSAqIGFNYWluVmFsdWUpKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgKz0gKDEuMCAtIHVzZUludGVyY2VwdCkgKiBhQ29ybmVyLnkgKiAoKGFDb3JuZXIueCAqIGFCYXNlTmV4dFZhbHVlKSArICgoMS4wIC0gYUNvcm5lci54KSAqIGFCYXNlVmFsdWUpKTtcIlxuICAgIH07XG4gICAgdmFyIGJveFBsb3QgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhQ29ybmVyO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc1ZhbHVlO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFCYW5kd2lkdGg7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNhcFdpZHRoO1xcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFIaWdoVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYVVwcGVyUXVhcnRpbGVWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTWVkaWFuVmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUxvd2VyUXVhcnRpbGVWYWx1ZTtcXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhTG93VmFsdWU7XFxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYURlZmluZWQ7XFxuXFxuICAgICAgICB1bmlmb3JtIHZlYzIgdVNjcmVlbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdVN0cm9rZVdpZHRoO1xcblxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcXG4gICAgXCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgdkRlZmluZWQgPSBhRGVmaW5lZDtcXG4gICAgICAgIGZsb2F0IGlzRXh0cmVtZVkgPSBzaWduKGFicyhhQ29ybmVyLnkpIC0gMi4wKSArIDEuMDtcXG4gICAgICAgIGZsb2F0IGlzTm90RXh0cmVtZVkgPSAxLjAgLSBpc0V4dHJlbWVZO1xcblxcbiAgICAgICAgZmxvYXQgaXNOb25aZXJvWSA9IGFicyhzaWduKGFDb3JuZXIueSkpO1xcbiAgICAgICAgZmxvYXQgaXNaZXJvWSA9IDEuMCAtIGlzTm9uWmVyb1k7XFxuXFxuICAgICAgICBmbG9hdCBpc1F1YXJ0aWxlWSA9IGlzTm90RXh0cmVtZVkgKiBpc05vblplcm9ZO1xcblxcbiAgICAgICAgZmxvYXQgaXNQb3NpdGl2ZVkgPSAoc2lnbihhQ29ybmVyLnkgKyAwLjUpICsgMS4wKSAvIDIuMDtcXG4gICAgICAgIGZsb2F0IGlzTmVnYXRpdmVZID0gMS4wIC0gaXNQb3NpdGl2ZVk7XFxuXFxuICAgICAgICBmbG9hdCB5VmFsdWUgPVxcbiAgICAgICAgICAoaXNFeHRyZW1lWSAqIGlzTmVnYXRpdmVZKSAqIGFIaWdoVmFsdWUgK1xcbiAgICAgICAgICAoaXNRdWFydGlsZVkgKiBpc05lZ2F0aXZlWSkgKiBhVXBwZXJRdWFydGlsZVZhbHVlICtcXG4gICAgICAgICAgaXNaZXJvWSAqIGFNZWRpYW5WYWx1ZSArXFxuICAgICAgICAgIChpc1F1YXJ0aWxlWSAqIGlzUG9zaXRpdmVZKSAqIGFMb3dlclF1YXJ0aWxlVmFsdWUgK1xcbiAgICAgICAgICAoaXNFeHRyZW1lWSAqIGlzUG9zaXRpdmVZKSAqIGFMb3dWYWx1ZTtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhQ3Jvc3NWYWx1ZSwgeVZhbHVlLCAwLCAxKTtcXG5cXG4gICAgICAgIGZsb2F0IGlzSG9yaXpvbnRhbCA9IGFDb3JuZXIudztcXG4gICAgICAgIGZsb2F0IGlzVmVydGljYWwgPSAxLjAgLSBpc0hvcml6b250YWw7XFxuXFxuICAgICAgICBmbG9hdCB4RGlzcGxhY2VtZW50ID0gYUNvcm5lci54ICogKGlzRXh0cmVtZVkgKiBhQ2FwV2lkdGggKyBpc05vdEV4dHJlbWVZICogYUJhbmR3aWR0aCkgLyAyLjA7XFxuXFxuICAgICAgICBmbG9hdCB4TW9kaWZpZXIgPSAoaXNWZXJ0aWNhbCAqIHVTdHJva2VXaWR0aCAqIGFDb3JuZXIueiAvIDIuMCkgKyB4RGlzcGxhY2VtZW50O1xcbiAgICAgICAgZmxvYXQgeU1vZGlmaWVyID0gaXNIb3Jpem9udGFsICogdVN0cm9rZVdpZHRoICogYUNvcm5lci56IC8gMi4wO1wiXG4gICAgfTtcblxuICAgIHZhciBjaXJjbGUkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAxLjA7XFxuICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aCgyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wKTtcXG4gICAgICAgIGZsb2F0IGNhblN0cm9rZSA9IHNtb290aHN0ZXAodlNpemUgLSAyLjAsIHZTaXplLCBkaXN0YW5jZSAqIHZTaXplKTtcXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDEuMCB8fCB2RGVmaW5lZCA8IDAuNSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVwiXG4gICAgfTsgLy8gU2VlIGh0dHBzOi8vaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL2Rpc3RmdW5jdGlvbnMyZC9kaXN0ZnVuY3Rpb25zMmQuaHRtLlxuXG4gICAgdmFyIHN0YXIkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1xcblxcbiAgICAgICAgLy8gYW50ZXJpb3IsIGV4dGVyaW9yIGFuZ2xlc1xcbiAgICAgICAgZmxvYXQgYW4gPSAwLjYyODMxOTtcXG4gICAgICAgIHZlYzIgYWNzID0gdmVjMigwLjgwOTAxNywgMC41ODc3ODYpOyAvLyAoY29zLCBzaW4pXFxuICAgICAgICBmbG9hdCBlbiA9IDAuOTUyMDAwO1xcbiAgICAgICAgdmVjMiBlY3MgPSB2ZWMyKDAuNTgwMDU1LCAwLjgxNDU3Nyk7XFxuICAgIFwiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAxLjA7XFxuXFxuICAgICAgICB2ZWMyIHAgPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xcbiAgICAgICAgcC55ICo9IC0xLjA7XFxuXFxuICAgICAgICAvLyBzZWN0b3JcXG4gICAgICAgIGZsb2F0IGJuID0gbW9kKGF0YW4ocC54LCBwLnkpLCAyLjAgKiBhbikgLSBhbjtcXG4gICAgICAgIHAgPSBsZW5ndGgocCkgKiB2ZWMyKGNvcyhibiksIGFicyhzaW4oYm4pKSk7XFxuXFxuICAgICAgICBwIC09IGFjcztcXG4gICAgICAgIHAgKz0gZWNzICogY2xhbXAoLWRvdChwLCBlY3MpLCAwLjAsIGFjcy55IC8gZWNzLnkpO1xcbiAgICAgICAgZmxvYXQgZCA9IGxlbmd0aChwKSAqIHNpZ24ocC54KTtcXG5cXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gMS4wICsgZDtcXG4gICAgICAgIGZsb2F0IGNhblN0cm9rZSA9IHNtb290aHN0ZXAodlNpemUgLSAyLjAsIHZTaXplLCBkaXN0YW5jZSAqIHZTaXplKTtcXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDEuMCB8fCB2RGVmaW5lZCA8IDAuNSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgd3llJDEgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcXG4gICAgXCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG5cXG4gICAgICAgIHZlYzIgcCA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XFxuICAgICAgICBwLnkgKj0gLTEuMDtcXG5cXG4gICAgICAgIC8vIHNlY3RvclxcbiAgICAgICAgZmxvYXQgYW4gPSAzLjE0MTU5MyAvIDMuMDtcXG4gICAgICAgIGZsb2F0IGJuID0gbW9kKGF0YW4ocC54LCBwLnkpLCAyLjAgKiBhbikgLSBhbjtcXG4gICAgICAgIHAgPSBsZW5ndGgocCkgKiB2ZWMyKGNvcyhibiksIGFicyhzaW4oYm4pKSk7XFxuXFxuICAgICAgICAvLyBib3hcXG4gICAgICAgIHZlYzIgZCA9IGFicyhwKSAtIHZlYzIoMC45LCAwLjM1KTtcXG4gICAgICAgIGZsb2F0IHNkZiA9IGxlbmd0aChtYXgoZCwgMC4wKSkgKyBtaW4obWF4KGQueCwgZC55KSwgMC4wKTtcXG5cXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gMS4wICsgc2RmO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gc21vb3Roc3RlcCh2U2l6ZSAtIDIuMCwgdlNpemUsIGRpc3RhbmNlICogdlNpemUpO1xcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMS4wIHx8IHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XCJcbiAgICB9O1xuICAgIHZhciBzcXVhcmUkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1wiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGZsb2F0IGNhbkZpbGwgPSAxLjA7XFxuICAgICAgICBpZiAodkRlZmluZWQgPCAwLjUpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmVjMiBwb2ludENvb3JkVHJhbnNmb3JtID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlID0gbWF4KGFicyhwb2ludENvb3JkVHJhbnNmb3JtLngpLCBhYnMocG9pbnRDb29yZFRyYW5zZm9ybS55KSk7XFxuICAgICAgICBmbG9hdCBjYW5TdHJva2UgPSBzbW9vdGhzdGVwKHZTaXplIC0gMi4wLCB2U2l6ZSwgZGlzdGFuY2UgKiB2U2l6ZSk7XCJcbiAgICB9OyAvLyBEaWFtb25kIGlzIHN5bW1ldHJpY2FsIGFib3V0IHRoZSB4LCBhbmQgeSBheGVzLCBzbyBvbmx5IGNvbnNpZGVyIHgsIHkgPiAwLlxuICAgIC8vICh4LCB5KSBhcmUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBmcmFnbWVudCB3aXRoaW4gdGhlIGdsIHBvaW50IChhZnRlclxuICAgIC8vIHRyYW5zZm9ybWVkIHRvIGJlIFstMSwgMV0pLlxuICAgIC8vIGEsIGIgY29udHJvbCB0aGUgd2lkdGgsIGhlaWdodCBvZiB0aGUgdHJpYW5nbGUsIHNvIGRpYW1vbmQgaXMgMmEsIDJiLlxuICAgIC8vIExpbmUgTCBpcyBhIHJheSBmcm9tIHRoZSBvcmlnaW4gdGhyb3VnaCAoeCwgeSksIHRoZSBkaXN0YW5jZSBmdW5jdGlvbiBpcyB0aGVuXG4gICAgLy8gdGhlIGRpc3RhbmNlIHRvICh4LCB5KSBkaXZpZGVkIGJ5IHRoZSBkaXN0YW5jZSB0byB3aGVyZSBMIGludGVyc2VjdHMgd2l0aCB0aGVcbiAgICAvLyBkaWFtb25kLCB0aGlzIG1ha2VzIHRoZSBkaXN0YW5jZSBmdW5jdGlvbiA8IDEgaW5zaWRlLCAxIG9uIHRoZSBib3VuZGFyeSwgYW5kXG4gICAgLy8gPiAxIG91dHNpZGUgdGhlIGRpYW1vbmQuXG4gICAgLy8gICAgfFxuICAgIC8vIGIgLS0tXG4gICAgLy8gICAgfFxcICAgICAgICAgICAgIExcbiAgICAvLyAgICB8IC1cXCAgICAgICAgICAvXG4gICAgLy8gICAgfCAgIFxcICAgICAgICAvXG4gICAgLy8gICAgfCAgICBcXCAgICAgIC9cbiAgICAvLyAgICB8ICAgICAtXFwgICAvXG4gICAgLy8gICAgfCAgICAgICBcXCAvXG4gICAgLy8gWSAtLS0gICAgICAgWFxuICAgIC8vICAgIHwgICAgICAgLyAtXFxcbiAgICAvLyAgICB8ICAgICAgLyAgICBcXFxuICAgIC8vICAgIHwgICAgIC8gICAgICBcXFxuICAgIC8vIHkgLS0tICAgWCAgICAgICAgLVxcXG4gICAgLy8gICAgfCAgIC8gICAgICAgICAgIFxcXG4gICAgLy8gICAgfCAgLyAgICAgICAgICAgICBcXFxuICAgIC8vICAgIHwgLyAgICAgICAgICAgICAgIC1cXFxuICAgIC8vICAgIHwvICAgICAgICAgICAgICAgICAgXFxcbiAgICAvLyAgICArLS0tLXwtLS18LS0tLS0tLS0tLS18LS0tXG4gICAgLy8gICAgICAgICB4ICAgWCAgICAgICAgICAgYVxuXG4gICAgdmFyIGRpYW1vbmQkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdlNpemU7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1xcbiAgICAgICAgZmxvYXQgYSA9IDAuNjtcXG4gICAgICAgIGZsb2F0IGIgPSAxLjA7XFxuICAgIFwiLFxuICAgICAgYm9keTogXCJcXG4gICAgICAgIGlmICh2RGVmaW5lZCA8IDAuNSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2ZWMyIHBvaW50Q29vcmRUcmFuc2Zvcm0gPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xcblxcbiAgICAgICAgZmxvYXQgeCA9IGFicyhwb2ludENvb3JkVHJhbnNmb3JtLngpO1xcbiAgICAgICAgZmxvYXQgeSA9IGFicyhwb2ludENvb3JkVHJhbnNmb3JtLnkpO1xcblxcbiAgICAgICAgZmxvYXQgWCA9IChhICogYiAqIHgpIC8gKGEgKiB5ICsgYiAqIHgpO1xcbiAgICAgICAgZmxvYXQgWSA9IChhICogYiAqIHkpIC8gKGEgKiB5ICsgYiAqIHgpO1xcblxcbiAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSBsZW5ndGgodmVjMih4LCB5KSkgLyBsZW5ndGgodmVjMihYLCBZKSk7XFxuXFxuICAgICAgICBpZiAoZGlzdGFuY2UgPiAxLjApIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICBcIlxuICAgIH07XG4gICAgdmFyIHRyaWFuZ2xlJDEgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMS4wO1xcbiAgICAgICAgdmVjMiBwb2ludENvb3JkVHJhbnNmb3JtID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXG4gICAgICAgIGZsb2F0IHRvcEVkZ2VzRGlzdGFuY2UgPSBhYnMocG9pbnRDb29yZFRyYW5zZm9ybS54KSAtICgocG9pbnRDb29yZFRyYW5zZm9ybS55IC0gMC42KSAvIHNxcnQoMy4wKSk7XFxuICAgICAgICBmbG9hdCBib3R0b21FZGdlRGlzdGFuY2UgPSBwb2ludENvb3JkVHJhbnNmb3JtLnkgKyAwLjU7XFxuICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IG1heCh0b3BFZGdlc0Rpc3RhbmNlLCBib3R0b21FZGdlRGlzdGFuY2UpO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gc21vb3Roc3RlcCh2U2l6ZSAtIDIuMCwgdlNpemUsIGRpc3RhbmNlICogdlNpemUpO1xcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMS4wIHx8IHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIGNyb3NzJDEgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZTaXplO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2U3Ryb2tlV2lkdGhSYXRpbztcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG4gICAgICAgIHZlYzIgcG9pbnRDb29yZFRyYW5zZm9ybSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XFxuICAgICAgICBmbG9hdCBpbm5lckNvcm5lckRpc3RhbmNlID0gbWluKGFicyhwb2ludENvb3JkVHJhbnNmb3JtLngpLCBhYnMocG9pbnRDb29yZFRyYW5zZm9ybS55KSkgKyAwLjY2IC0gdlN0cm9rZVdpZHRoUmF0aW87XFxuICAgICAgICBmbG9hdCBvdXRlckVkZ2VEaXN0YW5jZSA9IG1heChhYnMocG9pbnRDb29yZFRyYW5zZm9ybS54KSwgYWJzKHBvaW50Q29vcmRUcmFuc2Zvcm0ueSkpO1xcbiAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSBtYXgoaW5uZXJDb3JuZXJEaXN0YW5jZSwgb3V0ZXJFZGdlRGlzdGFuY2UpO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gc21vb3Roc3RlcCh2U2l6ZSAtIDIuMCwgdlNpemUsIGRpc3RhbmNlICogdlNpemUpO1xcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMS4wIHx8IHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIGNhbmRsZXN0aWNrJDEgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZDb2xvckluZGljYXRvcjtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG4gICAgICAgIGZsb2F0IGNhblN0cm9rZSA9IDAuMDtcXG4gICAgICAgIGlmICh2RGVmaW5lZCA8IDAuNSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNCwgMC44LCAwLCAxKTtcXG4gICAgICAgIGlmICh2Q29sb3JJbmRpY2F0b3IgPCAwLjApIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOCwgMC40LCAwLCAxKTtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIG9obGMkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkNvbG9ySW5kaWNhdG9yO1xcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMC4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMS4wO1xcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC40LCAwLjgsIDAsIDEpO1xcbiAgICAgICAgaWYgKHZDb2xvckluZGljYXRvciA8IDAuMCkge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC44LCAwLjQsIDAsIDEpO1xcbiAgICAgICAgfVwiXG4gICAgfTtcbiAgICB2YXIgYXJlYSQxID0ge1xuICAgICAgaGVhZGVyOiBcIlxcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMS4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMC4wO1xcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC44NiwgMC44NiwgMC44NiwgMSk7XCJcbiAgICB9O1xuICAgIHZhciBib3hQbG90JDEgPSB7XG4gICAgICBoZWFkZXI6IFwiXFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZEZWZpbmVkO1xcbiAgICBcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMC4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMS4wO1xcblxcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIGVycm9yQmFyJDEgPSB7XG4gICAgICBoZWFkZXI6IFwidmFyeWluZyBmbG9hdCB2RGVmaW5lZDtcIixcbiAgICAgIGJvZHk6IFwiXFxuICAgICAgICBmbG9hdCBjYW5GaWxsID0gMC4wO1xcbiAgICAgICAgZmxvYXQgY2FuU3Ryb2tlID0gMS4wO1xcbiAgICAgICAgaWYgKHZEZWZpbmVkIDwgMC41KSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cIlxuICAgIH07XG4gICAgdmFyIGJhciQxID0ge1xuICAgICAgaGVhZGVyOiBcInZhcnlpbmcgZmxvYXQgdkRlZmluZWQ7XCIsXG4gICAgICBib2R5OiBcIlxcbiAgICAgICAgZmxvYXQgY2FuRmlsbCA9IDEuMDtcXG4gICAgICAgIGZsb2F0IGNhblN0cm9rZSA9IDAuMDtcXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC42MCwgMC42MCwgMC42MCwgMS4wKTtcXG5cXG4gICAgICAgIGlmICh2RGVmaW5lZCA8IDAuNSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XCJcbiAgICB9O1xuICAgIHZhciBmaWxsQ29sb3IkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJ2YXJ5aW5nIHZlYzQgdkZpbGxDb2xvcjtcIixcbiAgICAgIGJvZHk6IFwiZ2xfRnJhZ0NvbG9yID0gKGNhbkZpbGwgKiB2RmlsbENvbG9yKSArICgoMS4wIC0gY2FuRmlsbCkgKiBnbF9GcmFnQ29sb3IpO1wiXG4gICAgfTtcbiAgICB2YXIgc3Ryb2tlQ29sb3IkMSA9IHtcbiAgICAgIGhlYWRlcjogXCJ2YXJ5aW5nIHZlYzQgdlN0cm9rZUNvbG9yO1wiLFxuICAgICAgYm9keTogXCJnbF9GcmFnQ29sb3IgPSAoY2FuU3Ryb2tlICogdlN0cm9rZUNvbG9yKSArICgoMS4wIC0gY2FuU3Ryb2tlKSAqIGdsX0ZyYWdDb2xvcik7XCJcbiAgICB9O1xuXG4gICAgdmFyIGFyZWFTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKGFyZWEuaGVhZGVyKS5hcHBlbmRCb2R5KGFyZWEuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoYXJlYSQxLmhlYWRlcikuYXBwZW5kQm9keShhcmVhJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIHR5cGVzID0ge1xuICAgICAgQllURTogNTEyMCxcbiAgICAgIFVOU0lHTkVEX0JZVEU6IDUxMjEsXG4gICAgICBTSE9SVDogNTEyMixcbiAgICAgIFVOU0lHTkVEX1NIT1JUOiA1MTIzLFxuICAgICAgRkxPQVQ6IDUxMjZcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxlbmd0aCh0eXBlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5CWVRFOlxuICAgICAgICBjYXNlIHR5cGVzLlVOU0lHTkVEX0JZVEU6XG4gICAgICAgICAgcmV0dXJuIDE7XG5cbiAgICAgICAgY2FzZSB0eXBlcy5TSE9SVDpcbiAgICAgICAgY2FzZSB0eXBlcy5VTlNJR05FRF9TSE9SVDpcbiAgICAgICAgICByZXR1cm4gMjtcblxuICAgICAgICBjYXNlIHR5cGVzLkZMT0FUOlxuICAgICAgICAgIHJldHVybiA0O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiLmNvbmNhdCh0eXBlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEFycmF5Vmlld0NvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLkJZVEU6XG4gICAgICAgICAgcmV0dXJuIEludDhBcnJheTtcblxuICAgICAgICBjYXNlIHR5cGVzLlVOU0lHTkVEX0JZVEU6XG4gICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG5cbiAgICAgICAgY2FzZSB0eXBlcy5TSE9SVDpcbiAgICAgICAgICByZXR1cm4gSW50MTZBcnJheTtcblxuICAgICAgICBjYXNlIHR5cGVzLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgIHJldHVybiBVaW50MTZBcnJheTtcblxuICAgICAgICBjYXNlIHR5cGVzLkZMT0FUOlxuICAgICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZUF0dHJpYnV0ZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvY2F0aW9uID0gLTE7XG4gICAgICB2YXIgYnVmZmVyID0gbnVsbDtcbiAgICAgIHZhciBzaXplID0gMTsgLy8gcGVyIHZlcnRleFxuXG4gICAgICB2YXIgdHlwZSA9IHR5cGVzLkZMT0FUO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBzdHJpZGUgPSAwO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgZGl2aXNvciA9IG51bGw7XG5cbiAgICAgIHZhciBiYXNlQXR0cmlidXRlID0gZnVuY3Rpb24gYmFzZUF0dHJpYnV0ZShwcm9ncmFtQnVpbGRlcikge1xuICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtQnVpbGRlci5jb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIHZhciBleHRJbnN0YW5jZWRBcnJheXMgPSBwcm9ncmFtQnVpbGRlci5leHRJbnN0YW5jZWRBcnJheXMoKTtcbiAgICAgICAgZXh0SW5zdGFuY2VkQXJyYXlzLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShsb2NhdGlvbiwgZGl2aXNvciAhPSBudWxsID8gZGl2aXNvciA6IHByb2dyYW1CdWlsZGVyLnN1Ykluc3RhbmNlQ291bnQoKSA+IDAgPyAxIDogMCk7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLmxvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLmJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLnN0cmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmlkZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLm9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlQXR0cmlidXRlLmRpdmlzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkaXZpc29yO1xuICAgICAgICB9XG5cbiAgICAgICAgZGl2aXNvciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGJhc2VBdHRyaWJ1dGU7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYmFzZUF0dHJpYnV0ZTtcbiAgICB9KTtcblxuICAgIHZhciBkZWZhdWx0QXJyYXlWaWV3RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVzLkZMT0FUO1xuICAgICAgdmFyIGNhY2hlZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgwKTtcblxuICAgICAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbiBmYWN0b3J5KHJlcXVpcmVkTGVuZ3RoKSB7XG4gICAgICAgIHZhciBBcnJheVR5cGUgPSBnZXRBcnJheVZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcblxuICAgICAgICBpZiAoY2FjaGVkQXJyYXkubGVuZ3RoID4gcmVxdWlyZWRMZW5ndGgpIHtcbiAgICAgICAgICBjYWNoZWRBcnJheSA9IG5ldyBBcnJheVR5cGUoY2FjaGVkQXJyYXkuYnVmZmVyLCAwLCByZXF1aXJlZExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FjaGVkQXJyYXkubGVuZ3RoICE9PSByZXF1aXJlZExlbmd0aCkge1xuICAgICAgICAgIGNhY2hlZEFycmF5ID0gbmV3IEFycmF5VHlwZShyZXF1aXJlZExlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVkQXJyYXk7XG4gICAgICB9O1xuXG4gICAgICBmYWN0b3J5LnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgIT09IChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB2YXIgQXJyYXlUeXBlID0gZ2V0QXJyYXlWaWV3Q29uc3RydWN0b3IodHlwZSk7XG4gICAgICAgICAgY2FjaGVkQXJyYXkgPSBuZXcgQXJyYXlUeXBlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9KTtcblxuICAgIHZhciBhdHRyaWJ1dGVQcm9qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIHZhciBzaXplID0gMTsgLy8gcGVyIHZlcnRleFxuXG4gICAgICB2YXIgdHlwZSA9IHR5cGVzLkZMT0FUO1xuICAgICAgdmFyIGFycmF5Vmlld0ZhY3RvcnkgPSBkZWZhdWx0QXJyYXlWaWV3RmFjdG9yeSgpO1xuXG4gICAgICB2YXIgdmFsdWUgPSBmdW5jdGlvbiB2YWx1ZShkLCBpKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICB2YXIgcHJvamVjdG9yID0gZnVuY3Rpb24gcHJvamVjdG9yKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBwcm9qZWN0ZWREYXRhID0gYXJyYXlWaWV3RmFjdG9yeS50eXBlKHR5cGUpKGxlbmd0aCAqIHNpemUpO1xuXG4gICAgICAgIGlmIChzaXplID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRWYWx1ZXMgPSB2YWx1ZShkYXRhW2ldLCBpKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFZhbHVlcy5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgY29tcG9uZW50cyBhcnJheSBvZiBzaXplIFwiLmNvbmNhdChzaXplLCBcIiwgcmVjaWV2ZWQgYXJyYXkgd2l0aCBsZW5ndGggXCIpLmNvbmNhdChjb21wb25lbnRWYWx1ZXMubGVuZ3RoLCBcIi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBjb21wb25lbnQgPSAwOyBjb21wb25lbnQgPCBzaXplOyBjb21wb25lbnQrKykge1xuICAgICAgICAgICAgICBwcm9qZWN0ZWREYXRhW2kgKiBzaXplICsgY29tcG9uZW50XSA9IGNvbXBvbmVudFZhbHVlc1tjb21wb25lbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50VmFsdWUgPSB2YWx1ZShkYXRhW19pXSwgX2kpO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBzaW5nbGUgY29tcG9uZW50IHZhbHVlLCByZWNpZXZlZCBhcnJheSB3aXRoIGxlbmd0aCBcIi5jb25jYXQoY29tcG9uZW50VmFsdWUubGVuZ3RoLCBcIi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9qZWN0ZWREYXRhW19pXSA9IGNvbXBvbmVudFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBwcm9qZWN0ZWREYXRhO1xuICAgICAgfTtcblxuICAgICAgcHJvamVjdG9yLmRpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICB9O1xuXG4gICAgICBwcm9qZWN0b3IuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHByb2plY3Rvci5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICAgIH07XG5cbiAgICAgIHByb2plY3Rvci50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICAgIH07XG5cbiAgICAgIHByb2plY3Rvci5hcnJheVZpZXdGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlWaWV3RmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5Vmlld0ZhY3RvcnkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICAgIH07XG5cbiAgICAgIHByb2plY3Rvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICAgIH07XG5cbiAgICAgIHByb2plY3Rvci5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9qZWN0b3I7XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiYXNlID0gYmFzZUF0dHJpYnV0ZUJ1aWxkZXIoKTtcbiAgICAgIHZhciBwcm9qZWN0b3IgPSBhdHRyaWJ1dGVQcm9qZWN0b3IoKTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGF0dHJpYnV0ZShwcm9ncmFtQnVpbGRlcikge1xuICAgICAgICBiYXNlLnNpemUoYXR0cmlidXRlLnNpemUoKSkudHlwZShhdHRyaWJ1dGUudHlwZSgpKTtcbiAgICAgICAgYmFzZShwcm9ncmFtQnVpbGRlcik7XG5cbiAgICAgICAgaWYgKCFwcm9qZWN0b3IuZGlydHkoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9qZWN0ZWREYXRhID0gcHJvamVjdG9yKCk7XG4gICAgICAgIHZhciBnbCA9IHByb2dyYW1CdWlsZGVyLmNvbnRleHQoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJhc2UuYnVmZmVyKCkpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgcHJvamVjdGVkRGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgIH07XG5cbiAgICAgIGF0dHJpYnV0ZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYmFzZS5idWZmZXIobnVsbCk7XG4gICAgICAgIHByb2plY3Rvci5jbGVhcigpO1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoYXR0cmlidXRlLCBiYXNlLCAnbm9ybWFsaXplZCcsICdsb2NhdGlvbicsICdkaXZpc29yJyk7XG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChhdHRyaWJ1dGUsIHByb2plY3RvciwgJ2RhdGEnLCAndmFsdWUnLCAnc2l6ZScsICd0eXBlJyk7XG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlYmluZEN1cnJ5ID0gKGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldE5hbWUsIHNvdXJjZSwgc291cmNlTmFtZSkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGN1cnJpZWRBcmdzID0gbmV3IEFycmF5KF9sZW4gPiA0ID8gX2xlbiAtIDQgOiAwKSwgX2tleSA9IDQ7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgY3VycmllZEFyZ3NbX2tleSAtIDRdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRbdGFyZ2V0TmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBzb3VyY2Vbc291cmNlTmFtZV0uYXBwbHkoc291cmNlLCBjdXJyaWVkQXJncy5jb25jYXQoYXJncykpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBhcmVhJDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2dyYW0gPSBwcm9ncmFtQnVpbGRlcigpLm1vZGUoZHJhd01vZGVzLlRSSUFOR0xFUykuc3ViSW5zdGFuY2VDb3VudCg2KTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcblxuICAgICAgdmFyIGNvcm5lckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZSgpLmRpdmlzb3IoMCkuc2l6ZSgzKS50eXBlKHR5cGVzLlVOU0lHTkVEX0JZVEUpLmRhdGEoW1swLCAwLCAwXSwgWzAsIDEsIDBdLCBbMSwgMSwgMV0sIFswLCAwLCAxXSwgWzEsIDAsIDBdLCBbMSwgMSwgMF1dKTtcbiAgICAgIHByb2dyYW0uYnVmZmVycygpLmF0dHJpYnV0ZSgnYUNvcm5lcicsIGNvcm5lckF0dHJpYnV0ZSk7XG5cbiAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgc2hhZGVyQnVpbGRlciA9IGFyZWFTaGFkZXIoKTtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIoc2hhZGVyQnVpbGRlci52ZXJ0ZXgoKSkuZnJhZ21lbnRTaGFkZXIoc2hhZGVyQnVpbGRlci5mcmFnbWVudCgpKTtcbiAgICAgICAgeFNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDApO1xuICAgICAgICB5U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMSk7XG4gICAgICAgIGRlY29yYXRlKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtKG51bUVsZW1lbnRzIC0gMSk7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LmRlY29yYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb3JhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHlTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBwcm9ncmFtLCAnY29udGV4dCcsICdwaXhlbFJhdGlvJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NOZXh0VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ3Jvc3NOZXh0VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtYWluVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTWFpblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbWFpbk5leHRWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FNYWluTmV4dFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFzZVZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUJhc2VWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Jhc2VOZXh0VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQmFzZU5leHRWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWROZXh0QXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYURlZmluZWROZXh0Jyk7XG4gICAgICByZXR1cm4gZHJhdztcbiAgICB9KTtcblxuICAgIHZhciBjaXJjbGVQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoY2lyY2xlLmhlYWRlcikuYXBwZW5kQm9keShjaXJjbGUuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoY2lyY2xlJDEuaGVhZGVyKS5hcHBlbmRCb2R5KGNpcmNsZSQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBwb2ludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1CdWlsZGVyKCkubW9kZShkcmF3TW9kZXMuUE9JTlRTKTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB0eXBlID0gY2lyY2xlUG9pbnRTaGFkZXIoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcblxuICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbiBkcmF3KG51bUVsZW1lbnRzKSB7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHR5cGUudmVydGV4KCkpLmZyYWdtZW50U2hhZGVyKHR5cGUuZnJhZ21lbnQoKSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICBkZWNvcmF0ZShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbShudW1FbGVtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LmRlY29yYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb3JhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHlTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBwcm9ncmFtLCAnY29udGV4dCcsICdwaXhlbFJhdGlvJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbWFpblZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYU1haW5WYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ3NpemVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhU2l6ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSk7XG5cbiAgICB2YXIgbGluZVdpZHRoU2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3aWR0aCA9IDE7XG5cbiAgICAgIHZhciBsaW5lV2lkdGggPSBmdW5jdGlvbiBsaW5lV2lkdGgocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtLmJ1ZmZlcnMoKS51bmlmb3JtKCd1U3Ryb2tlV2lkdGgnLCB1bmlmb3JtKHdpZHRoKSk7XG4gICAgICB9O1xuXG4gICAgICBsaW5lV2lkdGgubGluZVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGxpbmVXaWR0aDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBsaW5lV2lkdGg7XG4gICAgfSk7XG5cbiAgICB2YXIgZWxlbWVudEluZGljZXMgPSAoZnVuY3Rpb24gKGluaXRpYWxEYXRhKSB7XG4gICAgICB2YXIgYnVmZmVyID0gbnVsbDtcbiAgICAgIHZhciBkYXRhID0gaW5pdGlhbERhdGE7XG4gICAgICB2YXIgZGlydHkgPSB0cnVlO1xuXG4gICAgICB2YXIgYmFzZSA9IGZ1bmN0aW9uIGJhc2UocHJvZ3JhbUJ1aWxkZXIpIHtcbiAgICAgICAgdmFyIGdsID0gcHJvZ3JhbUJ1aWxkZXIuY29udGV4dCgpO1xuXG4gICAgICAgIGlmIChidWZmZXIgPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblxuICAgICAgICBpZiAoIWRpcnR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KGRhdGEpLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBiYXNlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICBiYXNlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH0pO1xuXG4gICAgdmFyIGxpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2dyYW0gPSBwcm9ncmFtQnVpbGRlcigpLm1vZGUoZHJhd01vZGVzLlRSSUFOR0xFUykuc3ViSW5zdGFuY2VDb3VudCg2KTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVXaWR0aFNoYWRlcigpO1xuICAgICAgLypcbiAgICAgICAgICBMaW5lIHNlZ21lbnQgZnJvbSBhIHRvIGIgaGFzIHZlcnRpY2VzIEEsIEIsIEMsIEQgLVxuICAgICAgICAgICAgIEEgfC0tLS0tLS18IEJcbiAgICAgICAgICAgICAgfCBcXCAgICAgfFxuICAgICAgICAgICAgICB8YSAgXFwgIGJ8XG4gICAgICAgICAgICAgIHwgICAgIFxcIHxcbiAgICAgICAgICAgIEQgfC0tLS0tLS18IENcbiAgICAgICAgICAgfEFEfCA9IHVTdHJva2VXaWR0aFxuICAgICAgICAgIHxBQnwgPSB8YWJ8ICsgdVN0cm9rZVdpZHRoXG4gICAgICAgICAgIEZyYWdtZW50IHNoYWRlciBpbXBsZW1lbnRlZCB1c2luZyBsaW5lIHNlZ21lbnQgU0RGIFxuICAgICAgICAgIHNpbXBsaWZpZWQgZm9yIHN0YXJ0aW5nIGF0IHRoZSBvcmlnaW4gKGEpIC1cbiAgICAgICAgICBodHRwczovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvZGlzdGZ1bmN0aW9uczJkL2Rpc3RmdW5jdGlvbnMyZC5odG1cbiAgICAgICovXG5cbiAgICAgIHZhciBjb3JuZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5kaXZpc29yKDApLnNpemUoNCkudHlwZSh0eXBlcy5CWVRFKS5kYXRhKFtbLTEsICsxLCAxLCAwXSwgWysxLCArMSwgMCwgMV0sIFsrMSwgLTEsIDAsIDFdLCBbLTEsIC0xLCAxLCAwXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuZWxlbWVudEluZGljZXMoZWxlbWVudEluZGljZXMoWzAsIDEsIDIsIDIsIDMsIDBdKSkuYXR0cmlidXRlKCdhQ29ybmVyJywgY29ybmVyQXR0cmlidXRlKTtcblxuICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbiBkcmF3KG51bUVsZW1lbnRzKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHZlcnRleFNoYWRlcikuZnJhZ21lbnRTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKFwiXFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgYUNvcm5lcjtcXG4gICAgICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYUNyb3NzVmFsdWU7XFxuICAgICAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFDcm9zc05leHRWYWx1ZTtcXG4gICAgICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5WYWx1ZTtcXG4gICAgICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgYU1haW5OZXh0VmFsdWU7XFxuICAgICAgICAgICAgYXR0cmlidXRlIGZsb2F0IGFEZWZpbmVkO1xcbiAgICAgICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhRGVmaW5lZE5leHQ7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1U3Ryb2tlV2lkdGg7XFxuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVTY3JlZW47XFxuXFxuICAgICAgICAgICAgdmFyeWluZyBmbG9hdCB2TGVuZ3RoO1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2UG9zaXRpb247XFxuICAgICAgICBcIik7XG4gICAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRCb2R5KFwiXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoYUNyb3NzVmFsdWUsIGFNYWluVmFsdWUsIDAuMCwgMS4wKTtcXG4gICAgICAgICAgICB2ZWM0IG5leHRWYWx1ZSA9IHZlYzQoYUNyb3NzTmV4dFZhbHVlLCBhTWFpbk5leHRWYWx1ZSwgMC4wLCAxLjApO1xcbiAgICAgICAgXCIpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ3ZhbHVlJywgMCk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnbmV4dFZhbHVlJywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAndmFsdWUnLCAxKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICduZXh0VmFsdWUnLCAxKTtcbiAgICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEJvZHkoXCJcXG4gICAgICAgICAgICB2ZWMyIHBvc2l0aW9uID0gYUNvcm5lclsyXSAqIHZhbHVlLnh5ICsgYUNvcm5lclszXSAqIG5leHRWYWx1ZS54eTtcXG5cXG4gICAgICAgICAgICB2ZWMyIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSgobmV4dFZhbHVlLnh5IC0gdmFsdWUueHkpICogdVNjcmVlbik7XFxuICAgICAgICAgICAgdmVjMiBub3JtYWwgPSB2ZWMyKGRpcmVjdGlvbi55LCAtZGlyZWN0aW9uLngpO1xcbiAgICAgICAgICAgIHZlYzIgcGFkZGluZyA9ICgodVN0cm9rZVdpZHRoIC8gMi4wKSAvICh1U2NyZWVuIC8gMi4wKSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgcGFkZGluZyAqPSBhRGVmaW5lZCAqIGFEZWZpbmVkTmV4dDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSAoYUNvcm5lclswXSAqIGRpcmVjdGlvbiArIGFDb3JuZXJbMV0gKiBub3JtYWwpICogcGFkZGluZztcXG5cXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMC4wLCAxLjApO1xcblxcbiAgICAgICAgICAgIHZMZW5ndGggPSBsZW5ndGgoKG5leHRWYWx1ZS54eSAtIHZhbHVlLnh5KSAqICh1U2NyZWVuIC8gMi4wKSk7XFxuICAgICAgICAgICAgdlBvc2l0aW9uID0gYUNvcm5lci54eSAqICh1U3Ryb2tlV2lkdGggLyAyLjApO1xcbiAgICAgICAgICAgIHZQb3NpdGlvbi54ICs9IGFDb3JuZXJbM10gKiB2TGVuZ3RoO1xcbiAgICAgICAgXCIpOyAvLyBhbGwgZnJhZ21lbnQgc2hhZGVyIGlucHV0cyBhcmUgcGl4ZWwgZGVub21pbmF0ZWRcblxuICAgICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoXCJcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVTdHJva2VXaWR0aDtcXG4gICAgICAgICAgICB2YXJ5aW5nIGZsb2F0IHZMZW5ndGg7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICBmbG9hdCBjYW5GaWxsID0gMC4wO1xcbiAgICAgICAgICAgIGZsb2F0IGNhblN0cm9rZSA9IDEuMDtcXG4gICAgICAgIFwiKTtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kQm9keShcIlxcbiAgICAgICAgICAgIHZlYzIgcG9zaXRpb24gPSB2UG9zaXRpb247XFxuICAgICAgICAgICAgcG9zaXRpb24ueCAtPSBjbGFtcChwb3NpdGlvbi54LCAwLjAsIHZMZW5ndGgpO1xcbiAgICAgICAgICAgIGZsb2F0IHNkZiA9IGxlbmd0aChwb3NpdGlvbikgLSB1U3Ryb2tlV2lkdGggLyAyLjA7XFxuICAgICAgICAgICAgaWYgKHNkZiA+IDAuNSkge1xcbiAgICAgICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiKTtcbiAgICAgICAgbGluZVdpZHRoKHByb2dyYW0pO1xuICAgICAgICBkZWNvcmF0ZShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbShudW1FbGVtZW50cyAtIDEpO1xuICAgICAgfTtcblxuICAgICAgZHJhdy5kZWNvcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29yYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy54U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB4U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB4U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy55U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB5U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB5U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgcHJvZ3JhbSwgJ2NvbnRleHQnLCAncGl4ZWxSYXRpbycpO1xuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgbGluZVdpZHRoLCAnbGluZVdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NOZXh0VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ3Jvc3NOZXh0VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtYWluVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTWFpblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbWFpbk5leHRWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FNYWluTmV4dFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZE5leHRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZE5leHQnKTtcbiAgICAgIHJldHVybiBkcmF3O1xuICAgIH0pO1xuXG4gICAgdmFyIG9obGNTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKG9obGMuaGVhZGVyKS5hcHBlbmRCb2R5KG9obGMuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIob2hsYyQxLmhlYWRlcikuYXBwZW5kQm9keShvaGxjJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIG9obGMkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1CdWlsZGVyKCkubW9kZShkcmF3TW9kZXMuVFJJQU5HTEVTKS5zdWJJbnN0YW5jZUNvdW50KDE4KTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBsaW5lV2lkdGhTaGFkZXIoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcbiAgICAgIC8qXG4gICAgICAgKiB4LXkgY29vcmRpbmF0ZSB0byBsb2NhdGUgdGhlIFwiY29ybmVyc1wiIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICogWDogLTE6IExFRlQsIDA6IE1JRERMRSwgMTogUklHSFRcbiAgICAgICAqIFk6IC0yOiBISUdILCAtMTogT1BFTiwgMTogQ0xPU0UsIDI6IExPV1xuICAgICAgICogWiAtIEZvbGxvd3MgY29udmVudGlvbiBmb3IgWC9ZIChhcHByb3ByaWF0ZSBkaXJlY3Rpb24gd2lsbCBiZSBzZWxlY3RlZCBieSB0aGUgc2hhZGVyKTogLTE6IExFRlQvVE9QLCAxOiBSSUdIVC9CT1RUT01cbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciBjb3JuZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5kaXZpc29yKDApLnNpemUoMykudHlwZSh0eXBlcy5CWVRFKS5kYXRhKFsvLyBNYWluIHN0ZW1cbiAgICAgIFswLCAtMiwgLTFdLCBbMCwgLTIsIDFdLCBbMCwgMiwgMV0sIFswLCAyLCAtMV0sIC8vIE9wZW4gYmFyXG4gICAgICBbLTEsIC0xLCAtMV0sIFstMSwgLTEsIDFdLCBbMCwgLTEsIDFdLCBbMCwgLTEsIC0xXSwgLy8gQ2xvc2UgYmFyXG4gICAgICBbMSwgMSwgMV0sIFswLCAxLCAxXSwgWzAsIDEsIC0xXSwgWzEsIDEsIC0xXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuZWxlbWVudEluZGljZXMoZWxlbWVudEluZGljZXMoWy8vIE1haW4gc3RlbVxuICAgICAgMCwgMSwgMiwgMCwgMywgMiwgLy8gT3BlbiBiYXJcbiAgICAgIDQsIDUsIDYsIDQsIDcsIDYsIC8vIENsb3NlIGJhclxuICAgICAgOCwgOSwgMTAsIDEwLCAxMSwgOF0pKS5hdHRyaWJ1dGUoJ2FDb3JuZXInLCBjb3JuZXJBdHRyaWJ1dGUpO1xuXG4gICAgICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcobnVtRWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHNoYWRlckJ1aWxkZXIgPSBvaGxjU2hhZGVyKCk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKHNoYWRlckJ1aWxkZXIudmVydGV4KCkpLmZyYWdtZW50U2hhZGVyKHNoYWRlckJ1aWxkZXIuZnJhZ21lbnQoKSk7XG4gICAgICAgIHhTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAwKTtcbiAgICAgICAgeVNjYWxlKHByb2dyYW0sICdnbF9Qb3NpdGlvbicsIDEpO1xuICAgICAgICBsaW5lV2lkdGgocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0udmVydGV4U2hhZGVyKCkuYXBwZW5kQm9keShcIlxcbiAgICAgICAgICBnbF9Qb3NpdGlvbi54ICs9IHhNb2RpZmllciAvIHVTY3JlZW4ueCAqIDIuMDtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24ueSArPSB5TW9kaWZpZXIgLyB1U2NyZWVuLnkgKiAyLjA7XFxuICAgICAgICBcIik7XG4gICAgICAgIGRlY29yYXRlKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtKG51bUVsZW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYXcuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZWNvcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeFNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeVNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIHByb2dyYW0sICdjb250ZXh0JywgJ3BpeGVsUmF0aW8nKTtcbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIGxpbmVXaWR0aCwgJ2xpbmVXaWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2Nyb3NzVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ3Jvc3NWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ29wZW5WYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FPcGVuVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdoaWdoVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhSGlnaFZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnbG93VmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTG93VmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjbG9zZVZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNsb3NlVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdiYW5kd2lkdGhBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQmFuZHdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnZGVmaW5lZEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FEZWZpbmVkJyk7XG4gICAgICByZXR1cm4gZHJhdztcbiAgICB9KTtcblxuICAgIHZhciBiYXJTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKGJhci5oZWFkZXIpLmFwcGVuZEJvZHkoYmFyLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKGJhciQxLmhlYWRlcikuYXBwZW5kQm9keShiYXIkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyAgICAgLi0tLS0tLS0tLS0tLS0uLS0tLS0tLS0tLS0tLlxuICAgIC8vICh4LXcvMiwgeTEpICAgICh4LCB5MSkgICAoeCt3LzIsIHkxKVxuICAgIC8vICAgICB8ICAgICBcXCAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICBcXCAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICBcXCAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICBcXCAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICBcXCAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICAgICBcXCAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICBcXCAgfFxuICAgIC8vICAgICDOsUwgICAgICAgICAgICDOsSAgICAgICAgICAgIM6xUlxuICAgIC8vICAgICAuLS0tLS0tLS0tLS0tLS4tLS0tLS0tLS0tLS0uXG4gICAgLy8gKHgtdy8yLCB5MCkgICAgICh4LCB5MCkgICAoeCt3LzIsIHkwKVxuICAgIC8vIERyYXdpbmcgb3JkZXJcbiAgICAvLyBUcmlhbmdsZSDOskwsIM6xTCwgzrFSLiAoYm90dG9tKVxuICAgIC8vIM6yIC0+IM6yTC5cbiAgICAvLyDOsSAtPiDOsUwuXG4gICAgLy8gzrEgLT4gzrFSLlxuICAgIC8vIFRyaWFuZ2xlIM6yTCwgzrFSLCDOslIuICh0b3ApXG4gICAgLy8gzrIgLT4gzrJMLlxuICAgIC8vIM6xIC0+IM6xUi5cbiAgICAvLyDOsiAtPiDOslIuXG5cbiAgICB2YXIgYmFyJDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2dyYW0gPSBwcm9ncmFtQnVpbGRlcigpLm1vZGUoZHJhd01vZGVzLlRSSUFOR0xFUykuc3ViSW5zdGFuY2VDb3VudCg2KTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcblxuICAgICAgdmFyIGNvcm5lckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZSgpLmRpdmlzb3IoMCkuc2l6ZSgyKS50eXBlKHR5cGVzLkJZVEUpLmRhdGEoW1stMSwgLTFdLCBbMSwgMV0sIFstMSwgMV0sIFsxLCAtMV1dKTtcbiAgICAgIHByb2dyYW0uYnVmZmVycygpLmVsZW1lbnRJbmRpY2VzKGVsZW1lbnRJbmRpY2VzKFswLCAxLCAyLCAwLCAxLCAzXSkpLmF0dHJpYnV0ZSgnYUNvcm5lcicsIGNvcm5lckF0dHJpYnV0ZSk7XG5cbiAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhudW1FbGVtZW50cykge1xuICAgICAgICB2YXIgc2hhZGVyQnVpbGRlciA9IGJhclNoYWRlcigpO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcihzaGFkZXJCdWlsZGVyLnZlcnRleCgpKS5mcmFnbWVudFNoYWRlcihzaGFkZXJCdWlsZGVyLmZyYWdtZW50KCkpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAxKTtcbiAgICAgICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIoKS5hcHBlbmRCb2R5KFwiXFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24ueCArPSB4TW9kaWZpZXIgLyB1U2NyZWVuLnggKiAyLjA7XFxuICAgICAgICBcIik7XG4gICAgICAgIGRlY29yYXRlKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtKG51bUVsZW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIGRyYXcuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZWNvcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeFNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGRyYXcueVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgeVNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZHJhdztcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGRyYXcsIHByb2dyYW0sICdjb250ZXh0JywgJ3BpeGVsUmF0aW8nKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtYWluVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhTWFpblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFzZVZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUJhc2VWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2JhbmR3aWR0aEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FCYW5kd2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdkZWZpbmVkQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYURlZmluZWQnKTtcbiAgICAgIHJldHVybiBkcmF3O1xuICAgIH0pO1xuXG4gICAgdmFyIGVycm9yQmFyU2hhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKHZlcnRleFNoYWRlckJhc2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyQnVpbGRlcihmcmFnbWVudFNoYWRlckJhc2UpO1xuICAgICAgdmVydGV4U2hhZGVyLmFwcGVuZEhlYWRlcihlcnJvckJhci5oZWFkZXIpLmFwcGVuZEJvZHkoZXJyb3JCYXIuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoZXJyb3JCYXIkMS5oZWFkZXIpLmFwcGVuZEJvZHkoZXJyb3JCYXIkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgZXJyb3JCYXIkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1CdWlsZGVyKCkubW9kZShkcmF3TW9kZXMuVFJJQU5HTEVTKS5zdWJJbnN0YW5jZUNvdW50KDE4KTtcbiAgICAgIHZhciB4U2NhbGUgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBiYXNlU2NhbGUoKTtcblxuICAgICAgdmFyIGRlY29yYXRlID0gZnVuY3Rpb24gZGVjb3JhdGUoKSB7fTtcblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVXaWR0aFNoYWRlcigpO1xuICAgICAgLypcbiAgICAgICAqIHgteSBjb29yZGluYXRlIHRvIGxvY2F0ZSB0aGUgXCJjb3JuZXJzXCIgb2YgdGhlIGVsZW1lbnQgKGllIGVycm9yYmFyKS4gVGhlIGB6YCBjb29yZGluYXRlIGxvY2F0ZXMgdGhlIGNvcm5lciByZWxhdGl2ZSB0byB0aGUgbGluZSAodGhpcyB0YWtlcyBsaW5lIHdpZHRoIGludG8gYWNjb3VudCkuXG4gICAgICAgKiBYOiAtMTogTEVGVCwgMDogTUlERExFLCAxOiBSSUdIVFxuICAgICAgICogWTogLTE6IEhJR0gsIDE6IExPV1xuICAgICAgICogWjogRm9sbG93cyBYIG9yIFkgY29udmVudGlvbiwgZGVwZW5kaW5nIG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgbGluZSB0aGF0IHRoZSB2ZXJ0ZXggaXMgcGFydCBvZi5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgY29ybmVyQXR0cmlidXRlID0gYXR0cmlidXRlKCkuZGl2aXNvcigwKS5zaXplKDMpLnR5cGUodHlwZXMuQllURSkuZGF0YShbLy8gTWFpbiBzdGVtXG4gICAgICBbMCwgMSwgMV0sIFswLCAxLCAtMV0sIFswLCAtMSwgLTFdLCBbMCwgLTEsIDFdLCAvLyBUb3AgY2FwXG4gICAgICBbMSwgLTEsIDFdLCBbMSwgLTEsIC0xXSwgWy0xLCAtMSwgLTFdLCBbLTEsIC0xLCAxXSwgLy8gQm90dG9tIGNhcFxuICAgICAgWy0xLCAxLCAtMV0sIFstMSwgMSwgMV0sIFsxLCAxLCAxXSwgWzEsIDEsIC0xXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuZWxlbWVudEluZGljZXMoZWxlbWVudEluZGljZXMoWy8vIE1haW4gc3RlbVxuICAgICAgMCwgMSwgMiwgMCwgMywgMiwgLy8gVG9wIGNhcFxuICAgICAgNCwgNSwgNiwgNCwgNywgNiwgLy8gQm90dG9tIGNhcFxuICAgICAgOCwgOSwgMTAsIDgsIDExLCAxMF0pKS5hdHRyaWJ1dGUoJ2FDb3JuZXInLCBjb3JuZXJBdHRyaWJ1dGUpO1xuXG4gICAgICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcobnVtRWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHNoYWRlckJ1aWxkZXIgPSBlcnJvckJhclNoYWRlcigpO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcihzaGFkZXJCdWlsZGVyLnZlcnRleCgpKS5mcmFnbWVudFNoYWRlcihzaGFkZXJCdWlsZGVyLmZyYWdtZW50KCkpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAxKTtcbiAgICAgICAgbGluZVdpZHRoKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcigpLmFwcGVuZEJvZHkoXCJcXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24ueCArPSB4TW9kaWZpZXIgLyB1U2NyZWVuLnggKiAyLjA7XFxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnkgKz0geU1vZGlmaWVyIC8gdVNjcmVlbi55ICogMi4wO1xcbiAgICAgICAgICAgIFwiKTtcbiAgICAgICAgZGVjb3JhdGUocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0obnVtRWxlbWVudHMpO1xuICAgICAgfTtcblxuICAgICAgZHJhdy5kZWNvcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29yYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy54U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB4U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB4U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy55U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB5U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB5U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgcHJvZ3JhbSwgJ2NvbnRleHQnLCAncGl4ZWxSYXRpbycpO1xuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgbGluZVdpZHRoLCAnbGluZVdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnaGlnaFZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUhpZ2hWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2xvd1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUxvd1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFuZHdpZHRoQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUJhbmR3aWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSk7XG5cbiAgICB2YXIgY2FuZGxlc3RpY2tTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKGNhbmRsZXN0aWNrLmhlYWRlcikuYXBwZW5kQm9keShjYW5kbGVzdGljay5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihjYW5kbGVzdGljayQxLmhlYWRlcikuYXBwZW5kQm9keShjYW5kbGVzdGljayQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBjYW5kbGVzdGljayQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9ncmFtID0gcHJvZ3JhbUJ1aWxkZXIoKS5tb2RlKGRyYXdNb2Rlcy5UUklBTkdMRVMpLnN1Ykluc3RhbmNlQ291bnQoMTIpO1xuICAgICAgdmFyIHhTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IGJhc2VTY2FsZSgpO1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IGxpbmVXaWR0aFNoYWRlcigpO1xuXG4gICAgICB2YXIgZGVjb3JhdGUgPSBmdW5jdGlvbiBkZWNvcmF0ZSgpIHt9O1xuICAgICAgLypcbiAgICAgICAqIHgteSBjb29yZGluYXRlIHRvIGxvY2F0ZSB0aGUgXCJjb3JuZXJzXCIgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgKiBYOiAtMTogTEVGVCwgMDogTUlERExFLCAxOiBSSUdIVFxuICAgICAgICogWTogLTI6IEhJR0gsIC0xOiBPUEVOLCAxOiBDTE9TRSwgMjogTE9XXG4gICAgICAgKiBaOiAtMTogTEVGVCwgMTogUklHSFQgKG9ubHkgdmFsaWQgZm9yIEhJR0gvTE9XIGNvcm5lcnMpXG4gICAgICAgKi9cblxuXG4gICAgICB2YXIgY29ybmVyQXR0cmlidXRlID0gYXR0cmlidXRlKCkuZGl2aXNvcigwKS5zaXplKDMpLnR5cGUodHlwZXMuQllURSkuZGF0YShbLy8gVmVydGljYWwgbGluZVxuICAgICAgWzAsIDIsIDFdLCBbMCwgMiwgLTFdLCBbMCwgLTIsIC0xXSwgWzAsIC0yLCAxXSwgLy8gQ2VudHJhbCBib3hcbiAgICAgIFsxLCAtMSwgMF0sIFstMSwgLTEsIDBdLCBbLTEsIDEsIDBdLCBbMSwgMSwgMF1dKTtcbiAgICAgIHByb2dyYW0uYnVmZmVycygpLmVsZW1lbnRJbmRpY2VzKGVsZW1lbnRJbmRpY2VzKFsvLyBWZXJ0aWNhbCBsaW5lXG4gICAgICAwLCAxLCAyLCAwLCAzLCAyLCAvLyBDZW50cmFsIGJveFxuICAgICAgNCwgNSwgNiwgNCwgNywgNl0pKS5hdHRyaWJ1dGUoJ2FDb3JuZXInLCBjb3JuZXJBdHRyaWJ1dGUpO1xuXG4gICAgICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcobnVtRWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHNoYWRlckJ1aWxkZXIgPSBjYW5kbGVzdGlja1NoYWRlcigpO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcihzaGFkZXJCdWlsZGVyLnZlcnRleCgpKS5mcmFnbWVudFNoYWRlcihzaGFkZXJCdWlsZGVyLmZyYWdtZW50KCkpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAxKTtcbiAgICAgICAgbGluZVdpZHRoKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcigpLmFwcGVuZEJvZHkoXCJcXG4gICAgICAgICAgZ2xfUG9zaXRpb24ueCArPSB4TW9kaWZpZXIgLyB1U2NyZWVuLnggKiAyLjA7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uLnkgKz0geU1vZGlmaWVyIC8gdVNjcmVlbi55ICogMi4wO1xcbiAgICAgICAgXCIpO1xuICAgICAgICBkZWNvcmF0ZShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbShudW1FbGVtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LmRlY29yYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb3JhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkcmF3LnlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHlTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBwcm9ncmFtLCAnY29udGV4dCcsICdwaXhlbFJhdGlvJyk7XG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChkcmF3LCBsaW5lV2lkdGgsICdsaW5lV2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjcm9zc1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUNyb3NzVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdvcGVuVmFsdWVBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhT3BlblZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnaGlnaFZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUhpZ2hWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2xvd1ZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUxvd1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY2xvc2VWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDbG9zZVZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnYmFuZHdpZHRoQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUJhbmR3aWR0aCcpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2RlZmluZWRBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhRGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIGRyYXc7XG4gICAgfSk7XG5cbiAgICB2YXIgYm94UGxvdFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoYm94UGxvdC5oZWFkZXIpLmFwcGVuZEJvZHkoYm94UGxvdC5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihib3hQbG90JDEuaGVhZGVyKS5hcHBlbmRCb2R5KGJveFBsb3QkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyAgICAgICAgICAgIC4tLS0tLS0uLS0tLS0tLlxuICAgIC8vICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgIM6yTDIgICAgICAgICAgICDOsiAgICAgICAgICAgzrJSMlxuICAgIC8vICAgICAuLS0tLS0tLS0tLS0tLS4tLS0tLS0tLS0tLS0uXG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgIM6zTDIgICAgICAgICAgICDOsyAgICAgICAgICAgzrNSMlxuICAgIC8vICAgICAuLS0tLS0tLS0tLS0tLS4tLS0tLS0tLS0tLS0uXG4gICAgLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgzrRMMiAgICAgICAgICAgIM60ICAgICAgICAgICDOtFIyXG4gICAgLy8gICAgIC4tLS0tLS0tLS0tLS0tLi0tLS0tLS0tLS0tLS5cbiAgICAvLyAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgICAgICAgICAgzrVMMSAgICAgzrUgICAgIM61UjFcbiAgICAvLyAgICAgICAgICAgIC4tLS0tLS0uLS0tLS0tLlxuICAgIC8vIExpbmUgZHJhd2luZyBvcmRlclxuICAgIC8vIM6xTDEgLT4gzrFSMVxuICAgIC8vIM6xIC0+IM6yXG4gICAgLy8gzrJMMiAtPiDOslIyXG4gICAgLy8gzrNMMiAtPiDOs1IyXG4gICAgLy8gzrRMMiAtPiDOtFIyXG4gICAgLy8gzrJMMiAtPiDOtEwyXG4gICAgLy8gzrJSMiAtPiDOtFIyXG4gICAgLy8gzrQgLT4gzrVcbiAgICAvLyDOtUwxIC0+IM61UjFcblxuICAgIHZhciBib3hQbG90JDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByb2dyYW0gPSBwcm9ncmFtQnVpbGRlcigpLm1vZGUoZHJhd01vZGVzLlRSSUFOR0xFUykuc3ViSW5zdGFuY2VDb3VudCg1NCk7XG4gICAgICB2YXIgeFNjYWxlID0gYmFzZVNjYWxlKCk7XG4gICAgICB2YXIgeVNjYWxlID0gYmFzZVNjYWxlKCk7XG5cbiAgICAgIHZhciBkZWNvcmF0ZSA9IGZ1bmN0aW9uIGRlY29yYXRlKCkge307XG5cbiAgICAgIHZhciBsaW5lV2lkdGggPSBsaW5lV2lkdGhTaGFkZXIoKTtcbiAgICAgIC8qXG4gICAgICAgKiB4LXkgY29vcmRpbmF0ZSB0byBsb2NhdGUgdGhlIFwiY29ybmVyc1wiIG9mIHRoZSBlbGVtZW50IChpZSBlcnJvcmJhcikuIFRoZSBgemAgY29vcmRpbmF0ZSBsb2NhdGVzIHRoZSBjb3JuZXIgcmVsYXRpdmUgdG8gdGhlIGxpbmUgKHRoaXMgdGFrZXMgbGluZSB3aWR0aCBpbnRvIGFjY291bnQpLlxuICAgICAgICogWDogLTE6IExFRlQsIDA6IE1JRERMRSwgMTogUklHSFRcbiAgICAgICAqIFk6IC0yOiBISUdILCAtMTogVVBQRVIgUVVBUlRJTEUsIDA6IE1FRElBTiwgMTogTE9XRVIgUVVBUlRJTEUsIDI6IExPV1xuICAgICAgICogWjogRm9sbG93cyBYIG9yIFkgY29udmVudGlvbiwgZGVwZW5kaW5nIG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgbGluZSB0aGF0IHRoZSB2ZXJ0ZXggaXMgcGFydCBvZi5cbiAgICAgICAqIFc6IEluZGljYXRvciB0byBkZXRlcm1pbmUgbGluZSBvcmllbnRhdGlvbiAobmVlZGVkIGJlY2F1c2Ugc29tZSBjb3JuZXJzIGFyZSBwYXJ0IG9mIHR3byBsaW5lcykuIC0gMDogVkVSVElDQUwsIDE6IEhPUklaT05UQUxcbiAgICAgICAqL1xuXG4gICAgICB2YXIgY29ybmVyQXR0cmlidXRlID0gYXR0cmlidXRlKCkuZGl2aXNvcigwKS5zaXplKDQpLnR5cGUodHlwZXMuQllURSkuZGF0YShbLy8gVG9wIGNhcCBsaW5lXG4gICAgICBbLTEsIC0yLCAtMSwgMV0sIFsxLCAtMiwgLTEsIDFdLCBbMSwgLTIsIDEsIDFdLCBbLTEsIC0yLCAxLCAxXSwgLy8gVG9wIHdoaXNrZXIgbGluZVxuICAgICAgWzAsIC0yLCAtMSwgMF0sIFswLCAtMiwgMSwgMF0sIFswLCAtMSwgMSwgMF0sIFswLCAtMSwgLTEsIDBdLCAvLyBVcHBlciBxdWFydGlsZSBsaW5lXG4gICAgICBbLTEsIC0xLCAtMSwgMV0sIFsxLCAtMSwgLTEsIDFdLCBbMSwgLTEsIDEsIDFdLCBbLTEsIC0xLCAxLCAxXSwgLy8gTWVkaWFuIGxpbmVcbiAgICAgIFstMSwgMCwgLTEsIDFdLCBbMSwgMCwgLTEsIDFdLCBbMSwgMCwgMSwgMV0sIFstMSwgMCwgMSwgMV0sIC8vIExvd2VyIHF1YXJ0aWxlIGxpbmVcbiAgICAgIFstMSwgMSwgLTEsIDFdLCBbMSwgMSwgLTEsIDFdLCBbMSwgMSwgMSwgMV0sIFstMSwgMSwgMSwgMV0sIC8vIExlZnQgYm94IHZlcnRpY2FsIGxpbmVcbiAgICAgIFstMSwgLTEsIC0xLCAwXSwgWy0xLCAtMSwgMSwgMF0sIFstMSwgMSwgMSwgMF0sIFstMSwgMSwgLTEsIDBdLCAvLyBSaWdodCBib3ggdmVydGljYWwgbGluZVxuICAgICAgWzEsIC0xLCAtMSwgMF0sIFsxLCAtMSwgMSwgMF0sIFsxLCAxLCAxLCAwXSwgWzEsIDEsIC0xLCAwXSwgLy8gQm90dG9tIHdoaXNrZXIgbGluZVxuICAgICAgWzAsIDIsIC0xLCAwXSwgWzAsIDIsIDEsIDBdLCBbMCwgMSwgMSwgMF0sIFswLCAxLCAtMSwgMF0sIC8vIEJvdHRvbSBjYXAgbGluZVxuICAgICAgWy0xLCAyLCAtMSwgMV0sIFsxLCAyLCAtMSwgMV0sIFsxLCAyLCAxLCAxXSwgWy0xLCAyLCAxLCAxXV0pO1xuICAgICAgcHJvZ3JhbS5idWZmZXJzKCkuZWxlbWVudEluZGljZXMoZWxlbWVudEluZGljZXMoWy8vIFRvcCBjYXAgbGluZVxuICAgICAgMCwgMSwgMiwgMCwgMiwgMywgLy8gVG9wIHdoaXNrZXIgbGluZVxuICAgICAgNCwgNSwgNiwgNCwgNiwgNywgLy8gVXBwZXIgcXVhcnRpbGUgbGluZVxuICAgICAgOCwgOSwgMTAsIDgsIDEwLCAxMSwgLy8gTWVkaWFuIGxpbmVcbiAgICAgIDEyLCAxMywgMTQsIDEyLCAxNCwgMTUsIC8vIExvd2VyIHF1YXJ0aWxlIGxpbmVcbiAgICAgIDE2LCAxNywgMTgsIDE2LCAxOCwgMTksIC8vIExlZnQgYm94IHZlcnRpY2FsIGxpbmVcbiAgICAgIDIwLCAyMSwgMjIsIDIwLCAyMiwgMjMsIC8vIFJpZ2h0IGJveCB2ZXJ0aWNhbCBsaW5lXG4gICAgICAyNCwgMjUsIDI2LCAyNCwgMjYsIDI3LCAvLyBCb3R0b20gd2hpc2tlciBsaW5lXG4gICAgICAyOCwgMjksIDMwLCAyOCwgMzAsIDMxLCAvLyBCb3R0b20gY2FwIGxpbmVcbiAgICAgIDMyLCAzMywgMzQsIDMyLCAzNCwgMzVdKSkuYXR0cmlidXRlKCdhQ29ybmVyJywgY29ybmVyQXR0cmlidXRlKTtcblxuICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbiBkcmF3KG51bUVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBzaGFkZXJCdWlsZGVyID0gYm94UGxvdFNoYWRlcigpO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcihzaGFkZXJCdWlsZGVyLnZlcnRleCgpKS5mcmFnbWVudFNoYWRlcihzaGFkZXJCdWlsZGVyLmZyYWdtZW50KCkpO1xuICAgICAgICB4U2NhbGUocHJvZ3JhbSwgJ2dsX1Bvc2l0aW9uJywgMCk7XG4gICAgICAgIHlTY2FsZShwcm9ncmFtLCAnZ2xfUG9zaXRpb24nLCAxKTtcbiAgICAgICAgbGluZVdpZHRoKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtLnZlcnRleFNoYWRlcigpLmFwcGVuZEJvZHkoXCJcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbi54ICs9IHhNb2RpZmllciAvIHVTY3JlZW4ueCAqIDIuMDtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbi55ICs9IHlNb2RpZmllciAvIHVTY3JlZW4ueSAqIDIuMDtcXG4gICAgICAgIFwiKTtcbiAgICAgICAgZGVjb3JhdGUocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0obnVtRWxlbWVudHMpO1xuICAgICAgfTtcblxuICAgICAgZHJhdy5kZWNvcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29yYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy54U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB4U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB4U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZHJhdy55U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB5U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB5U2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBkcmF3O1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgcHJvZ3JhbSwgJ2NvbnRleHQnLCAncGl4ZWxSYXRpbycpO1xuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZHJhdywgbGluZVdpZHRoLCAnbGluZVdpZHRoJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnY3Jvc3NWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FDcm9zc1ZhbHVlJyk7XG4gICAgICByZWJpbmRDdXJyeShkcmF3LCAnaGlnaFZhbHVlQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYUhpZ2hWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ3VwcGVyUXVhcnRpbGVWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FVcHBlclF1YXJ0aWxlVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdtZWRpYW5WYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FNZWRpYW5WYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2xvd2VyUXVhcnRpbGVWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FMb3dlclF1YXJ0aWxlVmFsdWUnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdsb3dWYWx1ZUF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FMb3dWYWx1ZScpO1xuICAgICAgcmViaW5kQ3VycnkoZHJhdywgJ2JhbmR3aWR0aEF0dHJpYnV0ZScsIHByb2dyYW0uYnVmZmVycygpLCAnYXR0cmlidXRlJywgJ2FCYW5kd2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdjYXBBdHRyaWJ1dGUnLCBwcm9ncmFtLmJ1ZmZlcnMoKSwgJ2F0dHJpYnV0ZScsICdhQ2FwV2lkdGgnKTtcbiAgICAgIHJlYmluZEN1cnJ5KGRyYXcsICdkZWZpbmVkQXR0cmlidXRlJywgcHJvZ3JhbS5idWZmZXJzKCksICdhdHRyaWJ1dGUnLCAnYURlZmluZWQnKTtcbiAgICAgIHJldHVybiBkcmF3O1xuICAgIH0pO1xuXG4gICAgdmFyIGFkamFjZW50QXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtaW5PZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbWF4T2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICBpZiAobWluT2Zmc2V0ID4gMCB8fCBtYXhPZmZzZXQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZnNldCB2YWx1ZXMgKFwiLmNvbmNhdChtaW5PZmZzZXQsIFwiICYgXCIpLmNvbmNhdChtYXhPZmZzZXQsIFwiKSBtdXN0IHN0cmFkZGxlIDAgXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhc2UgPSBiYXNlQXR0cmlidXRlQnVpbGRlcigpO1xuICAgICAgdmFyIHByb2plY3RvciA9IGF0dHJpYnV0ZVByb2plY3RvcigpO1xuXG4gICAgICB2YXIgYWRqYWNlbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBhZGphY2VudEF0dHJpYnV0ZShwcm9ncmFtQnVpbGRlcikge1xuICAgICAgICB2YXIgZWxlbWVudFNpemUgPSBhZGphY2VudEF0dHJpYnV0ZS5zaXplKCkgKiBsZW5ndGgoYWRqYWNlbnRBdHRyaWJ1dGUudHlwZSgpKTtcbiAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IE1hdGguYWJzKG1pbk9mZnNldCkgKiBlbGVtZW50U2l6ZTtcbiAgICAgICAgYmFzZS5vZmZzZXQoYnVmZmVyT2Zmc2V0KS5zaXplKGFkamFjZW50QXR0cmlidXRlLnNpemUoKSkudHlwZShhZGphY2VudEF0dHJpYnV0ZS50eXBlKCkpO1xuICAgICAgICBiYXNlKHByb2dyYW1CdWlsZGVyKTtcblxuICAgICAgICBpZiAoIXByb2plY3Rvci5kaXJ0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb2plY3RlZERhdGEgPSBwcm9qZWN0b3IoKTtcbiAgICAgICAgdmFyIGJ1ZmZlclBhZGRpbmcgPSBtYXhPZmZzZXQgKiBlbGVtZW50U2l6ZTtcbiAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlck9mZnNldCArIHByb2plY3RlZERhdGEubGVuZ3RoICogbGVuZ3RoKGFkamFjZW50QXR0cmlidXRlLnR5cGUoKSkgKyBidWZmZXJQYWRkaW5nO1xuICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtQnVpbGRlci5jb250ZXh0KCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBiYXNlLmJ1ZmZlcigpKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckxlbmd0aCwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlck9mZnNldCwgcHJvamVjdGVkRGF0YSk7XG4gICAgICB9O1xuXG4gICAgICBhZGphY2VudEF0dHJpYnV0ZS5vZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIGlmIChtaW5PZmZzZXQgPiBvZmZzZXQgfHwgb2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIG9mZnNldCBcIi5jb25jYXQob2Zmc2V0LCBcIiBleGNlZWRzIGJvdW5kcyAoXCIpLmNvbmNhdChtaW5PZmZzZXQsIFwiICYgXCIpLmNvbmNhdChtYXhPZmZzZXQsIFwiKSBcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIG9mZnNldEF0dHJpYnV0ZShwcm9ncmFtQnVpbGRlcikge1xuICAgICAgICAgIGJhc2Uub2Zmc2V0KChvZmZzZXQgLSBtaW5PZmZzZXQpICogYWRqYWNlbnRBdHRyaWJ1dGUuc2l6ZSgpICogbGVuZ3RoKGFkamFjZW50QXR0cmlidXRlLnR5cGUoKSkpO1xuICAgICAgICAgIGJhc2UocHJvZ3JhbUJ1aWxkZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGQzZmNSZWJpbmQucmViaW5kKG9mZnNldEF0dHJpYnV0ZSwgYWRqYWNlbnRBdHRyaWJ1dGUsICdjbGVhcicsICdsb2NhdGlvbicpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0QXR0cmlidXRlO1xuICAgICAgfTtcblxuICAgICAgYWRqYWNlbnRBdHRyaWJ1dGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJhc2UuYnVmZmVyKG51bGwpO1xuICAgICAgICBwcm9qZWN0b3IuY2xlYXIoKTtcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKGFkamFjZW50QXR0cmlidXRlLCBiYXNlLCAnbm9ybWFsaXplZCcsICdsb2NhdGlvbicsICdkaXZpc29yJyk7XG4gICAgICBkM2ZjUmViaW5kLnJlYmluZChhZGphY2VudEF0dHJpYnV0ZSwgcHJvamVjdG9yLCAnZGF0YScsICd2YWx1ZScsICdzaXplJywgJ3R5cGUnKTtcbiAgICAgIHJldHVybiBhZGphY2VudEF0dHJpYnV0ZTtcbiAgICB9KTtcblxuICAgIHZhciBsaW5lYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJhc2UgPSBiYXNlU2NhbGUoKTtcblxuICAgICAgdmFyIHByZWZpeCA9IGZ1bmN0aW9uIHByZWZpeChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIFwibGluZWFyXCIuY29uY2F0KGNvbXBvbmVudCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShwcm9ncmFtQnVpbGRlciwgaWRlbnRpZmllciwgY29tcG9uZW50KSB7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLnZlcnRleFNoYWRlcigpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJPZmZzZXQ7XCIpKS5hcHBlbmRIZWFkZXJJZk5vdEV4aXN0cyhcInVuaWZvcm0gdmVjNCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGU7XCIpKS5hcHBlbmRCb2R5KFwiXCIuY29uY2F0KGlkZW50aWZpZXIsIFwiID0gXCIpLmNvbmNhdChpZGVudGlmaWVyLCBcIiArIFwiKS5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiT2Zmc2V0O1wiKSkuYXBwZW5kQm9keShcIlwiLmNvbmNhdChpZGVudGlmaWVyLCBcIiA9IFwiKS5jb25jYXQoaWRlbnRpZmllciwgXCIgKiBcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIlNjYWxlO1wiKSk7XG4gICAgICAgIHZhciBkb21haW5TaXplID0gYmFzZS5kb21haW4oKVsxXSAtIGJhc2UuZG9tYWluKClbMF07XG4gICAgICAgIHZhciByYW5nZVNpemUgPSBiYXNlLnJhbmdlKClbMV0gLSBiYXNlLnJhbmdlKClbMF07XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSBiYXNlLnJhbmdlKClbMF0gKiAoZG9tYWluU2l6ZSAvIHJhbmdlU2l6ZSkgLSBiYXNlLmRvbWFpbigpWzBdO1xuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSByYW5nZVNpemUgLyBkb21haW5TaXplO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB2YXIgc2NhbGUgPSBbMSwgMSwgMSwgMV07XG4gICAgICAgIG9mZnNldFtjb21wb25lbnRdID0gdHJhbnNsYXRlO1xuICAgICAgICBzY2FsZVtjb21wb25lbnRdID0gc2NhbGVGYWN0b3I7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLmJ1ZmZlcnMoKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIk9mZnNldFwiKSwgdW5pZm9ybShvZmZzZXQpKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIlNjYWxlXCIpLCB1bmlmb3JtKHNjYWxlKSk7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZEFsbChzY2FsZSwgYmFzZSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSk7XG5cbiAgICB2YXIgbG9nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBnbEJhc2UgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciBiYXNlID0gMTA7XG5cbiAgICAgIGZ1bmN0aW9uIGxvZyh2LCBiYXNlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzEwKHYpIC8gTWF0aC5sb2cxMChiYXNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZWZpeCA9IGZ1bmN0aW9uIHByZWZpeChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIFwibG9nXCIuY29uY2F0KGNvbXBvbmVudCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShwcm9ncmFtQnVpbGRlciwgaWRlbnRpZmllciwgY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBsb2dQYXJ0ID0gXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiT2Zmc2V0ICsgKFwiKS5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGUgKiBjbGFtcChsb2coXCIpLmNvbmNhdChpZGVudGlmaWVyLCBcIikgLyBsb2coXCIpLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJCYXNlKSwgLWluZiwgaW5mKSlcIik7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLnZlcnRleFNoYWRlcigpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJPZmZzZXQ7XCIpKS5hcHBlbmRIZWFkZXJJZk5vdEV4aXN0cyhcInVuaWZvcm0gdmVjNCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGU7XCIpKS5hcHBlbmRIZWFkZXJJZk5vdEV4aXN0cyhcInVuaWZvcm0gdmVjNCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiSW5jbHVkZTtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSBmbG9hdCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiQmFzZTtcIikpLmFwcGVuZEJvZHkoXCJcIi5jb25jYXQoaWRlbnRpZmllciwgXCIgPSAoXCIpLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJJbmNsdWRlICogKFwiKS5jb25jYXQobG9nUGFydCwgXCIpKSArICgoMS4wIC0gXCIpLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJJbmNsdWRlKSAqIFwiKS5jb25jYXQoaWRlbnRpZmllciwgXCIpO1wiKSk7XG4gICAgICAgIHZhciBkb21haW5TaXplID0gbG9nKGdsQmFzZS5kb21haW4oKVsxXSwgYmFzZSkgLSBsb2coZ2xCYXNlLmRvbWFpbigpWzBdLCBiYXNlKTtcbiAgICAgICAgdmFyIHJhbmdlU2l6ZSA9IGdsQmFzZS5yYW5nZSgpWzFdIC0gZ2xCYXNlLnJhbmdlKClbMF07XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHJhbmdlU2l6ZSAvIGRvbWFpblNpemU7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSBnbEJhc2UucmFuZ2UoKVswXSAtIHNjYWxlRmFjdG9yICogbG9nKGdsQmFzZS5kb21haW4oKVswXSwgYmFzZSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIHZhciBzY2FsZSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIG9mZnNldFtjb21wb25lbnRdID0gdHJhbnNsYXRlO1xuICAgICAgICBzY2FsZVtjb21wb25lbnRdID0gc2NhbGVGYWN0b3I7XG4gICAgICAgIGluY2x1ZGVbY29tcG9uZW50XSA9IDE7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLmJ1ZmZlcnMoKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIk9mZnNldFwiKSwgdW5pZm9ybShvZmZzZXQpKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIlNjYWxlXCIpLCB1bmlmb3JtKHNjYWxlKSkudW5pZm9ybShcIlwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJJbmNsdWRlXCIpLCB1bmlmb3JtKGluY2x1ZGUpKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkJhc2VcIiksIHVuaWZvcm0oYmFzZSkpO1xuICAgICAgfTtcblxuICAgICAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgICB9O1xuXG4gICAgICBkM2ZjUmViaW5kLnJlYmluZEFsbChzY2FsZSwgZ2xCYXNlKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9KTtcblxuICAgIHZhciBwb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJhc2UgPSBiYXNlU2NhbGUoKTtcbiAgICAgIHZhciBleHBvbmVudCA9IDE7XG5cbiAgICAgIGZ1bmN0aW9uIHBvdyhiLCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oYikgKiBNYXRoLnBvdyhNYXRoLmFicyhiKSwgZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVmaXggPSBmdW5jdGlvbiBwcmVmaXgoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBcInBvd1wiLmNvbmNhdChjb21wb25lbnQpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNjYWxlID0gZnVuY3Rpb24gc2NhbGUocHJvZ3JhbUJ1aWxkZXIsIGlkZW50aWZpZXIsIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgcG93UGFydCA9IFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIk9mZnNldCArIChcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIlNjYWxlICogc2lnbihcIikuY29uY2F0KGlkZW50aWZpZXIsIFwiKSAqIHBvdyhhYnMoXCIpLmNvbmNhdChpZGVudGlmaWVyLCBcIiksIHZlYzQoXCIpLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJFeHApKSlcIik7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLnZlcnRleFNoYWRlcigpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSB2ZWM0IFwiLmNvbmNhdChwcmVmaXgoY29tcG9uZW50KSwgXCJPZmZzZXQ7XCIpKS5hcHBlbmRIZWFkZXJJZk5vdEV4aXN0cyhcInVuaWZvcm0gdmVjNCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGU7XCIpKS5hcHBlbmRIZWFkZXJJZk5vdEV4aXN0cyhcInVuaWZvcm0gdmVjNCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiSW5jbHVkZTtcIikpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKFwidW5pZm9ybSBmbG9hdCBcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiRXhwO1wiKSkuYXBwZW5kQm9keShcIlwiLmNvbmNhdChpZGVudGlmaWVyLCBcIiA9IChcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkluY2x1ZGUgKiAoXCIpLmNvbmNhdChwb3dQYXJ0LCBcIikpICsgKCgxLjAgLSBcIikuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkluY2x1ZGUpICogXCIpLmNvbmNhdChpZGVudGlmaWVyLCBcIik7XCIpKTtcbiAgICAgICAgdmFyIGRvbWFpblNpemUgPSBwb3coYmFzZS5kb21haW4oKVsxXSwgZXhwb25lbnQpIC0gcG93KGJhc2UuZG9tYWluKClbMF0sIGV4cG9uZW50KTtcbiAgICAgICAgdmFyIHJhbmdlU2l6ZSA9IGJhc2UucmFuZ2UoKVsxXSAtIGJhc2UucmFuZ2UoKVswXTtcbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gcmFuZ2VTaXplIC8gZG9tYWluU2l6ZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGJhc2UucmFuZ2UoKVswXSAtIHNjYWxlRmFjdG9yICogcG93KGJhc2UuZG9tYWluKClbMF0sIGV4cG9uZW50KTtcbiAgICAgICAgdmFyIG9mZnNldCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdmFyIHNjYWxlID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgb2Zmc2V0W2NvbXBvbmVudF0gPSB0cmFuc2xhdGU7XG4gICAgICAgIHNjYWxlW2NvbXBvbmVudF0gPSBzY2FsZUZhY3RvcjtcbiAgICAgICAgaW5jbHVkZVtjb21wb25lbnRdID0gMTtcbiAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuYnVmZmVycygpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiT2Zmc2V0XCIpLCB1bmlmb3JtKG9mZnNldCkpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiU2NhbGVcIiksIHVuaWZvcm0oc2NhbGUpKS51bmlmb3JtKFwiXCIuY29uY2F0KHByZWZpeChjb21wb25lbnQpLCBcIkluY2x1ZGVcIiksIHVuaWZvcm0oaW5jbHVkZSkpLnVuaWZvcm0oXCJcIi5jb25jYXQocHJlZml4KGNvbXBvbmVudCksIFwiRXhwXCIpLCB1bmlmb3JtKGV4cG9uZW50KSk7XG4gICAgICB9O1xuXG4gICAgICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9uZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwb25lbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kQWxsKHNjYWxlLCBiYXNlKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9KTtcblxuICAgIC8vIGRldGVybWluZSB0aGUgc2NhbGUgdHlwZS5cblxuICAgIHZhciBzY2FsZUxpbmVhckNvcHkgPSBkM1NjYWxlLnNjYWxlTGluZWFyKCkuY29weS50b1N0cmluZygpO1xuICAgIHZhciBzY2FsZUxvZ0NvcHkgPSBkM1NjYWxlLnNjYWxlTG9nKCkuY29weS50b1N0cmluZygpO1xuICAgIHZhciBzY2FsZVBvd0NvcHkgPSBkM1NjYWxlLnNjYWxlUG93KCkuY29weS50b1N0cmluZygpO1xuICAgIHZhciBzY2FsZVRpbWVDb3B5ID0gZDNTY2FsZS5zY2FsZVRpbWUoKS5jb3B5LnRvU3RyaW5nKCk7IC8vIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgcmVmZXJlbmNlIHRvIGhpbnQgdG8gY29uc3VtZXJzIHRoYXRcbiAgICAvLyBpdCBpcyBhIHB1cmUgZnVuY3Rpb25cblxuICAgIHZhciBpZGVudGl0eSA9IGQzU2NhbGUuc2NhbGVJZGVudGl0eSgpOyAvLyBvZmZzZXQgZGF0ZSB2YWx1ZXMgdG8gbWFrZSB0aGUgbW9zdCBvZiB0aGUgZmxvYXQzMiBwcmVjaXNpb25cblxuICAgIHZhciBlcG9jaCA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgcmVlcG9jaCA9IGZ1bmN0aW9uIHJlZXBvY2goZCkge1xuICAgICAgcmV0dXJuIGQgLSBlcG9jaDtcbiAgICB9O1xuXG4gICAgdmFyIHNjYWxlTWFwcGVyID0gKGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgc3dpdGNoIChzY2FsZS5jb3B5LnRvU3RyaW5nKCkpIHtcbiAgICAgICAgY2FzZSBzY2FsZUxpbmVhckNvcHk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2NhbGU6IGlkZW50aXR5LFxuICAgICAgICAgICAgICB3ZWJnbFNjYWxlOiBsaW5lYXIoKS5kb21haW4oc2NhbGUuZG9tYWluKCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIHNjYWxlVGltZUNvcHk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2NhbGU6IHJlZXBvY2gsXG4gICAgICAgICAgICAgIHdlYmdsU2NhbGU6IGxpbmVhcigpLmRvbWFpbihzY2FsZS5kb21haW4oKS5tYXAocmVlcG9jaCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIHNjYWxlTG9nQ29weTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzY2FsZTogaWRlbnRpdHksXG4gICAgICAgICAgICAgIHdlYmdsU2NhbGU6IGxvZygpLmRvbWFpbihzY2FsZS5kb21haW4oKSkuYmFzZShzY2FsZS5iYXNlKCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIHNjYWxlUG93Q29weTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzY2FsZTogaWRlbnRpdHksXG4gICAgICAgICAgICAgIHdlYmdsU2NhbGU6IHBvdygpLmRvbWFpbihzY2FsZS5kb21haW4oKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHJldHVybiBhIGNvcHkgb2YgdGhlIHNjYWxlIHRvIGhpbnQgdG8gY29uc3VtZXJzXG4gICAgICAgICAgICAvLyB0aGF0IGl0IG1heSBiZSBhbiBpbXB1cmUgZnVuY3Rpb25cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjYWxlOiBzY2FsZS5jb3B5KCksXG4gICAgICAgICAgICAgIHdlYmdsU2NhbGU6IGxpbmVhcigpLmRvbWFpbihzY2FsZS5yYW5nZSgpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgc3F1YXJlUG9pbnRTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKHNxdWFyZS5oZWFkZXIpLmFwcGVuZEJvZHkoc3F1YXJlLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKHNxdWFyZSQxLmhlYWRlcikuYXBwZW5kQm9keShzcXVhcmUkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgdHJpYW5nbGVQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIodHJpYW5nbGUuaGVhZGVyKS5hcHBlbmRCb2R5KHRyaWFuZ2xlLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKHRyaWFuZ2xlJDEuaGVhZGVyKS5hcHBlbmRCb2R5KHRyaWFuZ2xlJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIGNyb3NzUG9pbnRTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKGNyb3NzLmhlYWRlcikuYXBwZW5kQm9keShjcm9zcy5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihjcm9zcyQxLmhlYWRlcikuYXBwZW5kQm9keShjcm9zcyQxLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdW5jdGlvbiB2ZXJ0ZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KCkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBkaWFtb25kUG9pbnRTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKGRpYW1vbmQuaGVhZGVyKS5hcHBlbmRCb2R5KGRpYW1vbmQuYm9keSk7XG4gICAgICBmcmFnbWVudFNoYWRlci5hcHBlbmRIZWFkZXIoZGlhbW9uZCQxLmhlYWRlcikuYXBwZW5kQm9keShkaWFtb25kJDEuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIHZlcnRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDogZnVuY3Rpb24gZnJhZ21lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIHN0YXJQb2ludFNoYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyQnVpbGRlcih2ZXJ0ZXhTaGFkZXJCYXNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlckJ1aWxkZXIoZnJhZ21lbnRTaGFkZXJCYXNlKTtcbiAgICAgIHZlcnRleFNoYWRlci5hcHBlbmRIZWFkZXIoc3Rhci5oZWFkZXIpLmFwcGVuZEJvZHkoc3Rhci5ib2R5KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyLmFwcGVuZEhlYWRlcihzdGFyJDEuaGVhZGVyKS5hcHBlbmRCb2R5KHN0YXIkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgd3llUG9pbnRTaGFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlckJ1aWxkZXIodmVydGV4U2hhZGVyQmFzZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJCdWlsZGVyKGZyYWdtZW50U2hhZGVyQmFzZSk7XG4gICAgICB2ZXJ0ZXhTaGFkZXIuYXBwZW5kSGVhZGVyKHd5ZS5oZWFkZXIpLmFwcGVuZEJvZHkod3llLmJvZHkpO1xuICAgICAgZnJhZ21lbnRTaGFkZXIuYXBwZW5kSGVhZGVyKHd5ZSQxLmhlYWRlcikuYXBwZW5kQm9keSh3eWUkMS5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRleDogZnVuY3Rpb24gdmVydGV4KCkge1xuICAgICAgICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgc3ltYm9sTWFwcGVyID0gKGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgIGNhc2UgZDNTaGFwZS5zeW1ib2xDaXJjbGU6XG4gICAgICAgICAgcmV0dXJuIGNpcmNsZVBvaW50U2hhZGVyKCk7XG5cbiAgICAgICAgY2FzZSBkM1NoYXBlLnN5bWJvbFNxdWFyZTpcbiAgICAgICAgICByZXR1cm4gc3F1YXJlUG9pbnRTaGFkZXIoKTtcblxuICAgICAgICBjYXNlIGQzU2hhcGUuc3ltYm9sVHJpYW5nbGU6XG4gICAgICAgICAgcmV0dXJuIHRyaWFuZ2xlUG9pbnRTaGFkZXIoKTtcblxuICAgICAgICBjYXNlIGQzU2hhcGUuc3ltYm9sQ3Jvc3M6XG4gICAgICAgICAgcmV0dXJuIGNyb3NzUG9pbnRTaGFkZXIoKTtcblxuICAgICAgICBjYXNlIGQzU2hhcGUuc3ltYm9sRGlhbW9uZDpcbiAgICAgICAgICByZXR1cm4gZGlhbW9uZFBvaW50U2hhZGVyKCk7XG5cbiAgICAgICAgY2FzZSBkM1NoYXBlLnN5bWJvbFN0YXI6XG4gICAgICAgICAgcmV0dXJuIHN0YXJQb2ludFNoYWRlcigpO1xuXG4gICAgICAgIGNhc2UgZDNTaGFwZS5zeW1ib2xXeWU6XG4gICAgICAgICAgcmV0dXJuIHd5ZVBvaW50U2hhZGVyKCk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbmlzZWQgc3ltYm9sOiBcIi5jb25jYXQoc3ltYm9sKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgY29uc3RhbnRBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGJhc2UgPSBiYXNlQXR0cmlidXRlQnVpbGRlcigpLmRpdmlzb3IoMSk7XG4gICAgICB2YXIgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICB2YXIgZGlydHkgPSB0cnVlO1xuXG4gICAgICB2YXIgY29uc3RhbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBjb25zdGFudEF0dHJpYnV0ZShwcm9ncmFtQnVpbGRlcikge1xuICAgICAgICBiYXNlKHByb2dyYW1CdWlsZGVyKTtcblxuICAgICAgICBpZiAoIWRpcnR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGFuIGFycmF5LCByZWNlaXZlZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBiYXNlLnNpemUoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGFycmF5IG9mIGxlbmd0aDogXCIuY29uY2F0KGJhc2Uuc2l6ZSgpLCBcIiwgcmVjaWV2ZWQgYXJyYXkgb2YgbGVuZ3RoOiBcIikuY29uY2F0KHZhbHVlLmxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdsID0gcHJvZ3JhbUJ1aWxkZXIuY29udGV4dCgpO1xuICAgICAgICBnbFtcInZlcnRleEF0dHJpYlwiLmNvbmNhdCh2YWx1ZS5sZW5ndGgsIFwiZnZcIildKGJhc2UubG9jYXRpb24oKSwgdmFsdWUpO1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYmFzZS5sb2NhdGlvbigpKTtcbiAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0YW50QXR0cmlidXRlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICBjb25zdGFudEF0dHJpYnV0ZS52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50QXR0cmlidXRlO1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoY29uc3RhbnRBdHRyaWJ1dGUsIGJhc2UsICdub3JtYWxpemVkJywgJ3NpemUnLCAnbG9jYXRpb24nKTtcbiAgICAgIHJldHVybiBjb25zdGFudEF0dHJpYnV0ZTtcbiAgICB9KTtcblxuICAgIHZhciBmaWxsQ29sb3IkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5pdGlhbFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbMCwgMCwgMCwgMV07XG4gICAgICB2YXIgcHJvamVjdGVkQXR0cmlidXRlID0gYXR0cmlidXRlKCkuc2l6ZSg0KTtcbiAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgIHZhciBkaXJ0eSA9IHRydWU7XG5cbiAgICAgIHZhciBmaWxsQ29sb3IkMiA9IGZ1bmN0aW9uIGZpbGxDb2xvciQyKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLnZlcnRleFNoYWRlcigpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKGZpbGxDb2xvci5oZWFkZXIpLmFwcGVuZEJvZHlJZk5vdEV4aXN0cyhmaWxsQ29sb3IuYm9keSk7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLmZyYWdtZW50U2hhZGVyKCkuYXBwZW5kSGVhZGVySWZOb3RFeGlzdHMoZmlsbENvbG9yJDEuaGVhZGVyKS5hcHBlbmRCb2R5SWZOb3RFeGlzdHMoZmlsbENvbG9yJDEuYm9keSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuYnVmZmVycygpLmF0dHJpYnV0ZSgnYUZpbGxDb2xvcicsIGNvbnN0YW50QXR0cmlidXRlKHZhbHVlKS5zaXplKDQpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAoIWRpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBUaGUgZm9sbG93aW5nIGxpbmUgaXMgZXhwZW5zaXZlIGFuZCBpcyB0aGUgb25lIHdlIHdhbnQgdG8gc2tpcCxcbiAgICAgICAgICAvLyB0aGUgcmVzdCBhcmVuJ3QuXG5cblxuICAgICAgICAgIHByb2plY3RlZEF0dHJpYnV0ZS52YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgcHJvZ3JhbUJ1aWxkZXIuYnVmZmVycygpLmF0dHJpYnV0ZSgnYUZpbGxDb2xvcicsIHByb2plY3RlZEF0dHJpYnV0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24sIHJlY2VpdmVkIFwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGZpbGxDb2xvciQyLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGxDb2xvciQyO1xuICAgICAgfTtcblxuICAgICAgZDNmY1JlYmluZC5yZWJpbmQoZmlsbENvbG9yJDIsIHByb2plY3RlZEF0dHJpYnV0ZSwgJ2RhdGEnKTtcbiAgICAgIHJldHVybiBmaWxsQ29sb3IkMjtcbiAgICB9KTtcblxuICAgIHZhciBzdHJva2VDb2xvciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFswLCAwLCAwLCAxXTtcbiAgICAgIHZhciBwcm9qZWN0ZWRBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUoKS5zaXplKDQpO1xuICAgICAgdmFyIHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgdmFyIGRpcnR5ID0gdHJ1ZTtcblxuICAgICAgdmFyIHN0cm9rZUNvbG9yJDIgPSBmdW5jdGlvbiBzdHJva2VDb2xvciQyKHByb2dyYW1CdWlsZGVyKSB7XG4gICAgICAgIHByb2dyYW1CdWlsZGVyLnZlcnRleFNoYWRlcigpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKHN0cm9rZUNvbG9yLmhlYWRlcikuYXBwZW5kQm9keUlmTm90RXhpc3RzKHN0cm9rZUNvbG9yLmJvZHkpO1xuICAgICAgICBwcm9ncmFtQnVpbGRlci5mcmFnbWVudFNoYWRlcigpLmFwcGVuZEhlYWRlcklmTm90RXhpc3RzKHN0cm9rZUNvbG9yJDEuaGVhZGVyKS5hcHBlbmRCb2R5SWZOb3RFeGlzdHMoc3Ryb2tlQ29sb3IkMS5ib2R5KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9ncmFtQnVpbGRlci5idWZmZXJzKCkuYXR0cmlidXRlKCdhU3Ryb2tlQ29sb3InLCBjb25zdGFudEF0dHJpYnV0ZSh2YWx1ZSkuc2l6ZSg0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFkaXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gVGhlIGZvbGxvd2luZyBsaW5lIGlzIGV4cGVuc2l2ZSBhbmQgaXMgdGhlIG9uZSB3ZSB3YW50IHRvIHNraXAsXG4gICAgICAgICAgLy8gdGhlIHJlc3QgYXJlbid0LlxuXG5cbiAgICAgICAgICBwcm9qZWN0ZWRBdHRyaWJ1dGUudmFsdWUodmFsdWUpO1xuICAgICAgICAgIHByb2dyYW1CdWlsZGVyLmJ1ZmZlcnMoKS5hdHRyaWJ1dGUoJ2FTdHJva2VDb2xvcicsIHByb2plY3RlZEF0dHJpYnV0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24sIHJlY2VpdmVkIFwiLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlydHkgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHN0cm9rZUNvbG9yJDIudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Ryb2tlQ29sb3IkMjtcbiAgICAgIH07XG5cbiAgICAgIGQzZmNSZWJpbmQucmViaW5kKHN0cm9rZUNvbG9yJDIsIHByb2plY3RlZEF0dHJpYnV0ZSwgJ2RhdGEnKTtcbiAgICAgIHJldHVybiBzdHJva2VDb2xvciQyO1xuICAgIH0pO1xuXG4gICAgZXhwb3J0cy53ZWJnbEFkamFjZW50QXR0cmlidXRlID0gYWRqYWNlbnRBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy53ZWJnbEF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLndlYmdsQmFzZUF0dHJpYnV0ZSA9IGJhc2VBdHRyaWJ1dGVCdWlsZGVyO1xuICAgIGV4cG9ydHMud2ViZ2xCdWZmZXJCdWlsZGVyID0gYnVmZmVyQnVpbGRlcjtcbiAgICBleHBvcnRzLndlYmdsRWxlbWVudEluZGljZXMgPSBlbGVtZW50SW5kaWNlcztcbiAgICBleHBvcnRzLndlYmdsRmlsbENvbG9yID0gZmlsbENvbG9yJDI7XG4gICAgZXhwb3J0cy53ZWJnbFByb2dyYW1CdWlsZGVyID0gcHJvZ3JhbUJ1aWxkZXI7XG4gICAgZXhwb3J0cy53ZWJnbFNjYWxlTGluZWFyID0gbGluZWFyO1xuICAgIGV4cG9ydHMud2ViZ2xTY2FsZUxvZyA9IGxvZztcbiAgICBleHBvcnRzLndlYmdsU2NhbGVNYXBwZXIgPSBzY2FsZU1hcHBlcjtcbiAgICBleHBvcnRzLndlYmdsU2NhbGVQb3cgPSBwb3c7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc0FyZWEgPSBhcmVhJDI7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc0JhciA9IGJhciQyO1xuICAgIGV4cG9ydHMud2ViZ2xTZXJpZXNCb3hQbG90ID0gYm94UGxvdCQyO1xuICAgIGV4cG9ydHMud2ViZ2xTZXJpZXNDYW5kbGVzdGljayA9IGNhbmRsZXN0aWNrJDI7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc0Vycm9yQmFyID0gZXJyb3JCYXIkMjtcbiAgICBleHBvcnRzLndlYmdsU2VyaWVzTGluZSA9IGxpbmU7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc09obGMgPSBvaGxjJDI7XG4gICAgZXhwb3J0cy53ZWJnbFNlcmllc1BvaW50ID0gcG9pbnQ7XG4gICAgZXhwb3J0cy53ZWJnbFNoYWRlckJ1aWxkZXIgPSBzaGFkZXJCdWlsZGVyO1xuICAgIGV4cG9ydHMud2ViZ2xTdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yJDI7XG4gICAgZXhwb3J0cy53ZWJnbFN5bWJvbE1hcHBlciA9IHN5bWJvbE1hcHBlcjtcbiAgICBleHBvcnRzLndlYmdsVHlwZXMgPSB0eXBlcztcbiAgICBleHBvcnRzLndlYmdsVW5pZm9ybSA9IHVuaWZvcm07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
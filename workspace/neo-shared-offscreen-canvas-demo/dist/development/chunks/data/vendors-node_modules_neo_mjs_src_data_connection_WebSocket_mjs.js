"use strict";
(self["webpackChunkmainapp"] = self["webpackChunkmainapp"] || []).push([["vendors-node_modules_neo_mjs_src_data_connection_WebSocket_mjs"],{

/***/ "./node_modules/neo.mjs/src/data/connection/WebSocket.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/neo.mjs/src/data/connection/WebSocket.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./node_modules/neo.mjs/src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./node_modules/neo.mjs/src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    static getStaticConfig() {return {
        /**
         * True automatically applies the core.Observable mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         */
        socket_: null
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket();
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            me.createSocket();

            callback && me.on('open', {
                callback,
                scope : scope || me,
                single: true
            });
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me      = this,
            channel = me.channel;

        console.log('WS: Sending message', (channel ? '\nChannel: ' + channel : ''), '\nData:', data);

        return JSON.stringify(channel ? {channel, data} : data);
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createInterceptor(value, 'send', me.beforeSend, me);
        }

        return value;
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason);
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress);
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args);
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        console.log('onClose', event, reason, wasClean);
    }

    /**
     *
     */
    onError() {
        console.log('onError', arguments);
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        console.log('onMessage', data);

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId];
        }
    }

    /**
     *
     */
    onOpen() {
        this.fire('open', {scope: this});
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++;
        });
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me     = this,
            socket = me.socket,
            d      = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d);
                }, me, {single: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

Neo.applyClassConfig(Socket);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Socket);


/***/ }),

/***/ "./node_modules/neo.mjs/src/util/Function.mjs":
/*!****************************************************!*\
  !*** ./node_modules/neo.mjs/src/util/Function.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");


/**
 * @class Neo.util.Function
 * @extends Neo.core.Base
 */
class NeoFunction extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.util.Function'
         * @protected
         */
        className: 'Neo.util.Function'
    }}

    /**
     * Append args instead of prepending them
     * @param {Object} scope
     * @returns {Function}
     */
    static bindAppend(scope) {
        const fn   = this,
              args = [].slice.call(arguments).slice(1);

        return function() {
            return fn.apply(scope, [].slice.call(arguments).concat(args));
        }
    }

    /**
     * Intended for functions with 1 param where the interceptor can change the value
     * @param {Object} target
     * @param {String} targetMethodName
     * @param {Function} interceptFunction
     * @param {Object} scope=target
     * @returns {Function}
     */
    static createInterceptor(target, targetMethodName, interceptFunction, scope) {
        let targetMethod = target[targetMethodName];

        return (target[targetMethodName] = function(value) {
            return targetMethod.call(target, interceptFunction.call(scope || target, value));
        });
    }

    /**
     * @param {Neo.core.Base} target
     * @param {String} methodName
     * @param {Function} fn
     * @param {Object} scope
     * @returns {Function}
     */
    static createSequence(target, methodName, fn, scope) {
        let method = target[methodName] || Neo.emptyFn;

        return (target[methodName] = function() {
            method.apply(this, arguments);
            return fn.apply(scope || this, arguments);
        });
    }

    /**
     * The interceptor can prevent the targetMethod from getting executed in case it returns false.
     * @param {Object} target
     * @param {String} targetMethodName
     * @param {Function} interceptFunction
     * @param {Object} scope=target
     * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
     * @returns {Function}
     */
    static intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
        let targetMethod = target[targetMethodName];

        return (target[targetMethodName] = function() {
            return (interceptFunction.apply(scope || target, arguments) === false)
                ? preventedReturnValue
                : targetMethod.apply(target, arguments);
        });
    }
}

Neo.applyClassConfig(NeoFunction);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NeoFunction);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2RhdGEvdmVuZG9ycy1ub2RlX21vZHVsZXNfbmVvX21qc19zcmNfZGF0YV9jb25uZWN0aW9uX1dlYlNvY2tldF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNJO0FBQ0U7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLGVBQWU7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLFlBQVksNEVBQTZCO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsTUFBTSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDalFjOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBSTtBQUM5Qix3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFpbmFwcC8uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9kYXRhL2Nvbm5lY3Rpb24vV2ViU29ja2V0Lm1qcyIsIndlYnBhY2s6Ly9tYWluYXBwLy4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL3V0aWwvRnVuY3Rpb24ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9GdW5jdGlvbiBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgZnJvbSAnLi4vLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjaGFubmVsPW51bGxcbiAgICAgKi9cbiAgICBjaGFubmVsID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4UmVjb25uZWN0QXR0ZW1wdHM9NVxuICAgICAqL1xuICAgIG1heFJlY29ubmVjdEF0dGVtcHRzID0gNVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVzc2FnZUNhbGxiYWNrcz17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXNzYWdlQ2FsbGJhY2tzID0ge31cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1lc3NhZ2VJZD0xXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lc3NhZ2VJZCA9IDFcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJlY29ubmVjdEF0dGVtcHRzPTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVjb25uZWN0QXR0ZW1wdHMgPSAwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNlcnZlckFkZHJlc3M9bnVsbFxuICAgICAqL1xuICAgIHNlcnZlckFkZHJlc3MgPSBudWxsXG5cbiAgICBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBvYnNlcnZhYmxlOiB0cnVlXG4gICAgfX1cblxuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc29ja2V0LWNvbm5lY3Rpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc29ja2V0LWNvbm5lY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7V2ViU29ja2V0fG51bGx9IHNvY2tldF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzb2NrZXRfOiBudWxsXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAgICovXG4gICAgYXR0ZW1wdFJlY29ubmVjdChjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZWNvbm5lY3RBdHRlbXB0cysrO1xuXG4gICAgICAgIGlmIChtZS5yZWNvbm5lY3RBdHRlbXB0cyA8IG1lLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVTb2NrZXQoKTtcblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgbWUub24oJ29wZW4nLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgc2NvcGUgOiBzY29wZSB8fCBtZSxcbiAgICAgICAgICAgICAgICBzaW5nbGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0cyB0aGUgV2ViU29ja2V0IHNlbmQgY2FsbHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgYmVmb3JlU2VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNoYW5uZWwgPSBtZS5jaGFubmVsO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdXUzogU2VuZGluZyBtZXNzYWdlJywgKGNoYW5uZWwgPyAnXFxuQ2hhbm5lbDogJyArIGNoYW5uZWwgOiAnJyksICdcXG5EYXRhOicsIGRhdGEpO1xuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjaGFubmVsID8ge2NoYW5uZWwsIGRhdGF9IDogZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc29ja2V0IGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtXZWJTb2NrZXR8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U29ja2V0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHtcbiAgICAgICAgICAgICAgICBvbmNsb3NlICA6IG1lLm9uQ2xvc2UgIC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbmVycm9yICA6IG1lLm9uRXJyb3IgIC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbm1lc3NhZ2U6IG1lLm9uTWVzc2FnZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbm9wZW4gICA6IG1lLm9uT3BlbiAgIC5iaW5kKG1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE5lb0Z1bmN0aW9uLmNyZWF0ZUludGVyY2VwdG9yKHZhbHVlLCAnc2VuZCcsIG1lLmJlZm9yZVNlbmQsIG1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIGRlZmF1bHRzIHRvIDEwMDBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlYXNvbl1cbiAgICAgKi9cbiAgICBjbG9zZShjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVNvY2tldCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuc2VydmVyQWRkcmVzcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2xvc2VFdmVudH0gZXZlbnQgVGhlIFdlYnNvY2tldCBnZW5lcmF0ZWQgQ2xvc2VFdmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgZXZlbnQuY29kZSBUaGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSBwcm92aWRlZCBieSB0aGUgc2VydmVyXG4gICAgICpcbiAgICAgKiAgICAgICAgQ29kZSAgICAgICAgTmFtZSAgICAgICAgICAgICAgICAgIERlc2NyaXB0aW9uXG4gICAgICogICAgICAgIDAtOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBhbmQgbm90IHVzZWQuXG4gICAgICogICAgICAgIDEwMDAgICAgICAgIENMT1NFX05PUk1BTCAgICAgICAgICBOb3JtYWwgY2xvc3VyZTsgdGhlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB3aGF0ZXZlciBwdXJwb3NlIGZvciB3aGljaCBpdCB3YXMgY3JlYXRlZC5cbiAgICAgKiAgICAgICAgMTAwMSAgICAgICAgQ0xPU0VfR09JTkdfQVdBWSAgICAgIFRoZSBlbmRwb2ludCBpcyBnb2luZyBhd2F5LCBlaXRoZXIgYmVjYXVzZSBvZiBhIHNlcnZlciBmYWlsdXJlIG9yIGJlY2F1c2UgdGhlIGJyb3dzZXIgaXMgbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2UgdGhhdCBvcGVuZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICogICAgICAgIDEwMDIgICAgICAgIENMT1NFX1BST1RPQ09MX0VSUk9SICBUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gZHVlIHRvIGEgcHJvdG9jb2wgZXJyb3IuXG4gICAgICogICAgICAgIDEwMDMgICAgICAgIENMT1NFX1VOU1VQUE9SVEVEICAgICBUaGUgY29ubmVjdGlvbiBpcyBiZWluZyB0ZXJtaW5hdGVkIGJlY2F1c2UgdGhlIGVuZHBvaW50IHJlY2VpdmVkIGRhdGEgb2YgYSB0eXBlIGl0IGNhbm5vdCBhY2NlcHQgKGZvciBleGFtcGxlLCBhIHRleHQtb25seSBlbmRwb2ludCByZWNlaXZlZCBiaW5hcnkgZGF0YSkuXG4gICAgICogICAgICAgIDEwMDQgICAgICAgIENMT1NFX1RPT19MQVJHRSAgICAgICBUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkIHRoYXQgaXMgdG9vIGxhcmdlLlxuICAgICAqICAgICAgICAxMDA1ICAgICAgICBDTE9TRV9OT19TVEFUVVMgICAgICAgUmVzZXJ2ZWQuICBJbmRpY2F0ZXMgdGhhdCBubyBzdGF0dXMgY29kZSB3YXMgcHJvdmlkZWQgZXZlbiB0aG91Z2ggb25lIHdhcyBleHBlY3RlZC5cbiAgICAgKiAgICAgICAgMTAwNiAgICAgICAgQ0xPU0VfQUJOT1JNQUwgICAgICAgIFJlc2VydmVkLiBVc2VkIHRvIGluZGljYXRlIHRoYXQgYSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseSAodGhhdCBpcywgd2l0aCBubyBjbG9zZSBmcmFtZSBiZWluZyBzZW50KSB3aGVuIGEgc3RhdHVzIGNvZGUgaXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgIDEwMDctMTk5OSAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBieSB0aGUgV2ViU29ja2V0IHN0YW5kYXJkLlxuICAgICAqICAgICAgICAyMDAwLTI5OTkgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgZm9yIHVzZSBieSBXZWJTb2NrZXQgZXh0ZW5zaW9ucy5cbiAgICAgKiAgICAgICAgMzAwMC0zOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3IgdXNlIGJ5IGxpYnJhcmllcyBhbmQgZnJhbWV3b3Jrcy4gTWF5IG5vdCBiZSB1c2VkIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgKiAgICAgICAgNDAwMC00OTk5ICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3IgdXNlIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgcmVhc29uIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHJlYXNvbiB0aGUgc2VydmVyIGNsb3NlZCB0aGUgY29ubmVjdGlvbi4gVGhpcyBpcyBzcGVjaWZpYyB0byB0aGUgcGFydGljdWxhciBzZXJ2ZXIgYW5kIHN1Yi1wcm90b2NvbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgIHdhc0NsZWFuIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWQuXG4gICAgICovXG4gICAgb25DbG9zZShldmVudCwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICBjb25zb2xlLmxvZygnb25DbG9zZScsIGV2ZW50LCByZWFzb24sIHdhc0NsZWFuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRXJyb3IoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkVycm9yJywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ29uTWVzc2FnZScsIGRhdGEpO1xuXG4gICAgICAgIGlmIChkYXRhLm1JZCkge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1JZF0ucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIG1lLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tSWRdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnb3BlbicsIHtzY29wZTogdGhpc30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1lLm1lc3NhZ2VDYWxsYmFja3NbbWUubWVzc2FnZUlkXSA9IHtyZWplY3QsIHJlc29sdmV9O1xuXG4gICAgICAgICAgICBtZS5zZW5kTWVzc2FnZSh7ZGF0YSwgbUlkOiBtZS5tZXNzYWdlSWR9KTtcbiAgICAgICAgICAgIG1lLm1lc3NhZ2VJZCsrO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzb2NrZXQgPSBtZS5zb2NrZXQsXG4gICAgICAgICAgICBkICAgICAgPSBkYXRhO1xuXG4gICAgICAgIC8vIENPTk5FQ1RJTkcgIDAgICBUaGUgY29ubmVjdGlvbiBpcyBub3QgeWV0IG9wZW4uXG4gICAgICAgIC8vIE9QRU4gICAgICAgIDEgICBUaGUgY29ubmVjdGlvbiBpcyBvcGVuIGFuZCByZWFkeSB0byBjb21tdW5pY2F0ZS5cbiAgICAgICAgLy8gQ0xPU0lORyAgICAgMiAgIFRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBwcm9jZXNzIG9mIGNsb3NpbmcuXG4gICAgICAgIC8vIENMT1NFRCAgICAgIDMgICBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgb3IgY291bGRuJ3QgYmUgb3BlbmVkLlxuXG4gICAgICAgIC8vIElmIHNvY2tldCBpcyBub3QgeWV0IHJlYWR5IGxldCdzIGRlZmVyIHRvIG9wZW4gdGhlbiByZXNlbmRcbiAgICAgICAgc3dpdGNoIChzb2NrZXQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ0xPU0VEOlxuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ0xPU0lORzpcbiAgICAgICAgICAgICAgICBtZS5hdHRlbXB0UmVjb25uZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgbWUub24oJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoZCk7XG4gICAgICAgICAgICAgICAgfSwgbWUsIHtzaW5nbGU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0Lk9QRU46XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKFNvY2tldCk7XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldDtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5GdW5jdGlvblxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBOZW9GdW5jdGlvbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5GdW5jdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuRnVuY3Rpb24nXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhcmdzIGluc3RlYWQgb2YgcHJlcGVuZGluZyB0aGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBiaW5kQXBwZW5kKHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGZuICAgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlbmRlZCBmb3IgZnVuY3Rpb25zIHdpdGggMSBwYXJhbSB3aGVyZSB0aGUgaW50ZXJjZXB0b3IgY2FuIGNoYW5nZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE1ldGhvZE5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10YXJnZXRcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUludGVyY2VwdG9yKHRhcmdldCwgdGFyZ2V0TWV0aG9kTmFtZSwgaW50ZXJjZXB0RnVuY3Rpb24sIHNjb3BlKSB7XG4gICAgICAgIGxldCB0YXJnZXRNZXRob2QgPSB0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV07XG5cbiAgICAgICAgcmV0dXJuICh0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldE1ldGhvZC5jYWxsKHRhcmdldCwgaW50ZXJjZXB0RnVuY3Rpb24uY2FsbChzY29wZSB8fCB0YXJnZXQsIHZhbHVlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2VxdWVuY2UodGFyZ2V0LCBtZXRob2ROYW1lLCBmbiwgc2NvcGUpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXSB8fCBOZW8uZW1wdHlGbjtcblxuICAgICAgICByZXR1cm4gKHRhcmdldFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyY2VwdG9yIGNhbiBwcmV2ZW50IHRoZSB0YXJnZXRNZXRob2QgZnJvbSBnZXR0aW5nIGV4ZWN1dGVkIGluIGNhc2UgaXQgcmV0dXJucyBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE1ldGhvZE5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHByZXZlbnRlZFJldHVyblZhbHVlPW51bGwgVGhlIHZhbHVlIHRvIHJldHVybiBpbiBjYXNlIHRoZSBpbnRlcmNlcHRGdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnRlcmNlcHQodGFyZ2V0LCB0YXJnZXRNZXRob2ROYW1lLCBpbnRlcmNlcHRGdW5jdGlvbiwgc2NvcGUsIHByZXZlbnRlZFJldHVyblZhbHVlPW51bGwpIHtcbiAgICAgICAgbGV0IHRhcmdldE1ldGhvZCA9IHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXTtcblxuICAgICAgICByZXR1cm4gKHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIChpbnRlcmNlcHRGdW5jdGlvbi5hcHBseShzY29wZSB8fCB0YXJnZXQsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgID8gcHJldmVudGVkUmV0dXJuVmFsdWVcbiAgICAgICAgICAgICAgICA6IHRhcmdldE1ldGhvZC5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTmVvRnVuY3Rpb24pO1xuXG5leHBvcnQgZGVmYXVsdCBOZW9GdW5jdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==